[{"title":"jvm总结","url":"/2020/02/13/java基础/JVM/jvm总结/","content":"\n\n\n**1.JVM运行时数据区**\n\n![img](jvm总结\\1.png)\n\nJVM运行时数据区由以下组成：\n\n程序计数器：指向当前线程正在执行的字节码指令的地址行号等。（记录程序运行到哪里了）\n\n虚拟机栈：当前线程运行方法所需要的数据指令，返回地址\n\n本地方法栈：native方法使用的栈帧\n\n方法区：类信息，常量，静态变量等\n\nHeap：堆内存（存放对象实例）\n\n**2.java内存模型**\n\n![img](jvm总结\\2.png)\n\n由于对象的生命周期不一样，出现了分代，98%的对象在minorGC的时候会被回收掉\n\n结合图一可以看到，新生代和老年代是分配在堆内存中，而1.8以前的永久代是分配在方法区，1.8以后的元空间(meta space)是一个独立的内存。\n\n**为什么8：1：1**\n\n此处新生代的空间分配为8:1:1,主要由于新生代生命周期导致。如果只有两块如9：1，当s1中放入数据，那么下次GC将没有地方存放s1中的对象，将会直接进入老年代，将导致该对象很难回收\n\n\n\n注意 ，元空间相当于是动态扩容，只要内存够用\n\n\n\n**jvm参数配置**\n\nVM参数\n\nhttp://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html\n\n\n\n-Xms20M  starting\t起始堆内存大小\n\n-Xmx     max\t最大堆内存大小\n\n-Xmn     new\t新生代大小\n\n\n\n对象分配eden\n\n-XX:SurvivorRatio=8\n\n8:1:1\n\n\n\nTLAB  Thread Local Allaction Buffer  栈上分配\n\n\n\n对象很大\n\n​\t-XX:PretenureSizeThreshold=3145728   3M\n\n长期存活的对象 \n\n​\t-XX:MaxTenuringThreshold=15\n\n动态对象年龄判定\n\n​\t相同年龄所有对象的大小总和 > Survivor空间的一半\n\n​\t\n\n分配担保\n\n Minor GC 之前检查 \n\n 老年代最大可用连续空间是否>新生代所有对象总空间\n\n​\t\n\nMinor GC\t\t新生代垃圾回收\n\nMajor GC\t\told区垃圾回收\n\nFull  GC\t\tminor+major\n\nJVM调优最终目的减小垃圾回收\n\n**3.垃圾回收算法**\n\n引用\n\n​\t强  Object object = new Object();\n\n​\t软  SoftReference引用的对象\n\n​\t弱  WeakReference引用的对象\n\n​\t虚  PhantomReference引用的对象\n\n\n\n​\t\n\n回收\n\n​\t方法论\n\n​\t\t标记-清除算法\n\n​\t\t复制回收算法\n\n​\t\t标记-整理算法\n\n![img](jvm总结\\3.png)\n\n​\t垃圾收集器\n\n​\t\tSTW  Stop The World\n\n​\t\tSerial\n\n​\t\tParNew \n\n​\t\t\t-XX:ParallelGCThreads\n\n​\t\tParallel Scavenge （全局）\n\n​\t\t\t吞吐量 = 运行用户代码时间 / （运行用户代码时间  + 垃圾收集时间）\n\n​\t\t\t-XX:MaxGCPauseMillis=n\n\n​\t\t\t-XX:GCTimeRatio=n\n\n​\t\t\t-XX:UseAdaptiveSizePolicy   GC  Ergonomics\n\n​\t\tSerial Old\n\n​\t\t\tCMS备用预案  Concurrent Mode Failusre时使用\n\n​\t\t\t标记-整理算法\n\n​\t\tParallel Old\n\n​\t\t\t标记-整理算法\n\n​\t\tCMS\n\n​\t\t\t标记-清除算法\n\n​\t\t\t减少回收停顿时间\n\n​\t\t\t碎片 -XX:CMSInitiatingOccupancyFraction  \n\n​\t\t\tConcurrent Mode Failure 启用Serial Old\n\n​\t\t\t\n\n​\t\t\t-XX:+UseCMSCompactAtFullCollection\n\n​\t\t\t-XX:CMSFullGCsBeforeCompaction 执行多少次不压缩FullGC后 来一次带压缩的 0 表示每次都压\n\n​\t\t\t-XX:+UseConcMarkSweep\n\n​\t\tG1\n\n\n\n![img](jvm总结\\4.png)\n\n​\t\t\n\n​\t注：新生代均用复制回收算法\n\n\n\n\n\n**4.GC定位**\n\n如何查看当前的垃圾回收器\n\n​\t-XX:+PrintFlagsFinal\n\n​\t-XX:+PrintCommandLineFlags\n\n![img](jvm总结\\5.jpg)\n\n​\tserver client\n\n​\tMBean\n\nGC日志\n\n​\t1.输出日志\n\n​\t-XX:+PrintGCTimeStamps \n\n​\t-XX:+PrintGCDetails \n\n​\t-Xloggc:/home/administrator/james/gc.log\n\n​\t-XX:+PrintHeapAtGC\n\n​\t2.日志文件控制\n\n​\t-XX:-UseGCLogFileRotation\n\n​\t-XX:GCLogFileSize=8K\n\n​\t3.怎么看\n\n​\t\n\nJDK自带的 监控工具\n\nhttps://docs.oracle.com/javase/8/docs/technotes/tools/windows/toc.html\n\n​\tjmap -heap pid 堆使用情况\n\n​\tjstat  -gcutil pid 1000\n\n​\tjstack  线程dump \n\n​\tjvisualvm\n\n​\tjconsole\n\n​\t\n\nMAT\n\n​\thttp://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html\n\n​\t-XX:+HeapDumpOnOutOfMemoryError \n\n​\t-XX:HeapDumpPath=/home/administrator/james/error.hprof\n\n\n\n怀疑：\n\n​\t1.看GC日志  126719K->126719K(126720K)\n\n​\t2.dump\n\n​\t3.MAT\n\n​\t\t1.占用Retained Heap\n\n​\t\t2.看有没有GC Root指向\n\n​\t\n\n什么条件触发STW的Full GC呢？\n\nPerm空间不足；\n\nCMS GC时出现promotion failed和concurrent mode failure（concurrent mode failure发生的原因一般是CMS正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止CMS，直接进行Serial Old GC）；\n\n（promontion faild产生的原因是EDEN空间不足的情况下将EDEN与From survivor中的存活对象存入To survivor区时,To survivor区的空间不足，再次晋升到old gen区，而old gen区内存也不够的情况下产生了promontion faild从而导致full gc\t）\n\n\n\n统计得到的Young GC晋升到老年代的平均大小大于老年代的剩余空间；\n\n\n\n主动触发Full GC（执行jmap -histo:live [pid]）来避免碎片问题。\n\n​\t\n\n​\t\n\njava -Xms8m -Xmx64m -verbose:gc -Xloggc:/home/administrator/james/gc.log  -XX:+PrintHeapAtGC -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9004 -Djava.rmi.server.hostname=177.1.1.122 -jar jvm-demo1-0.0.1-SNAPSHOT.jar  > catalina.out  2>&1 &\n\n\n\njava -Xms128m -Xmx128m -verbose:gc -Xloggc:/home/administrator/james/gc.log  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/administrator/james/error.hprof -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC  -XX:+UseCMSCompactAtFullCollection -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9004 -Djava.rmi.server.hostname=177.1.1.122 -jar jvm-demo1-0.0.1-SNAPSHOT.jar  > catalina.out  2>&1 &\n\n \t\n\njava -Xms128m -Xmx128m -verbose:gc -Xloggc:/home/administrator/james/gc.log  -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintHeapAtGC -XX:HeapDumpPath=/home/administrator/james/error.hprof -XX:+PrintGCApplicationStoppedTime -XX:+PrintGCTimeStamps -XX:+PrintCommandLineFlags -XX:+PrintFlagsFinal -XX:+PrintGCDetails -XX:+UseCMSCompactAtFullCollection -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9004 -Djava.rmi.server.hostname=177.1.1.122 -jar jvm-demo1-0.0.1-SNAPSHOT.jar  > catalina.out  2>&1 &\n\n \t\n\n\n\n-XX:+CMSScavengeBeforeRemark\n\n​\t\n\n​\t\n\n\n\n\n\n\n\n​\t\t\n\n![img](jvm总结\\6.jpg)\n\n\n\n![img](jvm总结\\7.jpg)","tags":["jvm"]},{"title":"序列化","url":"/2019/07/20/java基础/分布式/序列化/","content":"\n\n## 实现一个序列化\n\n1.实现Serializable接口\n\n2.ObjectInputStream、ObjectOutputSream\n\n\n\n- 深拷贝：复制对应的所有变量和引用对应的实例，即引用对象为一个新对象而不是原来的对象\n\n  - 实现Cloneable接口，且重写clone()方法，将对象的引用克隆一次，传值\n\n    ```JAVA\n     \t@Override\n        public Object clone() throws CloneNotSupportedException {  \t\t\n    \t\t// 调用父类clone接口复制变量：\n            Student3 student = (Student3) super.clone();\n            // 本来是浅复制，现在将Teacher对象复制一份并重新set进来\n            student.setTeacher((Teacher2) student.getTeacher().clone());\n            return student;\n        }\n    \n    ```\n\n  - 序列化实现深克隆\n\n    ```java\n    public Object deepClone() throws IOException, ClassNotFoundException {\n            //序列化\n            ByteArrayOutputStream baos=new ByteArrayOutputStream();\n            ObjectOutputStream oos=new ObjectOutputStream(baos);\n    \n            oos.writeObject(this);\n    \n            //反序列化\n            ByteArrayInputStream bais=new \t\t\t\t\t\tByteArrayInputStream(baos.toByteArray());\n            ObjectInputStream ois=new ObjectInputStream(bais);\n            return ois.readObject();\n        }\n    ```\n\n    \n\n- 浅拷贝：复制对象的所有变量，但是引用的对象还是以前的对象。\n  \n  - 实现Cloneable接口，直接调用clone()方法\n\n## 序列化技术：\n\n- JACKSON\n\n\n```XML\n\t\t<dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-mapper-asl</artifactId>\n            <version>1.9.13</version>\n        </dependency>\n```\n\n  ```JAVA\nObjectMapper mapper=new ObjectMapper();\n          byte[] writeBytes=null;\n          Long start=System.currentTimeMillis();\n          writeBytes=mapper.writeValueAsBytes(person);//序列化\n          Person person1=mapper.readValue(writeBytes,Person.class);//反序列化\n          System.out.println(person1);\n  ```\n\n  - FastJson\n\n```XML\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.31</version>\n        </dependency>\n```\n\n```JAVA\nString result=JSON.toJSONString(person);//序列化\nPerson person=JSON.parseObject(text,Person.class);//反序列化\n```\n\n  - ProtoBuf\n\n```java\npublic class Person implements Serializable{\n\tprivate static final long serialVersionUID = 5711515415445643416L;\n    @Protobuf(fieldType = FieldType.STRING,order = 1)\n    private String name;\n\n    @Protobuf(fieldType = FieldType.INT32,order = 2)\n    private int age;\n```\n\n```xml\n        <dependency>\n            <groupId>com.baidu</groupId>\n            <artifactId>jprotobuf</artifactId>\n            <version>2.1.2</version>\n        </dependency>\n```\n\n```JAVA\nCodec<Person> personCodec= ProtobufProxy.create(Person.class,false);//此处较耗时\nbyte[] bytes=personCodec.encode(person);//序列化\nPerson person1=personCodec.decode(bytes);//反序列化\n```\n\n  - Hession\n\n```XML\n        <dependency>\n            <groupId>com.caucho</groupId>\n            <artifactId>hessian</artifactId>\n            <version>4.0.38</version>\n        </dependency>\n```\n\n```java\nByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\nHessianOutput ho=new HessianOutput(byteArrayOutputStream);\nho.writeObject(person);//序列化\n\nHessianInput hi=new HessianInput(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));\nPerson person=(Person)hi.readObject();//反序列化\n\n```\n\n\n\n","tags":["序列化"]},{"title":"rmi和webservice","url":"/2019/07/20/java基础/分布式/rmi和webserice/","content":"\n\n\n# RMI\n\n\n\n## 实现一个RMI程序\n\n- 编写服务端程序，暴露端口监听（LocateRegistry.createRegistry(8888);）\n- 绑定对象到对应接口(Naming.bind(\"rmi://localhost:8888/test\",hello);)\n- 客户端寻找接口(Hello hello=(Hello) Naming.lookup(\"rmi://localhost:8888/test\");)\n\n注意：\n\n- 接口hello必须继承java.rmi.Remote(接口方法抛出REMOTEEXCEPTION)\n- 实现类继承java.rmi.server.UnicastRemoteObject对象\n\n","tags":["RMI,WEBSERVICE"]},{"title":"socket连接","url":"/2019/07/17/java基础/分布式/Socket/","content":"\n\n# TCP/IP\n\nTCP/IP（Transmission Control Protocol/Internet Protocol）是一种可靠的网络数据传输控制协议。定义了主机如何连入因特网以及数据如何在他们之间传输的标准\n\n五层/七层模型：应用(表示，会话)，传输，网络，链路，物理传输\n\n![001](socket/001.png)\n\n- 三次握手\n\n  （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。\n\n  （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。\n\n  （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。\n\n- 四次挥手协议\n\n  （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。\n\n  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。\n\n  （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。\n\n  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。\n\n  \n\n  # Socket链接\n\n  \n\n  ## 1v1链接\n  - 客户端\n\n```java\npublic class SocketClient {\n\n  public static void main(String[] args) {\n    try {\n      Socket socket = new Socket(\"localhost\", 8888);\n      PrintWriter printWriter = new PrintWriter(socket.getOutputStream(), true);\n      printWriter.println(\"hello server\");\n      BufferedReader bufferedReader = new BufferedReader(\n          new InputStreamReader(socket.getInputStream()));\n      while (true) {\n        String serverData = bufferedReader.readLine();\n        if (serverData == null) {\n          break;\n        }\n        System.out.println(\"客户端消息：\" + serverData);\n      }\n      printWriter.close();\n      socket.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n```\n\n  - 服务端\n\n```java\n\npublic class SocketServer {\n\n  public static void main(String[] args) throws IOException {\n    ServerSocket serverSocket = null;\n    try {\n      serverSocket = new ServerSocket(8888);\n      while (true) {\n        Socket socket = serverSocket.accept();\n        new Thread(() -> {\n          try {\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(socket.getInputStream()));\n            PrintWriter printWriter = new PrintWriter(\n                new OutputStreamWriter(socket.getOutputStream()));\n            while (true) {\n              String clientData = reader.readLine();\n              if (clientData == null) {\n                break;\n              }\n              System.out.println(\"服务端消息：\" + clientData);\n              printWriter.println(\"hello.mike\");\n              printWriter.flush();\n            }\n\n          } catch (IOException e) {\n            e.printStackTrace();\n          }\n        }).start();\n      }\n    } catch (IOException e) {\n    } finally {\n      if (serverSocket != null) {\n        serverSocket.close();\n      }\n    }\n  }\n\n}\n```\n\n## 组播\n\n```java\npublic class MulticastServer {\n\n  public static void main(String[] args) {\n    //地址段：224.0.0.0-239.255.255.255\n    try {\n      InetAddress group=InetAddress.getByName(\"224.1.2.3\");\n      MulticastSocket multicastSocket=new MulticastSocket();\n      for (int i = 0; i <10 ; i++) {\n        String data=\"hello,index\"+i;\n        byte[] bytes=data.getBytes();\n        multicastSocket.send(new DatagramPacket(bytes,bytes.length,group,8888));\n        TimeUnit.SECONDS.sleep(2);\n      }\n\n    } catch (UnknownHostException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n\n\n}\n\n\n```\n\n\n\n\n\n```java\npublic class MulticastClient {\n\n  public static void main(String[] args) {\n\n    try {\n      InetAddress group=InetAddress.getByName(\"224.1.2.3\");\n      MulticastSocket multicastSocket=new MulticastSocket(8888);\n      multicastSocket.joinGroup(group);\n      byte[] bytes=new byte[1024];\n      while (true){\n        DatagramPacket datagramPacket=new DatagramPacket(bytes,bytes.length);\n        multicastSocket.receive(datagramPacket);\n        String msg=new String(datagramPacket.getData());\n        System.out.println(\"接受到msg：\"+msg);\n      }\n    } catch (UnknownHostException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n\n```\n\n","tags":["socket"]},{"title":"springboot源码分析","url":"/2019/06/22/java框架/springcloud/springboot/springboot请求响应分析/","content":"\n\n\n# springboot项目的创建\n\n- idea创建：File->New->Project...->Spring Initializr->Default:https://start.spring.io\n- web创建：登录https://start.spring.io/  ，选择对应springboot版本，设置group和artifact下载就行\\、\n\n注：springboot项目默认没有加载web，需要自己导入maven依赖\n\n```xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n```\n\n\n\n# springboot启动\n\n这里采用的是web下载方式，打开后，找到springboot启动类\n\n\n\n```java\npackage com.mkpassby.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringbootApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootApplication.class, args);\n\t}\n\n}\n\n```\n\n\n\n## springboot注解分析\n\n### @SpringBootApplication\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n...\n}\n```\n\n主要看有\n\n- @SpringBootConfiguration：声明配置类\n- @EnableAutoConfiguration：自动化配置\n- @ComponentScan：包扫描\n\n\n\n这里@EnableAutoConfiguration是通过将@Import导入AutoConfigurationImportSelector.class注入bean容器中\n\nspringboot中大量使用了@import注解：\n\n### @Import注解介绍\n\n@Import支持三种方式的导入：\n\n1. 直接导入一个配置类或者Bean\n2. 导入ImportSelector的实现类\n3. 导入ImportBeanDefinitionRegistrar的实现类\n\n\n\n```java\npublic class User {\n    private String name=\"aaa\";\n    public String getName() {\n        return name;  }  \n    public void setName(String name) {\n        this.name = name;  }}\n```\n\n```java\n@Import(User.class)\npublic class App {\n\n  public static void main(String[] args) {\n    ConfigurableApplicationContext configurableApplicationContext= SpringApplication.run(App.class,args);\n    System.out.println(configurableApplicationContext.getBean(User.class));\n    System.out.println(configurableApplicationContext.getBean(User.class).getName());\n    configurableApplicationContext.close();\n  }\n}\n```\n\nImportSelector方法的实现，return new String[]｛“com.mkpassby.demo.User”｝\n\n```java\npublic interface ImportSelector {\n  String[] selectImports(AnnotationMetadata var1);\n}\n\n```\n\n\n\nImportBeanDefinitionRegistrar和ImportSelector类似，注册额外的bean\n\n```JAVA\npublic class UserImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n  @Override\n  public void registerBeanDefinitions(AnnotationMetadata annotationMetadata,\n      BeanDefinitionRegistry beanDefinitionRegistry) {\n\n    beanDefinitionRegistry.registerBeanDefinition(\"User\",new RootBeanDefinition(User.class));\n  }\n}\n```\n\n \n\n\n\n## springboot启动分析\n\nSpringBoot启动由一个main方法调入，由静态run方法启动\n\n```java\n@SpringBootApplication\npublic class SpringbootApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootApplication.class, args);\n\t}\n}\n```\n\nrun方法中new SpringApplication(),在构造器调用WebApplicationType.deduceFromClasspath()，判定当前应用类型，我这里用的是2.1.6.RELEASE的版本，这里可以看到有一个WebApplicationType.REACTIVE，这个是对webflux非阻塞web框架的支持。\n\n```java\nstatic WebApplicationType deduceFromClasspath() {\n\t\tif (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\n\t\t\t\t&& !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\n\t\t\treturn WebApplicationType.REACTIVE;\n\t\t}\n\t\tfor (String className : SERVLET_INDICATOR_CLASSES) {\n\t\t\tif (!ClassUtils.isPresent(className, null)) {\n\t\t\t\treturn WebApplicationType.NONE;\n\t\t\t}\n\t\t}\n\t\treturn WebApplicationType.SERVLET;\n\t}\n```\n\n且在构造器中对所有包下的META-INF/spring.factories中配置的ApplicationContextInitializer和ApplicationListener实例化\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n\t\tthis.resourceLoader = resourceLoader;\n\t\tAssert.notNull(primarySources, \"PrimarySources must not be null\");\n\t\tthis.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n\t\tthis.webApplicationType = WebApplicationType.deduceFromClasspath();\n\t\tsetInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n\t\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n\t\tthis.mainApplicationClass = deduceMainApplicationClass();\n\t}\n```\n\n\n\n\n\n实例化SpringApplication完成后，调用run方法，实例化SpringApplicationRunListener，开启监听，准备数据等，其中核心在refreshContext(context)方法。在invokeBeanFactoryPostProcessors()方法中。该方法调用了PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())方法，此处第二个传参getBeanFactoryPostProcessors()传过来的是\n\n```properties\n0 = {SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor@3037} \n1 = {ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor@3038} \n2 = {ConfigurationClassPostProcessor@3787} \n```\n\n\n\n，这里是通过监听add到list中，此处具体实现需要进一步探究，最终通过postProcessBeanDefinitionRegistry进行BeanDefinition注册的处理。\n\n\n\n```java\n/**\n\t * Build and validate a configuration model based on the registry of\n\t * {@link Configuration} classes.\n\t */\n\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n\t\tString[] candidateNames = registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n            //获取所有标记了@Configuration注解类，封装成BeanDefinitionHolder集合\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// 没有 @Configuration 返回\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 根据@configuration中@Order排序\n\t\tconfigCandidates.sort((bd1, bd2) -> {\n\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr = null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr = (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator != null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n\t\t\t\t\tthis.importBeanNameGenerator = generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader == null) {\n\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n\t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n\t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames = newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}\n```\n\n\n\n\n\n继续跟进postProcessBeanDefinitionRegistry方法，后面调用了org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法,这里对@Configuration类进行了解析，包括@PropertySource，@ComponentScan，@Import，@ImportResource等。\n\n```java\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}\n```\n\n后续就是实例化所有的bean(Instantiate all remaining (non-lazy-init) singletons.),这里由于引入了spring-boot-starter-web依赖，特别说明下RequestMappingHandlerAdapter实例化。\n\n## RequestMappingHandlerAdapter实例化\n\n在实例化RequestMappingHandlerAdapter时会调用org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#requestMappingHandlerAdapter\n\n```java\n@Bean\n\tpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n\t\tRequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter();\n\t\tadapter.setContentNegotiationManager(mvcContentNegotiationManager());\n\t\tadapter.setMessageConverters(getMessageConverters());\n\t\tadapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());\n\t\tadapter.setCustomArgumentResolvers(getArgumentResolvers());\n\t\tadapter.setCustomReturnValueHandlers(getReturnValueHandlers());\n\n\t\tif (jackson2Present) {\n\t\t\tadapter.setRequestBodyAdvice(Collections.singletonList(new JsonViewRequestBodyAdvice()));\n\t\t\tadapter.setResponseBodyAdvice(Collections.singletonList(new JsonViewResponseBodyAdvice()));\n\t\t}\n\n\t\tAsyncSupportConfigurer configurer = new AsyncSupportConfigurer();\n\t\tconfigureAsyncSupport(configurer);\n\t\tif (configurer.getTaskExecutor() != null) {\n\t\t\tadapter.setTaskExecutor(configurer.getTaskExecutor());\n\t\t}\n\t\tif (configurer.getTimeout() != null) {\n\t\t\tadapter.setAsyncRequestTimeout(configurer.getTimeout());\n\t\t}\n\t\tadapter.setCallableInterceptors(configurer.getCallableInterceptors());\n\t\tadapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());\n\n\t\treturn adapter;\n\t}\n```\n进入getMessageConverters方法中，这里注意会由configureMessageConverters()方法进入org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#getMessageConverters\n\n```java\n@Override\n\tpublic void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\tfor (WebMvcConfigurer delegate : this.delegates) {\n\t\t\tdelegate.configureMessageConverters(converters);\n\t\t}\n\t}\n```\n\n\n\n\n\ngetMessageConverters方法，这里主要是从configureMessageConverters初始化messageConverters，以后后面的extendMessageConverters扩展messageCoverters。\n\n```java\nprotected final List<HttpMessageConverter<?>> getMessageConverters() {\n\t\tif (this.messageConverters == null) {\n\t\t\tthis.messageConverters = new ArrayList<>();\n\t\t\tconfigureMessageConverters(this.messageConverters);\n\t\t\tif (this.messageConverters.isEmpty()) {\n\t\t\t\taddDefaultHttpMessageConverters(this.messageConverters);\n\t\t\t}\n\t\t\textendMessageConverters(this.messageConverters);\n\t\t}\n\t\treturn this.messageConverters;\n\t}\n\n```\n\n这里如果需要扩展Http的请求扩展则可以查看类WebMvcConfigurer接口的注解说明，这里\n\n主要看\n\n``` JAVA\n\t/**\n\t * Configure the {@link HttpMessageConverter HttpMessageConverters} to use for reading or writing\n\t * to the body of the request or response. If no converters are added, a\n\t * default list of converters is registered.\n\t * <p><strong>Note</strong> that adding converters to the list, turns off\n\t * default converter registration. To simply add a converter without impacting\n\t * default registration, consider using the method\n\t * {@link #extendMessageConverters(java.util.List)} instead.\n\t * @param converters initially an empty list of converters\n\t */\n\tdefault void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}\n\n\t/**\n\t * A hook for extending or modifying the list of converters after it has been\n\t * configured. This may be useful for example to allow default converters to\n\t * be registered and then insert a custom converter through this method.\n\t * @param converters the list of configured converters to extend.\n\t * @since 4.1.3\n\t */\n\tdefault void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}\n```\n\n## 扩展\n\n这里贴出一段测试代码，可调整PostMapping中的produces和consumes查看变化\n\n\n\n通过对HttpConvert的修改，我们的代码可以适配成我们想要的入参或者出参，当然，应用场景多用json格式，可以考虑自己封装json对应的转换器，去除掉springboot中默认的json转换器\n\n```java\n@Configuration\npublic class MyWebMvcConfig implements WebMvcConfigurer {\n  @Override\n  public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n    converters.add(new PropertiesToUserConverter());\n\n  }\n  @Override\n  public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n    converters.add(new PropertiesToUserConverter());\n\n  }\n\n}\n```\n\n```java\n/**\n * @program: springboot\n * @description:\n * @author: mk_passby\n * @create: 2019-06-25 22:19\n **/\npublic class PropertiesToUserConverter extends AbstractHttpMessageConverter<User> {\n\n  public PropertiesToUserConverter() {\n    super(MediaType.valueOf(\"application/properties+person\"));\n    setDefaultCharset(Charset.forName(\"UTF-8\"));\n  }\n\n  @Override\n  protected boolean supports(Class<?> aClass) {\n    return aClass.isAssignableFrom(User.class);\n  }\n\n  //转换入参\n  @Override\n  protected User readInternal(Class<? extends User> aClass, HttpInputMessage httpInputMessage)\n      throws IOException, HttpMessageNotReadableException {\n    InputStream inputStream=httpInputMessage.getBody();\n    Properties properties=new Properties();\n    //请求内容properties转换为User对象\n    properties.load(inputStream);\n    User user=new User();\n    user.setName(properties.getProperty(\"user.name\"));\n    return user;\n  }\n\n  /***\n   * @param user\n   * @param httpOutputMessage\n   * @throws IOException\n   * @throws HttpMessageNotWritableException\n   */\n  //用properties格式写出去\n  @Override\n  protected void writeInternal(User user, HttpOutputMessage httpOutputMessage)\n      throws IOException, HttpMessageNotWritableException {\n    OutputStream outputStream=httpOutputMessage.getBody();\n    Properties properties=new Properties();\n    properties.setProperty(\"user.name\",user.getName());\n    properties.store(new OutputStreamWriter(outputStream,getDefaultCharset()),\"from web server\");\n  }\n}\n```\n\n```JAVA\n@RestController\npublic class RestControllerDemo {\n\n  @PostMapping(\n      value = \"user/properties/to/json\",\n      produces = \"application/properties+person\",//出参类型Accept\n      consumes = \"application/properties+person\"//入参类型Content-Type\n  )\n  public User userToProperties(@RequestBody User user) {\n    return user;\n  }\n}\n```\n\n用postman模拟请求，结果如下\n\n![1562769528306](springboot请求响应分析\\1562769528306.png)\n\n![1562769550293](springboot请求响应分析\\1562769550293.png)","tags":["springboot"]},{"title":"hexo搭建博客","url":"/2019/06/20/hexo/hexo博客搭建/","content":"\n这里主要贴出几个搭建过程中用到链接，自行参考，感谢感谢\n\n- [使用Hexo+Github一步步搭建属于自己的博客（基础）](https://www.cnblogs.com/fengxiongZz/p/7707219.html)\n- [使用Hexo+Github一步步搭建属于自己的博客（进阶）](https://www.cnblogs.com/fengxiongZz/p/7707568.html)\n- [hexo主题](https://hexo.io/themes/)\n- [Hexo-Aircloud-Blog主题安装教程](https://github.com/aircloud/hexo-aircloud-blog)\n\n\n\n| Hexo常用命令  | 作用                                           |\n| ------------- | ---------------------------------------------- |\n| hexo s(erver) | 启动本地服务器                                 |\n| hexo new \"AA\" | 新建\"AA\"文章                                   |\n| hexo d        | 部署到设定的仓库                               |\n| hexo clean    | 清除缓存文件 db.json 和已生成的静态文件 public |\n| hexo g        | 生成网站静态文件                               |\n\n"},{"title":"maven插件","url":"/2019/06/15/java基础/maven/maven插件/","content":"\n## maven插件\n\n#### 插件网址\n\n * [maven官网](https://maven.apache.org/plugins/,\"MAVEN-PLUGIN\")\n * [MojoHaus官网](http://www.mojohaus.org/plugins.html,\"MojoHous-Plugin\")\n\n#### 常用插件\n * [tomcat](https://tomcat.apache.org/maven-plugin-trunk/)\n\n\n```xml\n        <pluginManagement>\n          <plugins>\n            <plugin>\n              <groupId>org.apache.tomcat.maven</groupId>\n              <artifactId>tomcat6-maven-plugin</artifactId>\n              <version>2.3-SNAPSHOT</version>\n            </plugin>\n            <plugin>\n              <groupId>org.apache.tomcat.maven</groupId>\n              <artifactId>tomcat7-maven-plugin</artifactId>\n              <version>2.3-SNAPSHOT</version>\n            </plugin>\n          </plugins>\n        </pluginManagement>\n```\n* [assembly](https://maven.apache.org/plugins/maven-assembly-plugin/index.html)（打包）\n * zip\n * tar\n * tar.gz (or tgz)\n * tar.bz2 (or tbz2)\n * tar.snappy\n * tar.xz (or txz)\n * jar\n * dir\n * war\n* versions 统一升级版本号\n`mvn versions:set -DnewVersion=1.1`\n\n#### 自定义插件\n* [自定义Mojo](https://maven.apache.org/guides/plugin/guide-java-plugin-development.html)\n\n\n1.extends AbstractMojo\n```java\n    package sample.plugin;\n     \n    import org.apache.maven.plugin.AbstractMojo;\n    import org.apache.maven.plugin.MojoExecutionException;\n    import org.apache.maven.plugins.annotations.Mojo;\n     \n    /**\n     * Says \"Hi\" to the user.\n     *\n     */\n    @Mojo( name = \"sayhi\")\n    public class GreetingMojo extends AbstractMojo\n    {\n        public void execute() throws MojoExecutionException\n        {\n            getLog().info( \"Hello, world.\" );\n        }\n    }\n```\n2.pom参数\n\n```xml\n    <project>\n      <modelVersion>4.0.0</modelVersion>\n     \n      <groupId>sample.plugin</groupId>\n      <artifactId>hello-maven-plugin</artifactId>\n      <version>1.0-SNAPSHOT</version>\n      <packaging>maven-plugin</packaging>\n     \n      <name>Sample Parameter-less Maven Plugin</name>\n     \n      <dependencies>\n        <dependency>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-plugin-api</artifactId>\n          <version>3.0</version>\n        </dependency>\n     \n        <!-- dependencies to annotations -->\n        <dependency>\n          <groupId>org.apache.maven.plugin-tools</groupId>\n          <artifactId>maven-plugin-annotations</artifactId>\n          <version>3.4</version>\n          <scope>provided</scope>\n        </dependency>\n      </dependencies>\n    </project>\n```\n3.引用插件\n\n```xml\n    ...\n      <build>\n        <plugins>\n          <plugin>\n            <groupId>sample.plugin</groupId>\n            <artifactId>hello-maven-plugin</artifactId>\n            <version>1.0-SNAPSHOT</version>\n          </plugin>\n        </plugins>\n      </build>\n    ...\n```\n","tags":["maven"]},{"title":"maven基础","url":"/2019/05/19/java基础/maven/maven基础/","content":"\n\n## maven基础\n#### 优势\n- 相比传统项目，减少了手动导入工序，更加简便\n- 插件丰富\n- 构建简单\n\n\n#### 安装\n1. [maven下载地址](https://maven.apache.org/download.cgi，\"点击跳转\")\n2. 配置MVN_HOME，如JAVA_HOME类似\n3. 配置完成后，cmd输入`mvn-version` 检测是否配置成功\n4. 配置setting.xml，路径在maven安装目录conf目录下，打开setting.xml配置一个aliyun的仓库(默认仓库下载速度，以前也可以配置oschina打仓库，现在关闭了)\n\n\n```xml\n      <mirrors>\n      <!--aliyun仓库-->\n    \t<mirror>\n    \t  <id>alimaven</id>\n    \t  <name>aliyun maven</name>\n    \t  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    \t  <mirrorOf>central</mirrorOf>\n    \t</mirror>\n    \t<!-- 中央仓库1 -->\n        <mirror>\n            <id>repo1</id>\n            <mirrorOf>central</mirrorOf>\n            <name>Human Readable Name for this Mirror.</name>\n            <url>http://repo1.maven.org/maven2/</url>\n        </mirror>\n    \n        <!-- 中央仓库2 -->\n        <mirror>\n            <id>repo2</id>\n            <mirrorOf>central</mirrorOf>\n            <name>Human Readable Name for this Mirror.</name>\n            <url>http://repo2.maven.org/maven2/</url>\n        </mirror>\n        <!-- mirror\n         | Specifies a repository mirror site to use instead of a given repository. The repository that\n         | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n         | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n         |\n        <mirror>\n          <id>mirrorId</id>\n          <mirrorOf>repositoryId</mirrorOf>\n          <name>Human Readable Name for this Mirror.</name>\n          <url>http://my.repository.com/repo/path</url>\n        </mirror>\n         -->\n      </mirrors>\n```\n#### maven加载顺序\n首先是到用户目录下打.m2目录下setting中去找jar包，再去conf下的setting中找的\nmaven->/.m2/setting.xml->conf/settiong.xml\n\n\n#### pom.xml文件说明\n新建maven此处不做说明\n- groupid：公司名(网址）\n- artifactId：模块功能名(common，web，model，dao)\n- version：版本号\n- pachaging：打包方式，默认jar\n- dependencyManagemanet：依赖管理，统一版本号\n- Dependency：依赖\n * Type：默认jar\n * scope：\n   * complile：编译\n   * test：测试\n   * provided：已经提供了，不需要打进包\n   * runtime：运行时需要\n   * system：本地依赖的jar包 \n * exclusions：剔除不需要的jar包，多用于jar包冲突\n\n\n#### 基本的命令\n- compile:编译(mvn clean:compile)\n- test：运行test\n- package：打包\n- install：install到本地仓库\n- deploy：发布到远程仓库\n\n","tags":["maven"]},{"title":"代理模式","url":"/2018/07/15/java基础/设计模式/代理模式/","content":"\n\n\n代理模式就是新增加一个代理类，然后通过代理类来调用我们的实现。\n\n应用场景可以参考中介。\n\n# 1.未使用代理类场景\n\n        未使用代理类，即接口直接通过实现类实现功能\n\n![](代理模式\\1.jpg)\n\n接口：\n\n```java\npublic interface UserDao {\n    public void updateUser();\n    public void delUser();\n}\n```\n\n实现类：\n\n```java\npublic class UserDaoImpl implements UserDao{\n    @Override\n    public void updateUser() {\n        System.out.println(\"更新用户成功\");\n    }\n\n    @Override\n    public void delUser() {\n        System.out.println(\"删除用户成功\");\n    }\n}\n```\n\n测试类：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        UserDao userDao=new UserDaoImpl();\n        userDao.delUser();\n        userDao.updateUser();\n    }\n}\n\n```\n\n![](代理模式\\2.jpg)\n\n# 2.使用代理类\n\n## 2.1静态代理类\n\n即新增一个代理类，来管理我们的实现类，我们可以在代理类中添加一些动作\n\n![](代理模式\\3.jpg)\n\n将具体的实现通过构造器注入，然后代理类中调用我们对应的实现类的方法，\n\n新增的代理类如下：\n\n```java\npublic class StaticProxy implements UserDao{\n    private UserDao userDao;\n    public StaticProxy(UserDao userDao1)\n    {\n        this.userDao=userDao1;\n    }\n\n\n    @Override\n    public void updateUser() {\n        System.out.println(\"begin\");\n        userDao.updateUser();\n        System.out.println(\"end \");\n    }\n\n    @Override\n    public void delUser() {\n        System.out.println(\"begin\");\n        userDao.delUser();\n        System.out.println(\"end\");\n    }\n}\n```\n\n测试类\n\n```java\npublic class ProxyTest {\n    public static void main(String[] args) {\n        UserDao userDaoProxy=new StaticProxy(new UserDaoImpl());\n        userDaoProxy.delUser();\n        userDaoProxy.updateUser();\n    }\n}\n```\n\n结果如下\n\n![](代理模式\\4.jpg)\n\n## 2.2由静态代理类引出动态代理类\n\n- 可以看见，我们的静态代理类也实现了UserDao接口，当接口新增内容时，如新增一个query()方法，此时，我们的UserDaoImpl和StaticProxy类都要改变。-\n- 这是我们不想看见的，我们希望代理类可以不做修改，只需要修改我们的实现类的内容。由此引出了动态代理类(由此动态代理类的作用也显而易见) \n\n## 2.3动态代理类\n\n**定义动态代理工具类**\n\n返回指定的接口，将方法调用指定的调用处理程序的代理类的一个实例![](代理模式\\5.jpg)\n\n三个参数可以查阅JDK明细，主要需要实现`InvocationHandler`接口，实现`invoke`方法，通过反射实现对抽象接口方法的调用`method.invoke(target, args),`调其中target就是我们真正的实现类\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n```java\npublic class DynamicProxy {\n    public static void main(String[] args) {\n        UserDao userDao = (UserDao) Proxy.newProxyInstance(\n                UserDao.class.getClassLoader(),\n                new Class[]{UserDao.class},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        System.out.println(\"proxy begin\");\n                        Object result = method.invoke(new UserDaoImpl(), args);\n                        System.out.println(\"proxy end\");\n                        return result;\n                    }\n                }\n        );\n        userDao.delUser();\n    }，\n```\n\n\n\n# 3.总结\n\n- 核心在于ProxyGenerator.generateProxyClass，返回的byte[]为对象字节数组，生成代理对象。\n\n- 代理模式强调一些通用功能的扩展，在方法执行前，执行后添加点什么东西(LOG)，静态即单一的扩展，动态为多个类扩展，但是都引入新的代理类，从性能上讲，新的代理类会导致性能有所下降.","tags":["设计模式"]},{"title":"抽象工厂模式","url":"/2018/03/26/java基础/设计模式/抽象工厂模式/","content":"\n# 1.比较工厂方法模式\n\n## 工厂方法模式：\n\n-   一个抽象产品类，可以派生出多个具体产品类。\n-   一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。\n-   工厂方法模式只有一个抽象产品类(只能创建一个具体产品类的实例)\n\n## 抽象工厂模式：\n\n-   多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。\n-   一个抽象工厂类，可以派生出多个具体工厂类。\n-   抽象工厂模式有多个产品类(抽象工厂模式可以创建多个)\n\n# 2.抽象工厂模式举例\n\n比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。 这样A和B就是工厂，对应于抽象工厂；每个工厂生产的鼠标和键盘就是产品，对应于工厂方法；用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法） 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线\n\n# 3.总结\n\n1.  抽象工厂模式并不是指抽象类(不要混淆)，这里注意区分。\n2.  工厂方法模式更注重的是工厂方法的更改，更细微一点，如替换键盘由微软的生产方法替换到罗技的生产方法。而抽象工厂模式更注重的是工厂的替换，工厂方法的更改是工厂替换后考虑的点。\n3.  工厂方法模式可以看做是生产一个东西，抽象工厂模式看作生产一堆东西，只是对应的厂商不同(实现类)。如果工厂方法模式中Factory生产多个东西就是抽象工厂模式（个人理解）","tags":["设计模式"]},{"title":"工厂方法模式","url":"/2018/03/26/java基础/设计模式/工厂方法模式/","content":"\n# 1.普通简单工厂\n\n​        工厂类负责对实现同一接口的类进行实例创建,\n\n## 关系图如下\n\n![img](工厂方法模式\\1.png)\n\n## 代码如下：\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic Sender produce(String type) {\n\t\tif (\"mail\".equals(type)) {\n\t\t\treturn new MailSender();\n\t\t} else if (\"msg\".equals(type)) {\n\t\t\treturn new MsgSender();\n\t\t} else {\n\t\t\tSystem.out.println(\"请输入正确的类型\");\n\t\t\treturn null;\n\t\t}\n\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic interface Sender {\n\tpublic void send();\n\t\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class MailSender implements Sender{\n\n\t@Override\n\tpublic void send() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"this is a mailSender\");\n\t}\n\t\n\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class MsgSender implements Sender{\n\n\t@Override\n\tpublic void send() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"this is a msgSender\");\n\t}\n\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=new SendFactory().produce(\"msg\");\n\t\tsend.send();\n\t}\n}\n```\n\n运行结果：\n\n![img](工厂方法模式\\2.png)\n\n\n\n# 2.多方法简单工厂\n\n​        普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，多方法简单工厂为工厂提供创建每个实例的方法，避免这种问题。\n\n## 关系图如下\n\n![img](工厂方法模式\\3.png)\n\n## 代码如下：\n\n​        对比这里只有SenderFactory做了改变，这里仅贴出**SenderFactory**和**Test**的代码\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic Sender produceMail() {\n\t\treturn new MailSender();\n\t}\n\tpublic Sender produceMsg(){\n\t\treturn new MsgSender();\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=new SendFactory().produceMail();\n\t\tsend.send();\n\t}\n}\n```\n## 结果如下：\n\n![img](工厂方法模式\\4.png)\n\n\n\n# 3.静态方法简单工厂\n\n​        将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用\n\n​        即将SenderFactory中的produceMail()和produceMsg()改为静态方法。其他文件同样不变\n\n## 代码如下：\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic static Sender produceMail() {\n\t\treturn new MailSender();\n\t}\n\tpublic static Sender produceMsg(){\n\t\treturn new MsgSender();\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=SendFactory.produceMail();\n\t\tsend.send();\n\t}\n}\n```\n\n# 4.总结\n\n## 工厂模式的使用场景：\n\n​        当几个实现类都有相同的接口，可用工厂模式，易于扩展和修改。\n\n## 工厂模式选择：\n\n​        以上三种模式，第一种字符串有误会导致异常，第三种由于是静态方法，不需要重复创建对象，所以一般选择第三种——静态工厂方法\n\n\n\n# 5.工厂方法模式\n\n​        简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改。\n\n​        用工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码\n\n## 关系图如下：\n\n![img](工厂方法模式\\5.png)\n\n具体的实现这里就不再写出来了，只是给MailSenderFactory和MsgSenderFactory提供一格接口，让工厂类也易于扩展。\n\n\n\n## 这个模式的好处\n\n如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！","tags":["设计模式"]},{"title":"ssm项目搭建","url":"/2018/03/22/java框架/ssm项目搭建/","content":"\n# 基于xml配置\n\n## 1.所需架包\n\n```xml\n<dependencies>\n     \n        <dependency>\n              <groupId>javax.websocket</groupId>\n              <artifactId>javax.websocket-api</artifactId>\n              <version>1.1</version>\n        </dependency>\n        <dependency>\n              <groupId>org.springframework</groupId>\n              <artifactId>spring-websocket</artifactId>\n              <version>4.0.5.RELEASE</version>\n         </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>3.8.1</version>\n            <scope>test</scope>\n        </dependency>\n \n        <dependency>\n            <groupId>jstl</groupId>\n            <artifactId>jstl</artifactId>\n            <version>1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.2.3</version>\n        </dependency>\n        <dependency>\n            <groupId>com.google.code.gson</groupId>\n            <artifactId>gson</artifactId>\n            <version>2.2.4</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/net.sf.ezmorph/ezmorph -->\n        <dependency>\n            <groupId>net.sf.ezmorph</groupId>\n            <artifactId>ezmorph</artifactId>\n            <version>1.0.4</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils -->\n        <dependency>\n            <groupId>commons-beanutils</groupId>\n            <artifactId>commons-beanutils</artifactId>\n            <version>1.7.0</version>\n        </dependency>\n \n        <dependency>\n            <groupId>commons-collections</groupId>\n            <artifactId>commons-collections</artifactId>\n            <version>3.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib-ext-spring</artifactId>\n            <version>1.0.2</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-lang</groupId>\n            <artifactId>commons-lang</artifactId>\n            <version>2.6</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.0.1</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>1.2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-dbcp</groupId>\n            <artifactId>commons-dbcp</artifactId>\n            <version>1.4</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-pool</groupId>\n            <artifactId>commons-pool</artifactId>\n            <version>1.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.6.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator</artifactId>\n            <version>1.3.5</version>\n            <type>pom</type>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator-core</artifactId>\n            <version>1.3.5</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-logging</groupId>\n            <artifactId>commons-logging</artifactId>\n            <version>1.1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet.jsp</groupId>\n            <artifactId>jsp-api</artifactId>\n            <version>2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>servlet-api</artifactId>\n            <version>2.5</version>\n        </dependency>\n        <!-- ============================================== -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aspects</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-expression</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <!-- ============================================== -->\n        <dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-core-asl</artifactId>\n            <version>1.9.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-mapper-asl</artifactId>\n            <version>1.9.11</version>\n        </dependency>\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib</artifactId>\n            <version>2.3</version>\n            <classifier>jdk15</classifier>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.25</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n \n        <dependency>\n            <groupId>javax.mail</groupId>\n            <artifactId>mail</artifactId>\n            <version>1.4.3</version>\n        </dependency>\n \n       \n \n    </dependencies>\n```\n\n## 2.框架搭建\n\n### 2.1.html--->springMVC\n\n        将html页面的请求转发到springMVC，即转换servlet到springMVC，在WebRoot下的WEB-INF配置web.xml\n\n```xml\n<!-- springmvc前端控制器 -->\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet\n        </servlet-class>\n        <!--\n            contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等）\n            如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml）\n        -->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring/springmvc.xml</param-value>\n        </init-param>\n    </servlet>\n \n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <!--\n            第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析\n            第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析\n            使用此种方式可以实现 RESTful风格的url 第三种：/*，这样配置不对，使用这种配置，最终要转发到一个jsp页面时，\n            仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。\n        -->\n        <url-pattern>*.action</url-pattern>\n    </servlet-mapping>\n```\n\n处理页面乱码，过滤乱码问题\n\n```xml\n<!-- post乱码过虑器 -->\n    <filter>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter\n        </filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n```\n\n在web.xml中加载spring容器\n\n```xml\n<!-- 加载spring容器 -->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/classes/spring/applicationContext-*.xml\n        </param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n```\n\n部分errorpage的配置\n\n```xml\n<!-- 404 页面不存在错误 -->\n    <error-page>\n        <error-code>404</error-code>\n        <location>/error404.jsp</location>\n    </error-page>\n \n    <!-- 500 系统错误 -->\n    <error-page>\n        <error-code>500</error-code>\n        <location>/error500.jsp</location>\n    </error-page>\n \n    <!-- 405 页面不存在错误 -->\n    <error-page>\n        <error-code>405</error-code>\n        <location>/error405.jsp</location>\n    </error-page>\n \n    <!-- 400 提交数据异常错误 -->\n    <error-page>\n        <error-code>400</error-code>\n        <location>/error400.jsp</location>\n    </error-page>\n```\n\n至此，web.xml的配置已经完成\n\n### springMVC的处理：\n\n此处转发的请求是到classpath:spring/springmvc.xml中\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n \n    <!-- 对于注解的Handler可以单个配置\n    实际开发中建议使用组件扫描\n     -->\n    <!-- <bean class=\"cn.itcast.ssm.controller.ItemsController3\" /> -->\n    <!-- 可以扫描controller、service、...\n    这里让扫描controller，指定controller的包\n     -->\n    <context:component-scan base-package=\"com.learn.controller\"></context:component-scan>\n     \n     \n    <!-- 处理器映射器 将bean的name作为url进行查找 ，需要在配置Handler时指定beanname（就是url） \n    所有的映射器都实现 HandlerMapping接口。\n    -->\n    <bean\n        class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" />\n         \n    <!--注解映射器 -->\n    <!--<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>-->\n    <!--注解适配器 -->\n    <!--<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>-->\n     \n    <!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置\n    mvc:annotation-driven默认加载很多的参数绑定方法，\n    比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\n    实际开发时使用mvc:annotation-driven\n     -->\n    <mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\n         \n    <!-- 自定义参数绑定 -->\n    <bean id=\"conversionService\"\n        class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n        <!-- 转换器 -->\n        <property name=\"converters\">\n            <list>\n                <!-- 日期类型绑定器 -->\n                <bean class=\"com.learn.conv.DateConverter\" />\n            </list>\n        </property>\n    </bean>\n \n    <!-- 视图解析器\n    解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包\n     -->\n    <bean\n        class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <!-- 配置jsp路径的前缀 -->\n        <property name=\"prefix\" value=\"WEB-INF/jsp/\"/>\n        <!-- 配置jsp路径的后缀 -->\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n    <!-- 自定义的全局异常处理器 \n只要实现HandlerExceptionResolver接口就是全局异常处理器-->\n    <bean class=\"com.learn.exception.CustomExceptionResolver\"></bean>\n     \n     <!-- SpringMVC上传文件时，需要配置MultipartResolver处理器 -->  \n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">  \n        <!-- 指定所上传文件的总大小不能超过200KB。注意maxUploadSize属性的限制不是针对单个文件，而是所有文件的容量之和 -->  \n      <!--    <property name=\"maxUploadSize\" value=\"5242880\"/>  -->\n    </bean> \n     \n    <!--拦截器 -->\n<mvc:interceptors>\n    <!-- 登陆认证拦截器 -->\n    <mvc:interceptor>\n        <mvc:mapping path=\"/**\"/>\n        <bean class=\"com.learn.interceptor.LoginInterceptor\"></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n</beans>\n```\n\n同时这里贴出三个类（日期邦定器、登陆拦截器、全部异常处理 ）\n\n```java\npackage com.learn.exception;\n \nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n \nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.ModelAndView;\n \npublic class CustomExceptionResolver implements HandlerExceptionResolver{\n \n    public ModelAndView resolveException(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex) {\n        // TODO Auto-generated method stub\n        CustomException customException = null;\n        if(ex instanceof CustomException){\n            customException = (CustomException)ex;\n        }else{\n            customException = new CustomException(\"未知错误\");\n        }\n         \n        //错误信息\n        String message = customException.getMessage();\n         \n         \n        ModelAndView modelAndView = new ModelAndView();\n         \n        //将错误信息传到页面\n        modelAndView.addObject(\"message\", message);\n         \n        //指向错误页面\n        modelAndView.setViewName(\"error\");\n \n         \n        return modelAndView;\n    }\n     \n}\n```\n\n```java\npackage com.learn.conv;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.springframework.core.convert.converter.Converter;\npublic class DateConverter implements Converter<String, Date>{\n    public Date convert(String souce) {\n        System.out.println(souce.length());\n        if(souce.length() == 19){\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            try {\n                return format.parse(souce);\n            } catch (ParseException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }          \n        }else if(souce.length() == 10){\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n            try {\n                return format.parse(souce);\n            } catch (ParseException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }  \n        }else{\n            return null;\n        }\n    }\n}\n```\n\n```java\npackage com.learn.interceptor;\n \nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n \nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n \n/** \n* @author  \n* @version 创建时间：2016年4月26日 下午4:42:38 \n*  \n*/\npublic class LoginInterceptor implements HandlerInterceptor{\n \n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object arg2, Exception arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n        System.out.println(\"HandlerInterceptor1...afterCompletion\");\n         \n    }\n \n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object arg2, ModelAndView arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n        System.out.println(\"HandlerInterceptor1...postHandle\");\n         \n    }\n \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception {\n        String url=request.getRequestURI();\n        //System.out.println(\"url---------\"+url+\"--\"+url.indexOf(\"getModule.action\"));\n    if(url.indexOf(\"index.action\")>=0 ||url.indexOf(\"toLogin.action\")>=0||url.indexOf(\"msgDetail.action\")>=0\n            ||url.indexOf(\"findMsg.action\")>=0||url.indexOf(\"getModule.action\")>=0||url.indexOf(\"getModule2.action\")>=0\n            ||url.indexOf(\"getModule3.action\")>=0||url.indexOf(\"findMsg.action\")>=0||url.indexOf(\"indexSkip.action\")>=0\n            ||url.indexOf(\"searchType.action\")>=0||url.indexOf(\"searchRSIndex.action\")>=0||url.indexOf(\"getModule.action\")>=0     \n//             \n            )\n        {\n \n            return true;\n        }      \n        //判断session\n                HttpSession session  = request.getSession();\n                //从session中取出用户身份信息\n                String usercode = (String) session.getAttribute(\"userName\");               \n                if(usercode != null){\n                    //身份存在，放行\n                    return true;\n                }\n                 \n        //执行这里表示用户身份需要认证，跳转登陆页面\n        request.setAttribute(\"loginFailed\", \"用户登陆过期!\"); \n        request.getRequestDispatcher(\"index.action\").forward(request,response); \n         \n        return true;\n        //return true;\n    }\n}\n```\n\n#### applicationContext-transaction.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n \n<!-- 事务管理器 \n    对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\n-->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <!-- 数据源\n    dataSource在applicationContext-dao.xml中配置了\n     -->\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n \n<!-- 通知 -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes>\n        <!-- 传播行为 -->\n        <tx:method name=\"save*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"insert*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n        <tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n        <tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n<!-- aop -->\n<aop:config>\n    <aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.learn.service.Impl.*.*(..))\"/>\n</aop:config>\n \n</beans>\n```\n\n#### applicationContext-service.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n         \n<context:component-scan base-package=\"com.learn.service.Impl\"></context:component-scan>\n<!-- service -->\n<bean id=\"msgService\" class=\"com.learn.service.Impl.MsgServiceImpl\"/>\n \n</beans>\n```\n\n#### applicationContext-dao.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd          \n      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \n      http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\">\n     \n    <!-- 加载db.properties文件的内容，db.properties文件中的key命名有一定的特殊规则 -->\n    <context:property-placeholder location=\"classpath:db.properties\"/>\n    <!--配置数据源,dbcp  -->\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n                <!-- 数据连接信息 -->\n                <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\n                <property name=\"url\" value=\"${jdbc.url}\" />\n                <property name=\"username\" value=\"${jdbc.username}\" />\n                <property name=\"password\" value=\"${jdbc.password}\" />\n                <property name=\"maxActive\" value=\"30\" />\n                <property name=\"maxIdle\" value=\"5\" />\n                 \n    </bean>\n    <!-- sqlsessionFactory -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> \n                 <property name=\"dataSource\" ref=\"dataSource\"></property>\n                 <property name=\"configLocation\" value=\"classpath:mybatis/sqlMapConfig.xml\"></property>\n    </bean>\n   <!--  <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\n        p:dataSource-ref=\"dataSource\" p:configLocation=\"classpath:mybatis/sqlMapConfig.xml\" />--> \n    <!-- mapper扫描器 -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n                 <property name=\"basePackage\" value=\"com.learn.mapper\"></property>\n                 <property name=\"SqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>\n    </bean>\n</beans>\n```\n\n#### sqlMapConfig.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n   <!-- 全局的setting配置，根据需要添加 -->\n   <typeAliases>\n     <!-- 批量扫描别名 -->\n     <package name=\"com.learn.po\"/>\n   </typeAliases>\n</configuration>\n```\n\n## 逆向生成文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n  PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n \n<generatorConfiguration>\n    <context id=\"testTables\" targetRuntime=\"MyBatis3\">\n        <commentGenerator>\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\" />\n        </commentGenerator>\n        <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->\n        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\n            connectionURL=\"jdbc:mysql://127.0.0.1:3306/mk_notes\" userId=\"root\"\n            password=\"root\">\n        </jdbcConnection>\n        <!-- <jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\"\n            connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:yycg\" \n            userId=\"yycg\"\n            password=\"yycg\">\n        </jdbcConnection> -->\n \n        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n            NUMERIC 类型解析为java.math.BigDecimal -->\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\" />\n        </javaTypeResolver>\n \n        <!-- targetProject:生成PO类的位置 -->\n        <javaModelGenerator targetPackage=\"com.learn.po\"\n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n            <!-- 从数据库返回的值被清理前后的空格 -->\n            <property name=\"trimStrings\" value=\"true\" />\n        </javaModelGenerator>\n        <!-- targetProject:mapper映射文件生成的位置 -->\n        <sqlMapGenerator targetPackage=\"com.learn.mapper\" \n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n        </sqlMapGenerator>\n        <!-- targetPackage：mapper接口生成的位置 -->\n        <javaClientGenerator type=\"XMLMAPPER\"\n            targetPackage=\"com.learn.mapper\" \n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n        </javaClientGenerator>\n        <!-- 指定数据库表 -->\n        <table tableName=\"op_member_t\"></table>\n     \n    </context>\n</generatorConfiguration>\n```\n\n### 对应的java代码\n\n```java\npackage Generator;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n \nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\npublic class GeneratorSqlmap {\n    public void generator() throws Exception{\n \n        List<String> warnings = new ArrayList<String>();\n        boolean overwrite = true;\n        //指定 逆向工程配置文件\n        File configFile = new File(\"config/generatorConfig.xml\"); \n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n                callback, warnings);\n        myBatisGenerator.generate(null);\n \n    } \n    public static void main(String[] args) throws Exception {\n        try {\n            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n            generatorSqlmap.generator();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n         \n    }\n}\n```\n\n## 整个项目的目录结构\n\n供参考\n\n![](https://static.oschina.net/uploads/space/2017/0616/161712_LaAq_3429289.png)\n\n\n# 基于javaconfig配置\n\n## 1    项目结构（SSM+MAVEN）\n\n### 1.1    目录结构\n\n![](https://static.oschina.net/uploads/space/2018/0322/155319_tg0n_3429289.png)\n\n### 1.2    POM文件\n\n        由于仓库是nexus私服，如遇见无法加载的包，请无视\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test</groupId>\n\t<artifactId>ssmTest</artifactId>\n\t<packaging>war</packaging>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>ssmTest Maven Webapp</name>\n\t<url>http://maven.apache.org</url>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>junit</groupId>\n\t\t\t<artifactId>junit</artifactId>\n\t\t\t<version>3.8.1</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.xmlbeans</groupId>\n\t\t\t<artifactId>xmlbeans</artifactId>\n\t\t\t<version>2.6.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi-ooxml-schemas</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi-ooxml</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-collections4</artifactId>\n\t\t\t<version>4.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.websocket</groupId>\n\t\t\t<artifactId>javax.websocket-api</artifactId>\n\t\t\t<version>1.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-websocket</artifactId>\n\t\t\t<version>4.0.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>jstl</groupId>\n\t\t\t<artifactId>jstl</artifactId>\n\t\t\t<version>1.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t\t<version>2.2.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.google.code.gson</groupId>\n\t\t\t<artifactId>gson</artifactId>\n\t\t\t<version>2.2.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.ezmorph</groupId>\n\t\t\t<artifactId>ezmorph</artifactId>\n\t\t\t<version>1.0.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>jcifs</groupId>\n\t\t\t<artifactId>jcifs</artifactId>\n\t\t\t<version>1.3.17</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-beanutils</groupId>\n\t\t\t<artifactId>commons-beanutils</artifactId>\n\t\t\t<version>1.7.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-collections</groupId>\n\t\t\t<artifactId>commons-collections</artifactId>\n\t\t\t<version>3.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.json-lib</groupId>\n\t\t\t<artifactId>json-lib-ext-spring</artifactId>\n\t\t\t<version>1.0.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>log4j</groupId>\n\t\t\t<artifactId>log4j</artifactId>\n\t\t\t<version>1.2.17</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-lang</groupId>\n\t\t\t<artifactId>commons-lang</artifactId>\n\t\t\t<version>2.6</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-io</groupId>\n\t\t\t<artifactId>commons-io</artifactId>\n\t\t\t<version>2.0.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-fileupload</groupId>\n\t\t\t<artifactId>commons-fileupload</artifactId>\n\t\t\t<version>1.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis</groupId>\n\t\t\t<artifactId>mybatis-spring</artifactId>\n\t\t\t<version>1.2.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-dbcp</groupId>\n\t\t\t<artifactId>commons-dbcp</artifactId>\n\t\t\t<version>1.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-pool</groupId>\n\t\t\t<artifactId>commons-pool</artifactId>\n\t\t\t<version>1.5.6</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.aspectj</groupId>\n\t\t\t<artifactId>aspectjweaver</artifactId>\n\t\t\t<version>1.6.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis</groupId>\n\t\t\t<artifactId>mybatis</artifactId>\n\t\t\t<version>3.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t<artifactId>mybatis-generator</artifactId>\n\t\t\t<version>1.3.5</version>\n\t\t\t<type>pom</type>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t<artifactId>mybatis-generator-core</artifactId>\n\t\t\t<version>1.3.5</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-logging</groupId>\n\t\t\t<artifactId>commons-logging</artifactId>\n\t\t\t<version>1.1.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet.jsp</groupId>\n\t\t\t<artifactId>jsp-api</artifactId>\n\t\t\t<version>2.2</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet</groupId>\n\t\t\t<artifactId>servlet-api</artifactId>\n\t\t\t<version>2.5</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>aopalliance</groupId>\n\t\t\t<artifactId>aopalliance</artifactId>\n\t\t\t<version>1.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-webmvc</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-aop</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-aspects</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-context</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-beans</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-context-support</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-core</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-expression</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-jdbc</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-tx</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-test</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-web</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-pool2</artifactId>\n\t\t\t<version>2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.codehaus.jackson</groupId>\n\t\t\t<artifactId>jackson-core-asl</artifactId>\n\t\t\t<version>1.9.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.codehaus.jackson</groupId>\n\t\t\t<artifactId>jackson-mapper-asl</artifactId>\n\t\t\t<version>1.9.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.json-lib</groupId>\n\t\t\t<artifactId>json-lib</artifactId>\n\t\t\t<version>2.3</version>\n\t\t\t<classifier>jdk15</classifier>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<version>5.1.20</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.mail</groupId>\n\t\t\t<artifactId>mail</artifactId>\n\t\t\t<version>1.4.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-net</groupId>\n\t\t\t<artifactId>commons-net</artifactId>\n\t\t\t<version>3.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-codec</groupId>\n\t\t\t<artifactId>commons-codec</artifactId>\n\t\t\t<version>1.10</version>\n\t\t</dependency>\n\t</dependencies>\n\t<build>\n\t\t<finalName>ssmTest</finalName>\n\t</build>\n</project>\n\n```\n\n## 2    配置SPRINGMVC\n\n### 2.1    初始化\n\n         首先创建一个初始化类，继承AbstractAnnotationConfigDispatcherServletInitializer类\n\n```java\npackage com.ssm.config;\n\nimport org.apache.log4j.Logger;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\n/**\n * \n * @author C\n *\n */\npublic class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\tprivate final static Logger LOG = Logger.getLogger(WebAppInitializer.class);\n\n\t@Override\n\tprotected Class<?>[] getRootConfigClasses() {\n\t\t// TODO Auto-generated method stub\n\t\tLOG.info(\"------root配置类初始化------\");\n\t\treturn new Class<?>[] { RootConfig.class };\n\t}\n\n\t@Override\n\tprotected Class<?>[] getServletConfigClasses() {\n\t\tLOG.info(\"------web配置类初始化------\");\n\t\t return new Class<?>[] { WebConfig.class };\n\t}\n\n\t@Override\n\tprotected String[] getServletMappings() {\n\t\t// TODO Auto-generated method stub\n\t\tLOG.info(\"------映射根路径初始化------\");\n\t\t//return null;\n\t\t return new String[] {\"/\"};// 请求路径映射，将路径映射到DispatcherServlet上\n\t}\n\n}\n\n```\n\n这里继承AbstractAnnotationConfigDispatcherServletInitializer 类，就会自动个地配置Dispatcher-Servlet和Spring上下文(传统的方法是在web.xml中配置 DispatcherServlet)\n\n### 2.2    AbstractAnnotationConfigDispatcherServletInitializer剖析\n\n         Servlet3.0环境中，容器会在类路径去查找实现javax.servlet.ServletContainerInitializer接口的类，如果发现，就用它做servlet的容器\n    \n        Spring对这个接口进行了实现，为SpringServletContainerInitializer。它( SpringServletContainerInitializer )会去查找实现了WebAppInitializer的类并将配置任务交给他们来完成。Spring3.2引入了便利的 WebAppInitializer 实现，就是AbstractAnnotationConfigDispatcherServletInitializer。所以当部署到Servlet3.0容器中时，容器会自动发现它，并配置servlet上下文\n    \n         重新的三个方法也有对应注解，这里不再多说\n\n### 2.3  WebConfig配置\n\n        当DispatcherServlet启动的时候，会创建Spring应用上下文并加载配置文件或配置文件中声明的bean。\n    \n        当它加载上下文时，使用定义在WebConfig中的bean(基于java配置)\n    \n        DispatcherServlet 加载包含web组件的bean，如控制器，视图解析器等。还有一个ContextLoaderListener加载其他bean，如中间层及数据层组件等\n\n```java\npackage com.ssm.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\n\n/****\n * 定义 DispatcherServlet 加载应用上下文的配置\n * \n * @author C\n *\n */\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.ssm.controller\") // 包扫描\npublic class WebConfig extends WebMvcConfigurerAdapter{\n\t@Bean\n\tpublic ViewResolver viewResolver() {\n\t\tInternalResourceViewResolver resolver = new InternalResourceViewResolver();\n\t\tresolver.setPrefix(\"/WEB-INF/jsp\");\n\t\tresolver.setSuffix(\".jsp\");\n\t\treturn resolver;\n\t}\n\n\t@Bean(name = \"multipartResolver\") // bean必须写name属性且必须为multipartResolver\n\tprotected CommonsMultipartResolver multipartResolver() {\n\t\tCommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();\n\t\tcommonsMultipartResolver.setMaxUploadSize(5 * 1024 * 1024);\n\t\tcommonsMultipartResolver.setMaxInMemorySize(0);\n\t\tcommonsMultipartResolver.setDefaultEncoding(\"UTF-8\");\n\t\treturn commonsMultipartResolver;\n\t}\n\n\t// 静态资源的处理\n\tpublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n\t\tconfigurer.enable();\n\t}\n}\n\n```\n\n@Configuration：配置类\n\n@EnableWebMvc：相当于基于xml配置的<mvc:annotation-driven>启用注解驱动\n\n@ComponentScan：包扫描\n\n## 3    RootConfig配置\n\n```java\npackage com.ssm.config;\n\nimport org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n\n/***\n * 主要配置持久层的一些东西，包括数据库、Mybatis框架，事务之类的\n * \n * @author C\n *\n */\n@Configuration\n@ComponentScan(basePackages = { \"com.ssm.config\", \"com.ssm.service.impl\" })\n@Import(DataSourceConfig.class)\npublic class RootConfig {\n\t@Bean\n\tpublic BeanNameAutoProxyCreator autoProxyCreator() {\n\t\tBeanNameAutoProxyCreator autoProxyCreator = new BeanNameAutoProxyCreator();\n\t\tautoProxyCreator.setProxyTargetClass(true);\n\t\t// 设置要创建代理的那些Bean的名字\n\t\tautoProxyCreator.setBeanNames(\"*Service\");\n\t\tautoProxyCreator.setInterceptorNames(\"transactionInterceptor\");\n\t\treturn autoProxyCreator;\n\t}\n\n}\n\n```\n\n这里数据库的事务配置方式有三种：\n\n-   第一种在 RootConfig加上 @EnableTransactionManagement 注解，配置数据库， 手动加上事务使用 [@Transactional](https://my.oschina.net/u/3770144) 注解，并且指定的传播属性，缺点麻烦\n-   第二种使用 BeanNameAutoProxyCreator拦截代理方式\n-   第三种是采用aop切面事务\n\n## 4    DataSourceConfig\n\n        这里由于我用的1.7的JDK，@PropertySources会报错，作为学习，就直接将properties文件写到类里面了\n\n```java\npackage com.ssm.config;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.apache.log4j.Logger;\nimport org.mybatis.spring.SqlSessionFactoryBean;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\nimport org.springframework.context.annotation.PropertySources;\nimport org.springframework.core.io.support.PathMatchingResourcePatternResolver;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.interceptor.TransactionInterceptor;\n\n@Configuration\n/*@PropertySources(value = { @PropertySource(\"classpath:db.properties\") }) */\n@MapperScan(\"com.ssm.mapper\")\npublic class DataSourceConfig {\n\tprivate final static Logger LOG = Logger.getLogger(DataSourceConfig.class);\n\n\tprivate String driver = \"com.mysql.jdbc.Driver\";;\n\n\tprivate String url = \"jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&transformedBitIsBoolean=true&autoReconnect=true\";\n\n\tprivate String username = \"root\";\n\n\tprivate String password = \"root\";\n\n\t@Bean\n\tpublic BasicDataSource dataSource() {\n\t\tLOG.info(\"Initialize the BasicDataSource...\");\n\t\tBasicDataSource dataSource = new BasicDataSource();\n\t\tdataSource.setDriverClassName(driver);\n\t\tdataSource.setUrl(url);\n\t\tdataSource.setUsername(username);\n\t\tdataSource.setPassword(password);\n\t\treturn dataSource;\n\t}\n\n\t// mybatis的配置\n\t@Bean\n\tpublic SqlSessionFactoryBean sqlSessionFactoryBean() throws IOException {\n\t\tResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\t\tSqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n\t\tsqlSessionFactoryBean.setDataSource(dataSource());\n\t\tsqlSessionFactoryBean.setMapperLocations(resourcePatternResolver.getResources(\"classpath*:mappers/*.xml\"));\n\t\tsqlSessionFactoryBean.setTypeAliasesPackage(\"com.ssm.mapper\");// 别名，让*Mpper.xml实体类映射可以不加上具体包名\n\t\treturn sqlSessionFactoryBean;\n\t}\n\n\t// 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\n\t@Bean(name = \"transactionManager\")\n\tpublic DataSourceTransactionManager dataSourceTransactionManager() {\n\t\tDataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();\n\t\tdataSourceTransactionManager.setDataSource(dataSource());\n\t\treturn dataSourceTransactionManager;\n\t}\n\n\t@Bean(name = \"transactionInterceptor\")\n\tpublic TransactionInterceptor interceptor() {\n\t\tTransactionInterceptor interceptor = new TransactionInterceptor();\n\t\tinterceptor.setTransactionManager(dataSourceTransactionManager());\n\t\tProperties transactionAttributes = new Properties();\n\t\ttransactionAttributes.setProperty(\"save*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"del*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"update*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"get*\", \"PROPAGATION_REQUIRED,readOnly\");\n\t\ttransactionAttributes.setProperty(\"find*\", \"PROPAGATION_REQUIRED,readOnly\");\n\t\ttransactionAttributes.setProperty(\"*\", \"PROPAGATION_REQUIRED\");\n\t\tinterceptor.setTransactionAttributes(transactionAttributes);\n\t\treturn interceptor;\n\t}\n}\n\n```\n\n## 5    测试\n\n```java\npackage com.ssm.controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.ssm.service.IndexService;\nimport com.sun.mail.handlers.image_gif;\n\n@RestController\npublic class IndexController {\n\t@Autowired\n\tprivate IndexService indexService;\n\n\t@RequestMapping(\"index\")\n\tpublic String index() {\n\t\treturn \"THIS IS A TEST.WELCOME\";\n\t}\n\n\t@RequestMapping(\"getData\")\n\tpublic String getData() {\n\t\treturn indexService.findUser();\n\t}\n\n}\n\n```\n\n### 5.1访问servlet\n\n![](https://static.oschina.net/uploads/space/2018/0322/165245_2jbO_3429289.png)\n\n### 5.2访问数据库\n\n![](https://static.oschina.net/uploads/space/2018/0322/165508_siNA_3429289.png)![](https://static.oschina.net/uploads/space/2018/0322/165413_GwmS_3429289.png)"},{"title":"dubbo+zookeeper 入门","url":"/2018/03/07/java框架/dubbo/DUBBO+ZOOKEEPER入门/","content":"\n采用spring3.2+dubbo2.5.3+zookeeper3.3.6\n\n所需架包如图所示   \n\n![](DUBBO+ZOOKEEPER入门\\1.png)\n\n# 1.安装zookeeper\n\n本文采用zookeeper-3.3.6，可自行查找下载。下载后进入conf目录下，修改zoo_sample.cfg为zoo.cfg。该文件为zookeeper的配置文件\n\n```bash\n# The number of milliseconds of each tick\ntickTime=2000\n# The number of ticks that the initial \n# synchronization phase can take\ninitLimit=10\n# The number of ticks that can pass between \n# sending a request and getting an acknowledgement\nsyncLimit=5\n# the directory where the snapshot is stored.\ndataDir=/tmp/zookeeper\n# the port at which the clients will connect\nclientPort=2181\n```\n\ntickTime：基本事件单元，以毫秒为单位。**它用来控制心跳和超时，默认情况下最小的会话超时时间为两倍的 tickTime。**\n\ndataDir：存放内存数据的地方\n\nclientPort：用户于zookeeper相连的端口\n\ninitLimit：Leader允许F在 **initLimit** 时间内完成这个工作，请求和响应时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 10*2000=20 秒\n\nsyncLimit：检测机器的存活状态，请求和响应时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒\n\n此处需注意这种文件\n\n```bash\ntickTime=2000\ndataDir=/usr/zdatadir\ndataLogDir=/usr/zlogdir\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=cloud:2888:3888\nserver.2=cloud02:2888:3888\nserver.3=cloud03:2888:3888\nserver.4=cloud04:2888:3888\nserver.5=cloud05:2888:3888\n```\n\n**server.A=B：C：D：**其中 A 是一个数字，表示这个是第几号服务器；**B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。**如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号\n\n除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，**Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。**\n\n![](DUBBO+ZOOKEEPER入门\\2.png)\n\n# 2.启动zookeeper\n\n此处我用的为第一个配置文件，并没有配置集群。直接打开zookeeper-3.3.6\\\\bin\\\\zkServer.cmd，这里我是window环境，linux环境运行.sh文件\n\n# 3.dubbo\n\n通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。\n    \ndubbo就是一个服务框架，可以实现调用远程接口像调用本地接口一样方便。\n    \n这里注册中心我们选择zookeeper\n\n## 3.1安装Dubbo-admin，实现监控\n\n这里我安装的是dubbo-admin-2.5.3.war，部署到tomcat的webapps下，修改webapps\\\\dubbo-admin-2.5.3\\\\WEB-INF\\\\dubbo.properties文件，内容如下\n\n```ini\ndubbo.registry.address=zookeeper://127.0.0.1:2181\ndubbo.admin.root.password=root\ndubbo.admin.guest.password=guest\n```\n\n其中root和guest都为密码。\n\n启动tomcat，效果如下(如提示输出账号信息，输入root，root)\n\n![](DUBBO+ZOOKEEPER入门\\3.png)\n\n## 3.2dubbo流程\n\nprovider注册----生产---->zookeeper<----消费--------consumer\n    \n生产者将接口信息注册到zookeper，消费者通过zookeeper进行消费\n\n## 3.3生产者注册\n\nProvider.java文件如下\n\n```java\npackage com.dubbotest.provider;\n \nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n \npublic class Provider {\n \n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-service.xml\");\n        context.start();\n        System.out.println(\"-----------\");\n        System.in.read(); // 为保证服务一直开着，利用输入流的阻塞来模拟,任意键退出\n    }\n}\n```\n\napplicationContext-service.xml如下\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n        http://code.alibabatech.com/schema/dubbo  \n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd  \n        \">\n \n    <bean id=\"user\" class=\"com.model.User\">\n        <property name=\"name\" value=\"person\" />\n    </bean>\n \n    <!-- 具体的实现bean -->\n    <bean id=\"demoService\" class=\"com.dubbotest.provider.DemoServiceImpl\" />\n \n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"xixi_provider\" />\n \n    <!-- 使用multicast广播注册中心暴露服务地址 <dubbo:registry address=\"multicast://224.5.6.7:1234\" \n        /> -->\n \n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n \n    <!-- 用dubbo协议在20880端口暴露服务 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n \n    <!-- 声明需要暴露的服务接口 -->\n    <!-- <dubbo:service interface=\"com.dubbotest.provider.DemoService\" ref=\"demoService\" \n        /> -->\n    <dubbo:service interface=\"com.dubbotest.provider.DemoService\"\n        ref=\"demoService\" />\n \n</beans>\n```\n\n运行了provider中的main函数后可以在dubbo-admin管理中看见接口信息。\n\n![](DUBBO+ZOOKEEPER入门\\4.png)\n\n## 3.4consumer消费\n\nConsumer.java如下\n\n```java\npackage com.dubbotest.consumer;\n \nimport java.util.List;\n \nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n \nimport com.dubbotest.provider.DemoService;\nimport com.model.User;\n \npublic class Consumer {\n \n    public static void main(String[] args) throws Exception {  \n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(  \n                new String[] { \"applicationContext-dubbo.xml\" });  \n        context.start();  \n        DemoService demoService = (DemoService) context.getBean(\"demoService\"); \n        String hello = demoService.sayHello(\"tom\"); \n        System.out.println(hello); \n        List<User> list = demoService.getUsers();  \n        if (list != null && list.size() > 0) {  \n            for (int i = 0; i < list.size(); i++) {  \n                System.out.println(list.get(i).toString());  \n            }  \n        }  \n        System.in.read();  \n    }  \n}\n```\n\napplicationContext-dubbo.xml如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"  \n        xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n            http://www.springframework.org/schema/beans/spring-beans.xsd  \n            http://code.alibabatech.com/schema/dubbo  \n            http://code.alibabatech.com/schema/dubbo/dubbo.xsd  \n            \">  \n        \n        <!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 -->  \n        <dubbo:application name=\"hehe_consumer\" />  \n       \n        <!-- 使用zookeeper注册中心暴露服务地址 -->  \n        <!-- <dubbo:registry address=\"multicast://224.5.6.7:1234\" /> -->  \n        <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />  \n       \n        <!-- 生成远程服务代理，可以像使用本地bean一样使用demoService -->  \n        <dubbo:reference id=\"demoService\"  \n            interface=\"com.dubbotest.provider.DemoService\" />  \n       \n</beans>\n```\n\n运行后结果如图 ：\n\n![](DUBBO+ZOOKEEPER入门\\5.png)\n\n## 3.5其他文件：\n\nDemoService.java\n\n```java\npackage com.dubbotest.provider;\n \nimport java.util.List;\n \npublic interface DemoService {\n    String sayHello(String name);  \n       \n    public List getUsers();  \n}\n```\n\nDemoServiceImpl.java\n\n```java\npackage com.dubbotest.provider;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \nimport org.springframework.stereotype.Component;\n \nimport com.alibaba.dubbo.config.annotation.Service;\nimport com.model.User;\n \n@Service(version=\"1.0\")//此处Component是Spring bean注解，Service是dubbo的注解\npublic class DemoServiceImpl implements DemoService{\n \n    @Override\n    public String sayHello(String name) {\n        // TODO Auto-generated method stub\n         return \"Hello \" + name;  \n    }\n \n    @Override\n    public List getUsers() {\n          List list = new ArrayList();  \n             User u1 = new User();  \n             u1.setName(\"jack\");  \n             u1.setAge(20);  \n             u1.setSex(\"男\");  \n                \n             User u2 = new User();  \n             u2.setName(\"tom\");  \n             u2.setAge(21);  \n             u2.setSex(\"女\");  \n                \n             User u3 = new User();  \n             u3.setName(\"rose\");  \n             u3.setAge(19);  \n             u3.setSex(\"女\");  \n                \n             list.add(u1);  \n             list.add(u2);  \n             list.add(u3);  \n             return list;  \n    }\n \n}\n```\n\nUser.java\n\n```java\npackage com.model;\n \nimport java.io.Serializable;\n \npublic class User implements Serializable{\n     \n    private String name;\n    private String sex;\n    private int age;\n \n    @Override\n    public String toString() {\n        return \"User [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\";\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public String getSex() {\n        return sex;\n    }\n \n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n    }\n \n}\n```","tags":["dubbo"]},{"title":"Spring源码学习——自定义标签","url":"/2017/11/28/java框架/spring/spring-自定义标签/","content":"\n# 1.自定义标签步骤\n\n1.  创建一个需要扩展的组件\n2.  定义xsd文件描述组件内容\n3.  创建一个文件，实现BeanDefinitionParser接口，解析xsd文件中的定义和组件定义\n4.  创建handler文件，扩展NamespaceHandlerSupport，注册组件到spring容器\n5.  编写spring.handlers和spring.schemas文件\n\n# 2.代码如下\n\n## 1.编写pojo\n\n```java\npublic class User {\n\t\n\tprivate String name;\n\tprivate String sex;\n\tprivate int age;\n//省略getter、setter\n\n}\n```\n\n## 2.xsd文件描述组件内容\n\n```xml\n<?xml version=\"1.0\"?>\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://www.springtest.com/schema/user\"\n\txmlns:tns=\"http://www.springtest.com/schema/user\" elementFormDefault=\"qualified\">\n\t<!-- 表示数据类型等定义来自w3 -->\n\t<!--表示文档中要定义的元素来自什么命名空间 -->\n\t<!--表示此文档的默认命名空间是什么 -->\n\t<!--表示要求xml文档的每一个元素都要有命名空间指定 -->\n\n\t<!-- ……定义主体部分…… -->\n\t<element name=\"user\">\n\t\t<complexType>\n\t\t\t<attribute name=\"id\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"name\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"sex\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"age\" type=\"int\"></attribute>\n\t\t</complexType>\n\t</element>\n\n</schema>\n```\n\n描述了一个新的targetNamespace，并定义了一个name是user的element，有id，name，sex，age属性\n\n## 3.创建类，实现BeanDefinitionParser接口\n\n```java\npackage test.customtag;\n\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;\nimport org.springframework.util.StringUtils;\nimport org.w3c.dom.Element;\n\nimport com.model.User;\n\npublic class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\t// Element对应的类\n\tprotected Class getBeanClass(Element element) {\n\t\treturn User.class;\n\t}\n\n\t// 从element中解析并提取对应的元素\n\tprotected void doParse(Element element, BeanDefinitionBuilder bean) {\n\t\tString name = element.getAttribute(\"name\");\n\t\tString sex = element.getAttribute(\"sex\");\n\t\tString age = element.getAttribute(\"age\");\n\t\t// 将提取的数据放入到BeanDefinitionBuilder中，将所有beanbeanFactory中\n\t\tif (StringUtils.hasText(name)) {\n\t\t\tbean.addPropertyValue(\"name\", name);\n\t\t}\n\t\tif (StringUtils.hasText(sex)) {\n\t\t\tbean.addPropertyValue(\"sex\", sex);\n\t\t}\n\t\tif (StringUtils.hasText(age)) {\n\t\t\tbean.addPropertyValue(\"age\", Integer.parseInt(age));\n\t\t}\n\n\t}\n\n}\n```\n\n## 4.创建handler文件，注册spring容器\n\n```java\npackage test.customtag;\n\nimport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n\n/******创建handler文件，组件注册到spring容器***/\npublic class MyNamespaceHandler extends NamespaceHandlerSupport{\n\n\t@Override\n\tpublic void init() {\n\t\t// TODO Auto-generated method stub\n\t\tregisterBeanDefinitionParser(\"user\", new UserBeanDefinitionParser());\n\t}\n\n}\n```\n\n## 5.编写spring.handlers和spring.schemas文件，默认在工程的/META-INF/文件下\n\nspring.handlers\n\n```xml\nhttp\\://www.springtest.com/schema/user=test.customtag.MyNamespaceHandler\n```\n\nspring.schemas\n\n```xml\nhttp\\://www.springtest.com/schema/user.xsd=META-INF/Spring-test.xsd\n```\n\n此处注意：\n\n这里因为我创建的是java项目，直接在项目下建造META-INF会提示找不到对应的文件，所以这里是将文件打包成jar包导入到项目中。如下图所示\n\n![](https://static.oschina.net/uploads/space/2017/1128/113739_vNLU_3429289.png)![](https://static.oschina.net/uploads/space/2017/1128/113750_HHla_3429289.png)\n\n## 6.测试\n\n导入自定义标签\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\txmlns:myname=\"http://www.springtest.com/schema/user\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n        http://www.springtest.com/schema/user\n       \thttp://www.springtest.com/schema/user.xsd\n        \">\n\t<myname:user id=\"testBean\" name=\"aaaaaa\" sex=\"dsaf\" age=\"12\"></myname:user>\n</beans>\n```\n\n测试代码\n\n```java\n\npublic class Test {\n\t/****测试输出*/\n\t@org.junit.Test\n\tpublic void test1(){\n\t\tSystem.out.println(\"--------\");\n\t\tApplicationContext act=new ClassPathXmlApplicationContext(\"applicationContext-service.xml\");\n\t\tUser u=(User) act.getBean(\"testBean\");\n\t\tSystem.out.println(\"--------------\"+u.toString());\n\t}\n}\n```\n\n输出结果\n\n![](https://static.oschina.net/uploads/space/2017/1128/113515_sKwH_3429289.png)\n\n# 3.整个项目结构\n\n![](https://static.oschina.net/uploads/space/2017/1128/113903_VcT2_3429289.png)\n\n参考自：spring源码深度解析","tags":["spring"]},{"title":"springMVC使用websocket实现在线客服","url":"/2017/10/17/java框架/springmvc/websocket实现在线客服/","content":"\n# 1.环境\n\nspringMVC+spring+mybatis（spring4.0以上）\n\n注意需要导入spring-websocket和websocket-api包。其余架包正常ssm即可，可自行百度\n\n```xml\n<dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-websocket</artifactId>\n      <version>4.0.5.RELEASE</version> \n    </dependency>\n<dependency> \n    \t<groupId>javax.websocket</groupId>\n    \t<artifactId>javax.websocket-api</artifactId>\n    \t<version>1.1</version>\n    \t<scope>provided</scope>\n\t</dependency>\n```\n\n# 2.后台代码\n\n        用Map存放当前登录的账户及其对应的session\n\n提出几点解释：\n\n1.  @ServerEndpoint：把当前类变成websocket服务类\n2.  @OnOpen： 连接时执行\n3.  @OnClose：关闭时执行\n4.  @OnMessage：收到消息时执行\n5.  @OnError：连接错误时执行\n\n```java\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * @Description: 简单websocket demo *\n */\n@ServerEndpoint(value = \"/websocketTest/{userId}\")//@ServerEndpoint把当前类变成websocket服务类\npublic class WebsocketTest {\n\tprivate Logger logger = LoggerFactory.getLogger(WebsocketTest.class);\n\tprivate static String userId;\n\t// 连接的用户\n\tprivate static Map<String, Session> onlines = new HashMap<String, Session>();\n\n\t// 连接时执行\n\t@OnOpen\n\tpublic void onOpen(@PathParam(\"userId\") String userId, Session session) throws IOException {\n\t\tthis.userId = userId;\n\t\tonlines.put(userId, session);\n\t\tSystem.out.println(\"新连接：\" + userId);\n\n\t}\n\n\t// 关闭时执行\n\t@OnClose\n\tpublic void onClose(@PathParam(\"userId\") String userId) {\n\t\tif (onlines.containsKey(userId)) {\n\t\t\tonlines.remove(userId);\n\t\t}\n\t\tSystem.out.println(\"连接close：\" + this.userId + \" 关闭\");\n\t}\n\n\t// 收到消息时执行\n\t@OnMessage\n\tpublic void onMessage(String message, Session session, @PathParam(\"userId\") String userId) throws IOException {\n\t\tSystem.out.println(message);\n\t\tif (message.contains(\"&\")) {\n\t\t\tString[] params = message.split(\"&\");\n\t\t\tif (params[1].equals(\"all\")) {\n\t\t\t\tSystem.out.println(\"广播\");\n\t\t\t\tsendMessageToAll(userId + \"发送广播消息:\" + params[0]);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"toUser\");\n\t\t\t\tsendMessageToUser(userId, params[1], params[0]);\n\t\t\t\t;\n\t\t\t}\n\t\t}else\n\t\t\t session.getBasicRemote().sendText(userId+\"发送消息： \" + message); \n\t\tSystem.out.println(onlines.toString());\n\t}\n\n\t\n\n\n\t// 连接错误时执行\n\t@OnError\n\tpublic void onError(Session session, Throwable error) {\n\t\tSystem.out.println(\"用户id为：\" + this.userId + \"的连接发送错误\");\n\t\terror.printStackTrace();\n\t}\n\n\t/**\n\t * 广播消息给所有人\n\t * **/\n\t\tprivate void sendMessageToAll(String message) {\n\t\t\tSet<String> users = onlines.keySet();\n\t\t\tfor (String user : users) {\n\t\t\t\ttry {\n\t\t\t\t\tif (onlines.get(user).isOpen()) {\n\t\t\t\t\t\t((Session) onlines.get(user)).getBasicRemote().sendText(message);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t/******\n\t *  给某个用户发送消息 \n\t * @Param userName 发消息的name\n\t * **/\n\t\tprivate void sendMessageToUser(String userName, String receiveName, String message) {\n\t\t\tSet<String> users = onlines.keySet();\n\t\t\tfor (String user : users) {\n\t\t\t\tif (user.equals(receiveName)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (onlines.get(user).isOpen()) {\n\t\t\t\t\t\t\tSystem.out.println(\"user---\" + user);\n\t\t\t\t\t\t\t((Session) onlines.get(user)).getBasicRemote().sendText(userName + \"给你发了消息：\" + message);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\n```\n\n# 3.html\n\n## 一、操作类html\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\t广播消息---- admin\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<select id=\"toUser\" >\n\t<option id=\"toUser\" value=\"all\">ALL</option>\n\t<option id=\"toUser\" value=\"user001\">user001</option>\n\t<option id=\"toUser\" value=\"user002\">user002</option>\n\t</select>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/admin\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\tvar user = document.getElementById('toUser').value;\n\t\t\tmessage+='&'+user;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n## 二、接收类1\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\twebsocket Demo---- user001\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/user001\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n## 三、接收类2\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\twebsocket Demo---- user002\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/user002\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n4.具体效果\n\n截图如下，实现简单web聊天功能。\n\n","tags":["springmvc"]},{"title":"Shiro简介","url":"/2017/09/02/java框架/shiro/Apache-shiro学习/","content":"\n# 1.Shiro简介\n\nShiro 可以帮助我们完成：认证、授权、加密、会话管理、与Web 集成、缓存等\n\n![](https://static.oschina.net/uploads/space/2017/0902/160620_MqP6_3429289.png)\n\n其中工作原理主要如图，进入后创建一个Subject（即为当前用户），然后SecurityManager管理所有Subject，这里可以理解为于SpringMVC的DispatcherServlet，最后我们Realm相当于是一个数据源，管理用户身份是否合法。\n\n# 2.入门示例\n\n```java\n@Test\npublic void testHelloworld() {\n//1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager\nFactory<org.apache.shiro.mgt.SecurityManager> factory =\nnew IniSecurityManagerFactory(\"classpath:shiro.ini\");\n//2、得到SecurityManager实例并绑定给SecurityUtils\norg.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();\nSecurityUtils.setSecurityManager(securityManager);\n//3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）\nSubject subject = SecurityUtils.getSubject();\nUsernamePasswordToken token = new UsernamePasswordToken(\"zhang\", \"123\");\ntry {\n//4、登录，即身份验证\nsubject.login(token);\n} catch (AuthenticationException e) {\n//5、身份验证失败\n}\nAssert.assertEquals(true, subject.isAuthenticated()); //断言用户已经登录\n//6、退出\nsubject.logout();\n}\n```\n\n2.1、首先通过new IniSecurityManagerFactory 并指定一个ini 配置文件来创建一个SecurityManager工厂；\n\n2.2、接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可；  \n2.3、通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结  \n束时需要解除绑定；然后获取身份验证的Token，如用户名/密码；  \n2.4、调用subject.login 方法进行登录，其会自动委托给SecurityManager.login方法进行登录；  \n2.5、如果身份验证失败请捕获AuthenticationException 或其子类;\n\n2.6、最后可以调用subject.logout退出\n\n# 3.与web集成\n\n```xml\n<dependency>\n<groupId>org.apache.shiro</groupId>\n<artifactId>shiro-web</artifactId>\n<version>1.2.2</version>\n</dependency>\n<dependency>\n<groupId>junit</groupId>\n<artifactId>junit</artifactId>\n<version>4.9</version>\n</dependency>\n<dependency>\n<groupId>commons-logging</groupId>\n<artifactId>commons-logging</artifactId>\n<version>1.1.3</version>\n</dependency>\n<dependency>\n<groupId>org.apache.shiro</groupId>\n<artifactId>shiro-core</artifactId>\n<version>1.2.2</version>\n</dependency>\n```\n\n## 必要的架包。\n\n## web.xml如图所示\n\n```xml\n<filter>\n\t\t<filter-name>shiroFilter</filter-name>\n\t\t<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n\t</filter>\n\n\t<filter-mapping>\n\t\t<filter-name>shiroFilter</filter-name>\n\t\t<url-pattern>*.shtml</url-pattern>\n\t</filter-mapping>\n```\n\nDelegatingFilterProxy作用是自动到spring容器查找名字为shiroFilter（filter-name）的bean并把所有Filter的操作委托给它，然后将ShiroFilter 配置到spring容器即可\n\n```xml\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n\t\t<property name=\"securityManager\" ref=\"securityManager\" />\n</bean>\n```\n\n## ini配置部分说明\n\n```xml\n[main]\n#默认是/login.jsp\nauthc.loginUrl=/login\nroles.unauthorizedUrl=/unauthorized\nperms.unauthorizedUrl=/unauthorized\n[users]\nzhang=123,admin\nwang=123\n[roles]\nadmin=user:*,menu:*\n[urls]\n/login=anon\n/unauthorized=anon\n/static/**=anon\n/authenticated=authc\n/role=authc,roles[admin]\n/permission=authc,perms[\"user:create\"]\n```\n\n其中最重要的就是\\[urls\\]部分的配置，其格式是： “url=拦截器\\[参数\\]，拦截器\\[参数\\]”；  \n即如果当前请求的url匹配\\[urls\\]部分的某个url模式，将会执行其配置的拦截器。比如anon  \n拦截器表示匿名访问（即不需要登录即可访问）；authc拦截器表示需要身份认证通过后才  \n能访问；roles\\[admin\\]拦截器表示需要有admin 角色授权才能访问；而perms\\[\"user:create\"\\]  \n拦截器表示需要有“user:create”权限才能访问\n\n暂时就看到这里，作一个记录，下次继续更新","tags":["shiro"]},{"title":"微信公众号接入","url":"/2017/05/20/微信公众号/微信公众号接入/","content":"\nPACKAGE\n\n![](https://static.oschina.net/uploads/space/2017/0522/172756_NC0S_3429289.png)\n\n1.MenuManage\n\n```java\n/**\n * 创建菜单\n * */\npublic class MenuManager {\n\tprivate static Logger log = LoggerFactory.getLogger(MenuManager.class);\n\n\tpublic static void main(String[] args) {\n\t\t// 第三方用户唯一凭证\n\t\tString appId = \"000000000000000000\";\n\t\t// 第三方用户唯一凭证密钥\n\t\tString appSecret = \"00000000000000000000000000000000\";\n\n\t\t// 调用接口获取access_token\n\t\tAccessToken at = WeixinUtil.getAccessToken(appId, appSecret);\n\t\t\n\t\tif (null != at) {\n\t\t\t// 调用接口创建菜单\n\t\t\tint result = WeixinUtil.createMenu(getMenu(), at.getToken());\n\n\t\t\t// 判断菜单创建结果\n\t\t\tif (0 == result)\n\t\t\t\tlog.info(\"菜单创建成功！\");\n\t\t\telse\n\t\t\t\tlog.info(\"菜单创建失败，错误码：\" + result);\n\t\t}\n\t}\n\n\tprivate static Menu getMenu() {\n\t\t// TODO Auto-generated method stub\n\t\tCommonButton btn11 = new CommonButton();\n\t\tbtn11.setName(\"测试1\");\n\t\tbtn11.setType(\"click\");\n\t\tbtn11.setKey(\"11\");\n\t\t\n\t\tCommonButton btn12 = new CommonButton();\n\t\tbtn12.setName(\"测试2\");\n\t\tbtn12.setType(\"click\");\n\t\tbtn12.setKey(\"12\");\n\n\t\tCommonButton btn13 = new CommonButton();\n\t\tbtn13.setName(\"测试3\");\n\t\tbtn13.setType(\"click\");\n\t\tbtn13.setKey(\"13\");\n\n\t\tCommonButton btn14 = new CommonButton();\n\t\tbtn14.setName(\"测试4\");\n\t\tbtn14.setType(\"click\");\n\t\tbtn14.setKey(\"14\");\n\n\t\tCommonButton btn21 = new CommonButton();\n\t\tbtn21.setName(\"快递查询\");\n\t\tbtn21.setType(\"click\");\n\t\tbtn21.setKey(\"21\");\n\n\t\tCommonButton btn22 = new CommonButton();\n\t\tbtn22.setName(\"经典游戏\");\n\t\tbtn22.setType(\"click\");\n\t\tbtn22.setKey(\"22\");\n\n\n\t\tCommonButton btn23 = new CommonButton();\n\t\tbtn23.setName(\"聊天唠嗑\");\n\t\tbtn23.setType(\"click\");\n\t\tbtn23.setKey(\"23\");\n\n\n\t\tCommonButton btn31 = new CommonButton();\n\t\tbtn31.setName(\"Q友圈\");\n\t\tbtn31.setType(\"click\");\n\t\tbtn31.setKey(\"31\");\n\n\t\tCommonButton btn32 = new CommonButton();\n\t\tbtn32.setName(\"电影排行榜\");\n\t\tbtn32.setType(\"click\");\n\t\tbtn32.setKey(\"32\");\n\n\t\tCommonButton btn33 = new CommonButton();\n\t\tbtn33.setName(\"更多帮助\");\n\t\tbtn33.setType(\"click\");\n\t\tbtn33.setKey(\"33\");\n\n\t\tComplexButton mainBtn1 = new ComplexButton();\n\t\tmainBtn1.setName(\"测试按钮\");\n\t\tmainBtn1.setSub_button(new CommonButton[] { btn11, btn12, btn13, btn14 });\n\n\t\tComplexButton mainBtn2 = new ComplexButton();\n\t\tmainBtn2.setName(\"休闲驿站\");\n\t\tmainBtn2.setSub_button(new CommonButton[] { btn21, btn22, btn23});\n\n\t\tComplexButton mainBtn3 = new ComplexButton();\n\t\tmainBtn3.setName(\"更多帮助\");\n\t\tmainBtn3.setSub_button(new CommonButton[] { btn31, btn32, btn33 });\n\n\t\t/**\n\t\t * 此菜单结构，每个一级菜单都有二级菜单项\n\t\t */\n\t\tMenu menu = new Menu();\n\t\tmenu.setButton(new Button[] { mainBtn1, mainBtn2, btn33 });\n\t\t\n\t\treturn menu;\n\t}\n\n}\n```\n\nBaseServlet\n\n```java\npublic class BaseServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * 认证微信服务器\n\t */\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t// 微信加密签名\n\t\tString signature = req.getParameter(\"signature\");\n\t\t// 时间\n\t\tString timestamp = req.getParameter(\"timestamp\");\n\t\t// 随机数\n\t\tString nonce = req.getParameter(\"nonce\");\n\t\t// 随机字符串\n\t\tString echostr = req.getParameter(\"echostr\");\n\t\tPrintWriter out = resp.getWriter();\n\t\t// 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败\n\t\tif (SignUtil.checkSignature(signature, timestamp, nonce)) {\n\t\t\tout.print(echostr);\n\t\t}\n\t\tout.close();\n\t\tout = null;\n\t}\n\n\t/**\n\t * 用户消息处理\n\t */\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\t// 将请求、响应的编码均设置为UTF-8（防止中文乱码）\n\t\treq.setCharacterEncoding(\"UTF-8\");\n\t\tresp.setCharacterEncoding(\"UTF-8\");\n\t\t// Service处理请求\n\t\tString result = null;\n\t\ttry {\n\t\t\t// 默认返回内容\n\t\t\tString respContent = \"测试微信公众号\";\n\t\t\tMap<String, String> requestMap = MessageUtil.parseXml(req);\n\t\t\tString fromUserName = requestMap.get(\"FromUserName\");\n\t\t\tString toUserName = requestMap.get(\"ToUserName\");\n\t\t\tString msgType = requestMap.get(\"MsgType\");\t\n\t\t\tBaseService baseService=new BaseService();\n\t\t\t// 回复文本消息\n\t\t\tif(MessageUtil.REQ_MESSAGE_TYPE_TEXT.equals(msgType)){\n\t\t\t\tString content=requestMap.get(\"Content\");\n\t\t\t\tTextMessageReq textMessageReq=new TextMessageReq(toUserName, fromUserName, msgType, content);\n\t\t\t\tresult=baseService.dealTextReq(textMessageReq);\t\n\t\t\t}else if(MessageUtil.REQ_MESSAGE_TYPE_EVENT.equals(msgType)){\n\t\t\t\t// 事件类型   \n\t\t\t\tString eventType = requestMap.get(\"Event\");\n\t\t\t\tif (eventType.equals(MessageUtil.EVENT_TYPE_SUBSCRIBE)){\n\t\t\t\t\tresult = \"谢谢您的关注！回复\\\"0\\\"查看帮助\";\n\t\t\t\t}else if(MessageUtil.EVENT_TYPE_CLICK.equals(eventType)){\n\t\t\t\t\t// 菜单点击key值\n\t\t\t\t\tString eventKey = requestMap.get(\"EventKey\");  \n\t\t\t\t\tresult=baseService.dealClickReq(toUserName,fromUserName,msgType,eventKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tPrintWriter out = resp.getWriter();\n\t\tout.write(result);\n\t\tout.close();\n\n\t}\n\n}\n```\n\nBaseService\n\n```java\n/**\n * 消息处理\n */\npublic class BaseService {\n\t/**\n\t * 文本消息处理\n\t */\n\tpublic String dealTextReq(TextMessageReq textMessageReq) {\n\t\tString result = null;\n\t\tif (\"0\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(MessageTemplate.getMainMenu());\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"1\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\n\t\t\t\t\t\"<a href=\\\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\\\">点击跳转网页welcome</a>\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"2\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\n\t\t\t\t\t\"<a href=\\\"http://rotornet.tunnel.qydev.com/WXTest/jsp/content.jsp\\\">点击跳转网页content</a>\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"3\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getSingleNews();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else if (\"4\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getSingleNewsNoImage();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else if (\"5\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getNews();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\"没有找到指令，请重新输入\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t}\n\t\treturn result;\n\n\t}\n\n\t/** 菜单点击事件 */\n\tpublic String dealClickReq(String toUserName, String fromUserName, String msgType, String eventKey) {\n\t\t// TODO Auto-generated method stub\n\t\tString result = null;\n\t\tTextMessageResp textMessageResp = getTextMessageResp(toUserName,fromUserName);\n\t\tif (eventKey.equals(\"11\")) {\n\t\t\ttextMessageResp.setContent(\"测试1被点击\");\n\t\t}else if (eventKey.equals(\"12\")) {\n\t\t\ttextMessageResp.setContent(\"测试2被点击\");\n\t\t}else if (eventKey.equals(\"13\")) {\n\t\t\ttextMessageResp.setContent(\"测试3被点击\");\n\t\t}else if (eventKey.equals(\"14\")) {\n\t\t\ttextMessageResp.setContent(\"测试4被点击\");\n\t\t}else if (eventKey.equals(\"21\")) {\n\t\t\ttextMessageResp.setContent(\"快递查询被点击\");\n\t\t}else if (eventKey.equals(\"22\")) {\n\t\t\ttextMessageResp.setContent(\"经典游戏被点击\");\n\t\t}else if (eventKey.equals(\"23\")) {\n\t\t\ttextMessageResp.setContent(\"聊天唠嗑被点击\");\n\t\t}else if (eventKey.equals(\"33\")) {\n\t\t\ttextMessageResp.setContent(MessageTemplate.getMainMenu());\n\t\t}else{\n\t\t\ttextMessageResp.setContent(\"未找到功能\");\n\t\t}\n\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\treturn result;\n\t}\n\t/**此处和接收到的发送者，接受者相反*/\n\tprivate NewsMessageResp getNewsMessageResp(String fromUserName, String toUserName) {\n\t\t// TODO Auto-generated method stub\n\t\tNewsMessageResp newsMessage = new NewsMessageResp();\n\t\tnewsMessage.setFromUserName(fromUserName);\n\t\tnewsMessage.setToUserName(toUserName);\n\t\tnewsMessage.setCreateTime(new Date().getTime());\n\t\tnewsMessage.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);\n\t\tnewsMessage.setFuncFlag(0);\n\t\treturn newsMessage;\n\t}\n\t/**此处和接收到的发送者，接受者相反*/\n\tprivate TextMessageResp getTextMessageResp(String fromUserName, String toUserName) {\n\t\tTextMessageResp textMessageResp = new TextMessageResp();\n\t\ttextMessageResp.setFromUserName(fromUserName);\n\t\ttextMessageResp.setToUserName(toUserName);\n\t\ttextMessageResp.setCreateTime(new Date().getTime());\n\t\ttextMessageResp.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);\n\t\ttextMessageResp.setFuncFlag(0);\n\t\treturn textMessageResp;\n\t}\n}\n```\n\nMessageTemplate\n\n```java\n/**\n * 消息模板\n */\npublic class MessageTemplate {\n\t/**\n\t * 主菜单消息\n\t */\n\tpublic static String getMainMenu() {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tbuffer.append(\"您好/::)，请回复数字选择服务：\").append(\"\\n\\n\");\n\t\tbuffer.append(\"1  网页welcome预览\").append(\"\\n\");\n\t\tbuffer.append(\"2  网页content预览\").append(\"\\n\");\n\t\tbuffer.append(\"3  单图文消息预览1\").append(\"\\n\");\n\t\tbuffer.append(\"4  单图文消息预览2\").append(\"\\n\");\n\t\tbuffer.append(\"5  多图文消息预览\").append(\"\\n\\n\");\n\t\tbuffer.append(\"回复“0”显示此帮助菜单\");\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * 超链接信息\n\t */\n\tpublic static String getUrlContent(String content, String url) {\n\t\treturn \"<a href=\\\"\" + url + \"\\\">\" + content + \"</a>\";\n\t}\n\n\t/**\n\t * 单图文消息\n\t */\n\tpublic static List<ArticleResp> getSingleNews() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article = new ArticleResp();\n\t\tarticle.setTitle(\"微信公众帐号开发教程Java版\");\n\t\tarticle.setDescription(\"测试微信公众号单图文消息-\"+String.valueOf(Character.toChars(0x1F334))+\"\");\n\t\tarticle.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower.jpg\");\n\t\tarticle.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article);\n\t\treturn articles;\n\t}\n\n\t/**\n\t * 单图文消息---不含图片\n\t */\n\tpublic static List<ArticleResp> getSingleNewsNoImage() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article = new ArticleResp();\n\t\tarticle.setTitle(\"微信公众帐号单图文消息测试\");\n\t\tarticle.setDescription(\"测试微信公众号单图文消息--无图片\"+String.valueOf(Character.toChars(0x2764))+\"心分两半，一半清醒，一半醉\");\n\t\t//图片设置为空\n\t\tarticle.setPicUrl(\"\");\n\t\tarticle.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article);\n\t\treturn articles;\n\t}\n\t/**多图文消息*/\n\tpublic static List<ArticleResp> getNews() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article1 = new ArticleResp();\n\t\tarticle1.setTitle(\"微信公众号多图文消息\");\n\t\t//description页面不会显示\n\t\tarticle1.setDescription(\"\");\n\t\tarticle1.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower3.jpg\");\n\t\tarticle1.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tArticleResp article2 = new ArticleResp();\n\t\tarticle2.setTitle(\"微信\"+String.valueOf(Character.toChars(0x1F334))+\"公众号图文消息二\");\n\t\t//description页面不会显示\n\t\tarticle2.setDescription(\"\");\n\t\tarticle2.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower2.jpg\");\n\t\tarticle2.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tArticleResp article3 = new ArticleResp();\n\t\tarticle3.setTitle(\"微信\"+String.valueOf(Character.toChars(0x1F339))+\"公众号图文消息三\");\n\t\tarticle3.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower1.jpg\");\n\t\tarticle3.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article1);\n\t\tarticles.add(article2);\n\t\tarticles.add(article3);\n\t\treturn articles;\n\t}\n\t\n}\n```\n\nimages\n\n![](微信公众号接入\\1.jpg)\n\n![](微信公众号接入\\2.jpg)\n\n![](微信公众号接入\\3.jpg)\n\n![](微信公众号接入\\4.jpg)\n\nwelcome.jsp\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.css\">\n<script src=\"https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js\"></script>\n<script src=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.js\"></script>\n</head>\n\n<body>\n\n<div data-role=\"page\">\n  <div data-role=\"header\">\n    <h1>欢迎来到我的微信测试公众号</h1>\n  </div>\n\n  <div data-role=\"main\" class=\"ui-content\">\n    <p>这是一个简单的测试公众号!!</p>\n  </div>\n\n  <div data-role=\"footer\">\n    <h1>有疑问欢迎致电客服</h1>\n  </div>\n</div> \n\n</body>\n</html>\n```\n\ncontent.jsp\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.css\">\n<script src=\"https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js\"></script>\n<script src=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.js\"></script>\n</head>\n<script>\n  function message(){\n\t  var chk_value =[]; \n\t  var name=$(\"#name\").val();\n\t  $(\"input[name='favcolor']:checked\").each(function(){\n\t\t  chk_value.push($(this).val()); \n\t  });\n\t  alert(\"您的全名是:\"+name+\" 您喜欢的颜色是：\"+chk_value);\n  }\n</script>\n<body>\n\n<div data-role=\"page\">\n  <div data-role=\"header\">\n  <h1>公众号主题页面</h1>\n  </div>\n  <div data-role=\"main\" class=\"ui-content\">\n    <form method=\"post\" >\n      <fieldset data-role=\"collapsible\" data-theme=\"b\" data-content-theme=\"b\">\n        <legend>点击可折叠</legend>\n          <label for=\"name\">全名:</label>\n          <input type=\"text\" name=\"text\" id=\"name\" data-theme=\"a\">\n          <p>喜爱的颜色:</p>\n        <div data-role=\"controlgroup\">\n          <label for=\"red\">红色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"red\" value=\"red\">\n          <label for=\"green\">绿色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"green\" value=\"green\">\n          <label for=\"blue\">蓝色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"blue\" value=\"blue\" >\n        </div>\t\n      <input type=\"button\" data-inline=\"true\" onclick=\"message()\"  value=\"提交\" data-theme=\"b\">\n      </fieldset>\n    </form>\n  </div>\n</div>\n\n</body>\n</html>\n```","tags":["公众号"]},{"title":"java处理excel","url":"/2017/04/22/java基础/java操作excel/","content":"\n主要介绍读取excel和写入excel，以及更改excel中内容(模板)\n\n网上有很多针对03版execl写入的教程，此处不做介绍\n\n需要的jar包如图：\n\n![](https://static.oschina.net/uploads/space/2017/0422/184340_V0Lg_3429289.png)\n\n文本中三个方法，分别对应读取excel，修改excel，和新建excel\n\n```java\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.Workbook;\nimport org.apache.poi.xssf.streaming.SXSSFWorkbook;\nimport org.apache.poi.xssf.usermodel.XSSFRow;\nimport org.apache.poi.xssf.usermodel.XSSFSheet;\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook;\n\n/**\n * @author 嗡嗡作响\n * 仅针对07版本excel说明，03版网上有很多教程，请自行参考\n * */\npublic class DoExcel {\n\t\n\t//读取excel文件，放入Map中，实际一般是放在po中\n\t@SuppressWarnings(\"unchecked\")\n\tpublic List<Map> read(String filepath) {\n\t\tXSSFWorkbook wb;\n\t\tList<Map> list = new ArrayList<Map>();\n\t\ttry {\n\t\t\twb = new XSSFWorkbook(new FileInputStream(filepath));\n\t\t\tXSSFSheet sheet = wb.getSheetAt(0);\n\t\t\tXSSFRow row;\n\t\t\tfor (int i = sheet.getFirstRowNum(); i < sheet\n\t\t\t\t\t.getPhysicalNumberOfRows(); i++) {\n\t\t\t\trow = sheet.getRow(i);\n\t\t\t\tMap<String, String> map = new HashMap<String, String>();\n\t\t\t\tif (row.getCell(0) != null) {\n\t\t\t\t\tmap.put(\"index0\", row.getCell(0).toString());\n\t\t\t\t}\n\t\t\t\tif (row.getCell(1) != null) {\n\t\t\t\t\tmap.put(\"index1\", row.getCell(1).toString());\n\t\t\t\t}\n\t\t\t\tif (row.getCell(2) != null) {\n\t\t\t\t\tmap.put(\"index2\", row.getCell(2).toString());\n\t\t\t\t}\n\t\t\t\tlist.add(map);\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn list;\n\t}\n\t//写入新的excel中，可预设定excel模板，向模板中加数据，导出新的excel\n\tpublic void writeExcel(String filepath1) {\n\t\tWorkbook wb = null;\n\t\tFileOutputStream out = null;\n\t\ttry {\n\t\t\twb = new XSSFWorkbook(new FileInputStream(filepath1));\n\t\t\tSheet sh = wb.getSheetAt(0);\n\t\t\tRow row = sh.getRow(2);\n\t\t\tCell cell = row.createCell(0);\n\t\t\tString value = \"料號\";\n\t\t\tcell.setCellValue(value);\n\t\t\tout = new FileOutputStream(\"d:\\\\test\\\\testnew.xlsx\");\n\t\t\t//wb.write(out);\n\t\t\tSystem.out.println(\"OK\");\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (out != null) {\n\t\t\t\t\twb.write(out);\n\t\t\t\t\tout.flush();\n\t\t\t\t\tout.close();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n//新建excel的demo，仅作参考\n\tpublic void writeExcelDemo() {\n\t\tWorkbook wb = new SXSSFWorkbook(100);//内存保留 100 条数据，避免内存溢出，其余写入 硬盘\n\t\tSheet sh = wb.createSheet();//创建sheet\n\t\tRow row = sh.createRow(0);//创建行\n\t\tCell cell = row.createCell(0);//创建对应行的第几列\n\t\tString value = \"料號\";\n\t\tcell.setCellValue(value);\n\t\tcell = row.createCell(1);\n\t\tvalue = \"物料名稱\";\n\t\tcell.setCellValue(value);\n\t\tFileOutputStream out;\n\t\ttry {\n\t\t\tout = new FileOutputStream(\"d:\\\\test\\\\username.xlsx\");//输出文件路径\n\t\t\ttry {\n\t\t\t\twb.write(out); \n\t\t\t\tout.close();\n\t\t\t\tSystem.out.println(\"ok\");\n\t\t\t} catch (IOException e) {\n\t\t\t\t// \n\t\t\t\te.printStackTrace();\n\t\t\t}\n\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// \n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t//List<Map> aa = new ReadExcel().read(\"D:\\\\test\\\\test.xlsx\");\n\t\t//System.out.println(aa);\n\t\tnew DoExcel().writeExcel(\"D:\\\\test\\\\test111.xlsx\");\n\t\tSystem.out.println(\"---\");\n\t//\tnew ReadExcel().writeExcelDemo();\n\t}\n}\n```"},{"title":"nginx+tomcat入门配置","url":"/2017/04/21/nginx/nginx+tomcat入门配置/","content":"\n    此文仅作入门学习，以及记录下配置中遇到的坑。首先nginx+tomcat主要为了实现负载均衡 (分发请求)。为了解释清楚负载均衡，这里假设www.test.com采用这种配置，当我们去访问www.test.com这个网址的时候，请求是传到了nginx服务器，然后由nginx分发到tomcat，假设我们启动了10个tomcat，nginx根据我们的配置分发请求给指定的tomcat，减轻服务器压力。\n\n# 1.工具\n\nnginx-1.8.0\n\napache-tomcat-6.0.20\n\napache-tomcat-8.0.30\n\n# 2.Nginx+tomcat配置\n\n解压后在nginx-1.8.0\\\\conf\\\\中找到Nginx配置文件nginx.conf进行配置。\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\t#location / {\n        #    proxy_pass http://backend_tomcat;\n        #}\n        }\n```\n\n先找到配置文件中server{}，这里listen 8080监听8080端口\n\n如果启动了nginx，输入http://localhost:8080会看见![](https://static.oschina.net/uploads/space/2017/0421/103109_IUKW_3429289.png)\n\n接下来取消注解location / {  \n            proxy\\_pass http://backend\\_tomcat;  \n        }这里标示将请求转发给backend_tomcat（名字随意），然后在http里配置backend_tomcat，与server同一级。\n\n```xml\nhttp{\n\tupstream backend_tomcat{\n\t\t\n\t\tserver 127.0.0.1:80 weight=1;\n\t\tserver 127.0.0.1:8888 weight=1;\n\t}\n\t\n    server {\n    }\n}\n```\n\n这里配置两个server对应两个tomcat，一个80端口的tomcat6，一个8888端口的tomcat8，weight表示访问的权重。\n\n配置好后，启动tomcat6和tomcat8，启动nginx，访问http://localhost:8080一直刷新，会看见在tomcat6和tomcat8界面切换。实现分发请求\n\n# 3.nginx实现静态分离\n\n这里主要说在使用nginx时，由于我们的请求是转发的，所以对于静态的文件无法直接加载，这里需要配置静态分离，即将js，css，image等静态资源放在nginx服务器，jsp，do，action等去分发请求。\n\n操作如下\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\n\t\tlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\t\n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   html;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\t\n\t\t\tproxy_pass http://backend_tomcat;\n\t\t}\n}\n```\n\n这里贴出代码注意，此时需要将第二点处的location /(如下图) 改为location ~ \\\\.(jsp|action)$(如上图)，第一个表示所有请求，第二个表示拦截以.jsp或者.action结尾的请求\n\nroot html表示拦截到的静态文件去html文件夹找，这里的html文件夹表示安装目录\\\\nginx-1.8.0\\\\html文件夹，可以在html里放一个test文件夹，放一个图片test.png，启动nginx，输入http://localhost:8080/test/test.png，此时可以访问\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\tlocation / {\n            proxy_pass http://backend_tomcat;\n        }\n        }\n```\n\n# 4.nignx配置导向项目\n\n        如果按上述配置将请求转发到项目位置，并将项目静态文件放到html文件夹下，此时发现报错，查看文件时发现在服务器的jsp页面中的basePath会被解析为backend_tomcat加上端口+项目名，系统找不到backend\\_tomcat，此时需要在添加proxy\\_set\\_header Host， proxy\\_set_header，这里作用及时重写请求头，防止后端服务器处理时认为所有请求都来自反向代理服务器。\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\t#location / {\n        #    proxy_pass http://backend_tomcat;\n        #}\n\t\tlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   filetest;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n\t\t\tproxy_pass http://backend_tomcat;\n\t\t}\n```\n\n如图，配置后，重跑ngnix，发现请求地址对了，但是对于nginx中的静态文件未显示端口，加载不出静态文件。此时再加上host中的端口，如下图\n\n```xml\nlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\tproxy_set_header Host  $host:8080; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   filetest;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n\t\t\tproxy_pass http://backend_tomcat;\n```\n\n重新启动nginx，配置完成，正常访问","tags":["nginx"]}]