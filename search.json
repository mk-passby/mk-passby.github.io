[{"title":"Spring 工厂","url":"/2020/09/12/框架系列/spring/Spring工厂/","content":"\n\n\n## Spring 工厂\n\n1.传统的创建对象的方式为直接new一个对象，这样导致对象间耦合度高，如果对象发生变化，则需要到处修改。这样导致很多时候我们只是想在不同的地方调用对象的方法，但是不得不重复创建对象。\n\n### 创建对象\n\n这里列举两个对象的创建方式(不止这两个，序列化，克隆等都是，这里我们只介绍new和反射)\n\n- 直接new创建对象\n- 反射创建对象\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\nimport com.mk.learn.spring.ioc.module.User;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-27 22:40\n **/\npublic class Test {\n\n    public static void main(String[] args)\n        throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        //直接new创建对象\n        //User user=new User();\n        Test test = new Test();\n        //反射创建对象\n        User user = test.createUserByRefle();\n\n    }\n\n    private User createUserByRefle()\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return (User) Class.forName(\"com.mk.learn.spring.ioc.module.User\").newInstance();\n    }\n\n}\n\n```\n\n这样直接看两种创建方式似乎没什么差别，但是如果将`\"com.mk.learn.spring.ioc.module.User\"`这部分内容提出来呢。使用工厂模式，于是有了下面的变形\n\n### 将对象的创建交给工厂\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-17 21:10\n **/\npublic class NormalFactory {\n    public static Object createObjectByRefle(String className)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return Class.forName(className).newInstance();\n    }\n}\n```\n\n于是对象的创建就通过如下的方式\n\n```java\nUser user1 = (User) NormalFactory.createObjectByRefle(User.class.getName());\n```\n\n**思考该创建方式**\n\n- 为什么这里createObjectByRefle要用Object做返回值不用User对象呢？如果用User对象都不用强转不是更方便吗？\n  - 如果使用User对象做返回值<font color=#FF0000>扩展性极差</font>，假设有一个UserA对象需要用工厂创建，就需要新增一个创建UserA的方法。这样导致工厂类臃肿。使用Object做返回值则更优雅。\n\n\n\n但是这里又有一个问题，这里工厂创建的对象不够灵活。NormalFactory对象强依赖User.class.getName()。既然已经强依赖了，那么怎么思考下是不是需要统一管理呢？\n\n### 怎么处理类的统一管理呢？\n\n这里我们可以通过配置文件统一管理类名。\n\n这里使用properties举例：\n\n在resources下新增factoryObject.properties\n\n```properties\nuser=com.mk.learn.spring.ioc.module.User\n```\n\n那么我们的工厂类进一步变为如下的方式创建：\n\n```java\n public static Object createObjectByProperties(String name)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException {\n        InputStream\n            inputStream =\n            NormalFactory.class.getResourceAsStream(\"/factoryObject.properties\");\n        Properties properties=new Properties();\n        properties.load(inputStream);\n\n            //创建普通对象\n        return Class.forName(properties.getProperty(name)).newInstance();\n    }\n```\n\n\n\n我们创建对象的方式可以改用如下：\n\n```java\n User user2 = (User) NormalFactory.createObjectByProperties(\"user\");\n```\n\n\n\n### 至此，我们的完整代码如下：\n\n- NormalFactory普通工厂\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-17 21:10\n **/\npublic class NormalFactory {\n\n    /**\n     * 通过工厂创建对象\n     * @param className\n     * @return\n     * @throws ClassNotFoundException\n     * @throws IllegalAccessException\n     * @throws InstantiationException\n     */\n    public static Object createObjectByRefle(String className)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return Class.forName(className).newInstance();\n    }\n\n    /**\n     * 通过工厂+properties创建对象\n     * @param name\n     * @return\n     * @throws ClassNotFoundException\n     * @throws IllegalAccessException\n     * @throws InstantiationException\n     * @throws IOException\n     */\n    public static Object createObjectByProperties(String name)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException {\n        InputStream\n            inputStream =\n            NormalFactory.class.getResourceAsStream(\"/factoryObject.properties\");\n        Properties properties=new Properties();\n        properties.load(inputStream);\n\n            //创建普通对象\n        return Class.forName(properties.getProperty(name)).newInstance();\n    }\n}\n\n```\n\n\n\n- Test测试类\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\nimport com.mk.learn.spring.ioc.module.User;\nimport java.io.IOException;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-27 22:40\n **/\npublic class Test {\n    public static void main(String[] args)\n        throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException {\n        //直接new创建对象\n        //User user=new User();\n        Test test = new Test();\n        System.out.println(\"通过new获取对象：\" + test);\n        System.out.println(test);\n        //反射创建对象\n        User user = test.createUserByRefle();\n        System.out.println(\"通过反射获取对象：\" + user);\n        //反射工厂创建对象\n        User user1 = (User) NormalFactory.createObjectByRefle(User.class.getName());\n        System.out.println(\"通过工厂反射获取对象：\" + user1);\n        //反射工厂+properties创建对象\n        User user2 = (User) NormalFactory.createObjectByProperties(\"user\");\n        System.out.println(\"通过properties获取对象：\" + user2);\n    }\n\n    private User createUserByRefle()\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return (User) Class.forName(\"com.mk.learn.spring.ioc.module.User\").newInstance();\n    }\n}\n```\n\n- user对象\n\n```java\npackage com.mk.learn.spring.ioc.module;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-25 22:20\n **/\npublic class User {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n```\n\n\n\n### spring怎么获取bean对象的呢\n\n#### 依赖jar包\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <parent>\n    <artifactId>learning-demo</artifactId>\n    <groupId>com.learn.mk</groupId>\n    <version>1.0-SNAPSHOT</version>\n  </parent>\n  <modelVersion>4.0.0</modelVersion>\n  <artifactId>spring-demo</artifactId>\n<dependencies>\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>5.1.4.RELEASE</version>\n  </dependency>\n</dependencies>\n</project>\n```\n\n#### 创建xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user\" class=\"com.mk.learn.spring.ioc.module.User\"/>\n</beans>\n```\n\n#### 编写测试类测试\n\n```java\npackage com.mk.learn.spring.ioc.spring;\n\nimport com.mk.learn.spring.ioc.module.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-13 20:34\n **/\npublic class SpringBeanTest {\n\n    public static void main(String[] args) {\n        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(\"springBean.xml\");\n        User user = (User) applicationContext.getBean(\"user\");\n        System.out.println(\"通过spring创建Bean\"+user);\n    }\n}\n```\n\n运行结果：\n\n```\n通过spring创建Beancom.mk.learn.spring.ioc.module.User@77caeb3e\n\nProcess finished with exit code 0\n```\n\n\n\n### spring工厂的本质\n\n结合前面springbean的创建方式和对象由工厂创建的思维。可以得到我们spring工厂的本质就是工厂模式。\n\n即：\n\n- ApplicationContext⼯⼚ +springBean.xml配置文件\n\n## ApplicationContext工厂\n\n### ApplicationContext接⼝类型\n\n- 接⼝：屏蔽实现的差异\n- ⾮web环境的实现类 ：ClassPathXmlApplicationContext(main junit)\n- web环境的实现类 ：XmlWebApplicationContext\n\n### ApplicationContext常用API\n\n| 方法                                         | 介绍                                                    |\n| -------------------------------------------- | ------------------------------------------------------- |\n| getBean(String name, Class<T> requiredType)  | 通过这种⽅式获得对象，就不需要强制类型转换              |\n| getBean(Class<T> requiredType)               | 当前Spring的配置⽂件中 只能有⼀个bean class是Person类型 |\n| getBeanDefinitionNames()                     | 获取的是 Spring⼯⼚配置⽂件中所有bean标签的id值         |\n| getBeanNamesForType(@Nullable Class<?> type) | 根据类型获得Spring配置⽂件中对应的id值                  |\n| containsBeanDefinition(String beanName)      | ⽤于判断是否存在指定id值得bean,不能判断name值           |\n| containsBean(String beanName)                | ⽤于判断是否存在指定id值得bean,能判断name值             |\n\n## 配置⽂件中需要注意的细节\n\n- 只配置class属性,得到的id是com.mk.learn.spring.ioc.module.Dog#0\n  - 如果需要被其他bean引用需要配置上这个id\n\n```xml\n<bean class=\"com.mk.learn.spring.ioc.module.Dog\"/>\n```\n\n- name属性\n  - ⽤于在Spring的配置⽂件中，为bean对象定义别名。\n  - id是唯一值，只能有一个，但是别名可以定义多个。\n\n## 开发过程中，所有的对象都交给Spring⼯⼚来创建？\n\n- 理论上 是的，但是有特例 ：实体对象(entity)是不会交给Spring创建，它是由持久层框架进⾏创建\n\n## Spring5.x与⽇志框架的整合\n\n- Spring与⽇志框架进⾏整合，⽇志框架就可以在控制台中，输出Spring框架运⾏过程中的⼀些重要的信息。\n- 好处：便于了解Spring框架的运⾏过程，利于程序的调试\n\n### Spring如何整合⽇志框架\n\n -  引⼊log4j jar包\n\n    - POM文件\n\n```xml\n<dependency>\n <groupId>org.slf4j</groupId>\n <artifactId>slf4jlog4j12</artifactId>\n <version>1.7.25</version>\n</dependency>\n<dependency>\n <groupId>log4j</groupId>\n <artifactId>log4j</artifactId>\n <version>1.2.17</version>\n</dependency>\n```\n\n- log4j.properties，放在resources目录下\n\n```properties\n### 配置根\nlog4j.rootLogger =debug,console\n### ⽇志输出到控制台显示\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target=System.out\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n\n运行结果如下：\n\n```markdown\n2020-09-13 21:29:09 DEBUG ClassPathXmlApplicationContext:590 - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1edf1c96\n2020-09-13 21:29:09 DEBUG XmlBeanDefinitionReader:395 - Loaded 3 bean definitions from class path resource [springBean.xml]\n2020-09-13 21:29:09 DEBUG DefaultListableBeanFactory:213 - Creating shared instance of singleton bean 'user'\n2020-09-13 21:29:09 DEBUG DefaultListableBeanFactory:213 - Creating shared instance of singleton bean 'user1'\n2020-09-13 21:29:09 DEBUG DefaultListableBeanFactory:213 - Creating shared instance of singleton bean 'com.mk.learn.spring.ioc.module.Dog#0'\n通过spring创建Beancom.mk.learn.spring.ioc.module.User@1f36e637\nBeanDefinitionName is:user\nBeanDefinitionName is:user1\nBeanDefinitionName is:com.mk.learn.spring.ioc.module.Dog#0\nbeanNamesForType = user\nbeanNamesForType = user1\n```\n\n## 注⼊(Injection)\n\n- 通过编码的⽅式，为成员变量进⾏赋值，存在耦合\n\n### 如何进⾏注⼊\n\n- 类的成员变量提供set get⽅法\n- 配置spring的配置⽂件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user\" class=\"com.mk.learn.spring.ioc.module.User\">\n    <property name=\"name\">\n      <value>AAA1111</value>\n    </property>\n    <property name=\"age\" value=\"123\"/>\n  </bean>\n</beans>\n```\n\n- 测试类\n\n```java\npackage com.mk.learn.spring.ioc.spring;\n\nimport com.mk.learn.spring.ioc.module.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-13 21:34\n **/\npublic class SpringIocTest  {\n\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            \"springIoc.xml\");\n        User user = (User) applicationContext.getBean(\"user\");\n        System.out.println(\"user.getName() = \" + user.getName());\n        System.out.println(\"user.getAge() = \" + user.getAge());\n    }\n}\n```\n\n### 常用的注入方式\n\n#### JDK类型\n\n- 数组/List集合\n\n```xml\n<list>\n <value>AAA</value>\n <value>BBBB</value>\n <value>CCC</value>\n</list>\n```\n\n- Set集合\n\n```xml\n<set>\n <value>AAA</value>\n <value>BBBB</value>\n <value>CCC</value>\n</set>\n```\n\n- Map集合\n\n```xml\n<map>\n <entry>\n <key><value>AA</value></key>\n <value>CCCC</value>\n </entry>\n <entry>\n <key><value>AA1</value></key>\n <ref bean=\"XXXX\"/>\n </entry>\n</map>\n```\n\n- Properites\n\n```properties\n<props>\n <prop key=\"key1\">value1</prop>\n <prop key=\"key2\">value2</prop>\n</props>\n```\n\n#### ⽤户⾃定义类型\n\n- 直接配置bean对象注入\n  - 为成员变量提供set get⽅法\n  - 配置⽂件中进⾏注⼊\n\n```xml\n<bean id=\"userService\" class=\"xxxx.UserServiceImpl\">\n \t<property name=\"userDAO\">\n \t\t<bean class=\"xxx.UserDAOImpl\"/>\n \t</property>\n</bean>\n```\n\n- 使用ref指向bean\n\n```xml\n<bean id=\"userDAO\" class=\"xxx.UserDAOImpl\"/>\n<bean id=\"userService\" class=\"xxx.UserServiceImpl\">\n\t<property name=\"userDAO\">\n \t\t<ref bean=\"userDAO\"/>\n \t</property>\n</bean>\n```\n\n#### Set注⼊的简化写法\n\n```markdown\n<property name=\"aaa\">\n \t<value>CCCC</value>\n</property>\n \t可以简化为\n<property name=\"aaa\" value=\"CCCC\"/>\n\n-------------------------------\n⽤户⾃定义类型\n<property name=\"userDAO\">\n \t<ref bean=\"userDAO\"/>\n</property>\n\t可以简化为\n<property name=\"userDAO\" ref=\"userDAO\"/>\n\n-------------------------------\n<bean id=\"person\" class=\"xxxx.Person\">\n <property name=\"name\">\n \t<value>AAA</value>\n </property>\n</bean>\n\t可以简化为(需要引入命名空间p标签)\n<bean id=\"person\" class=\"xxx.Person\" p:name=\"AAA\"/>\n\n---------------------------------\n<bean id=\"userService\" class=\"xx.UserServiceImpl\">\n\t<property name=\"userDAO\">\n \t\t<ref bean=\"userDAO\"/>\n \t</property>\n</bean>\n\t可以简化为(需要引入命名空间p标签)\n<bean id=\"userService\" class=\"xxx.UserServiceImpl\" p:userDAO-ref=\"userDAO\"/>\n```\n\n\n\n#### 构造注⼊\n\n- 参数个数不同时通过控制`<constructor-arg>`标签的数量进⾏区分\n- 构造参数个数相同时,通过在标签引⼊ type属性 进⾏类型的区分`<constructor-arg type=\"\">`\n\n```java\npublic class ConstructorModule {\n    private int age;\n    private String naem;\n    public ConstructorModule(int age, String naem) {\n        this.age = age;\n        this.naem = naem;\n    }\n}\n```\n\n\n\n\n\n```xml\n <!--构造器注入-->\n  <bean id=\"constructorDemo\" class=\"com.mk.learn.spring.ioc.module.ConstructorModule\">\n    <constructor-arg value=\"123\"/>\n    <constructor-arg value=\"AAAA\"/>\n  </bean>\n```\n\n## Spring⼯⼚创建复杂对象\n\n- 复杂对象：指的就是不能直接通过new构造⽅法创建的对象(Connection,SqlSessionFactory)\n\n### Spring⼯⼚创建复杂对象的3种⽅式\n\n#### 1.FactoryBean接⼝\n\n- 实现FactoryBean接⼝\n- Spring内部运⾏流程\n  1. 通过conn获得ConnectionFactoryBean类的对象 ，进⽽通过instanceof 判断出是FactoryBean接⼝的实现类\n  2. Spring按照规定 getObject() --->Connection\n  3. 返回Connection\n\n```java\npackage com.mk.learn.spring.ioc.module;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport org.springframework.beans.factory.FactoryBean;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-13 22:26\n **/\npublic class ConnectionFactoryBean implements FactoryBean<Connection> {\n\n    @Override\n    public Connection getObject() throws Exception {\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        Connection connection= DriverManager.getConnection(\n            \"jdbc:mysql://localhost:3306/test?useSSL=false\",\n            \"root\",\n            \"xxxx\");\n        return connection;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return Connection.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}\n```\n\n#### 2.实例⼯⼚\n\n```xml\n<bean id=\"connFactory\" class=\"com.mk.learn.spring.ioc.module.ConnectionFactoryBean\"></bean>\n<bean id=\"conn\" factorybean=\"connFactory\" factorymethod=\"getConnection\"/>\n```\n\n#### 3.静态⼯⼚\n\n```xml\n<bean id=\"conn\" class=\"com.mk.learn.spring.ioc.module.ConnectionFactoryBean\"  factorymethod=\"getConnection\"/>\n```\n\n\n\n## 控制Spring⼯⼚创建对象的次数\n\n### 简单对象的创建次数\n\n```markdown\n<bean id=\"account\" scope=\"singleton|prototype\" class=\"xxxx.Account\"/>\n\tsigleton:只会创建⼀次简单对象 默认值\n\tprototype:每⼀次都会创建新的对象\n```\n\n### 复杂对象的创建次数\n\n```markdown\nFactoryBean{\n isSingleton(){\n \treturn true 只会创建⼀次\n \treturn false 每⼀次都会创建新的\n }\n}\n\t如没有isSingleton⽅法 还是通过scope属性 进⾏对象创建次数的控制\n```\n\n","tags":["spring"]},{"title":"springcloud-总结","url":"/2020/08/23/框架系列/springcloud/springcloud总结/","content":"\n\n\n# 基础选型\n\n## springcloud系统基础项目实战\n\n-   [springcloud项目搭建](./SpringCloud项目搭建.md)\n    - 所有项目地址：[点击此处](https://github.com/mk-passby/springcloud2020)\n- [springcloud_1.版本选型](./springcloud_1.版本选型.md)\n\n## 微服务编码与构建\n\n### 热部署\n\n- 为什么需要热部署，热部署到底是干什么的？\n  \n- springboot热部署就是当一个项目在运行过程中，如果有代码修改，项目会自动重启，部署好最新的修改代码，避免人为手动重启。\n  \n- ​\t怎么设置热部署\n\n  - 新增pom依赖\n\n    ```markdown\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n       <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    ```\n\n  - 新增pom插件\n\n    ```markdown\n     \n    <build>\n      <plugins>\n        <plugin>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-maven-plugin</artifactId>\n          <configuration>\n            <fork>true</fork>\n            <addResources>true</addResources>\n          </configuration>\n        </plugin>\n      </plugins>\n    </build>\n    ```\n\n  - 开启自动build\n\n    ![](./springcloud总结/1.png)\n\n  - 设置应用运行时自动重启，快捷键ctrl+shift+alt+/\n\n    ![](./springcloud总结/2.png)\n\n\n\n### DependencyManagement\n\n在我们的分模块项目开发中通常会在父pom中看见DependencyManagement这个标签\n\n- 作用\n  - 能让所有子项目中引用一个依赖而不用显示的列出版本号\n- 注意\n  - DependencyManagement只是声明依赖，**不实现引入**，需要子项目显示声明所需要的依赖\n  - 如果子项目中声明的依赖没有知名version和scope，都是读取自父pom\n  - 如果子项目中指定了版本号，那么就用子项目中自己指定的版本\n\n\n\n# 服务注册与发现\n\n## Eureka基础知识\n\n### 服务治理\n\n![](./springcloud总结/3.bmp)\n\n### 服务注册与发现\n\n![](./springcloud总结/4.bmp)\n![](./springcloud总结/5.bmp)\n\n### Eureka两大组件\n![](./springcloud总结/6.bmp)\n\n### 单机Eureka构建步骤\n\n- EurekaServer\n  - yaml文件配置\n\n  ```yaml\n  server:\n    port: 7001\n  \n  eureka:\n    instance:\n      hostname: localhost  #eureka服务端的实例名字\n    client:\n      register-with-eureka: false    #表识不向注册中心注册自己\n      fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n       service-url:\n        defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/    #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n   \n  ```\n  - 主启动类加上@EnableEurekaServer\n\n  ```java\n  @EnableEurekaServer\n  @SpringBootApplication\n  public class EurekaMain7001 {\n      public static void main(String[] args) {\n          SpringApplication.run(EurekaMain7001.class,args);\n      }\n  }\n  ```\n\n  - pom\n\n  ```markdown\n   <dependencies>\n          <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server -->\n          <dependency>\n              <groupId>org.springframework.cloud</groupId>\n              <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n          </dependency>\n  </dependencies>\n  ```\n  \n    \n  \n    \n  \n- EurekaClient\n\n  - yaml\n\n    ```yaml\n    ![7](E:\\developProject\\hexo-aircloud-blog\\source\\_posts\\框架系列\\springcloud\\springcloud总结\\7.bmp)eureka:\n      client:\n        register-with-eureka: true\n        fetchRegistry: true\n        service-url:\n          defaultZone: http://localhost:7001/eureka\n    ```\n\n  - 主启动类@EnableEurekaClient\n\n    ```java\n    @EnableEurekaClient\n    @SpringBootApplication\n    public class PaymentMain8001 {\n        public static void main(String[] args) {\n            SpringApplication.run(PaymentMain8001.class,args);\n        }\n    }\n    ```\n    \n  - 导pom\n  \n      ```markdown\n       <dependencies>\n      <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server -->\n              <dependency>\n                  <groupId>org.springframework.cloud</groupId>\n                  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n              </dependency>\n       </dependencies>\n      ```\n\n### Eureka集群\n\n#### 原理说明\n\n![](springcloud总结\\7.bmp)\n\n解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错\n\n#### 构建步骤\n\n- EurekaService(7001和7002作为eureka集群)\n\n  - 7001的yaml\n\n  ```yaml\n  server:\n    port: 7001\n  \n  eureka:\n    instance:\n      hostname: eureka7001.com    #eureka服务端的实例名字\n    client:\n      register-with-eureka: false    #表识不向注册中心注册自己\n      fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n      service-url:\n        defaultZone: http://eureka7002.com:7002/eureka/    #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n   \n  ```\n\n  - 7002的yaml\n\n  ```yaml\n  server:\n    port: 7002\n  \n  eureka:\n    instance:\n      hostname: eureka7002.com #eureka服务端的实例名字\n    client:\n      register-with-eureka: false    #表识不向注册中心注册自己\n      fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n      service-url:\n        defaultZone: http://eureka7001.com:7001/eureka/     #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n   \n  ```\n\n  - 其他配置类似，此处省略\n\n- EurekaClient\n\n  - 注册到7001和7002上，修改yaml配置\n\n  ```yaml\n  service-url:\n    defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  #集群版\n  ```\n\n  - 其他配置类似，省略\n\n\n\n### 服务发现Discovery\n\n- 启动类上加上@EnableDiscoveryClient\n\n- 注入DiscoveryClient\n\n  ```java\n  @Resource\n  private DiscoveryClient discoveryClient;\n  ```\n\n  \n\n### Eureka自我保护\n\n- 某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存\n- 属于CAP里面的AP分支\n  ![](springcloud总结\\8.bmp)\n  ![](springcloud总结\\9.bmp)\n  ![](springcloud总结\\10.bmp)\n\n- 禁用自我保护机制\n\n  - eureakeServer端\n\n    - 出厂默认，自我保护机制是开启的。默认配置如：eureka.server.enable-self-preservation = true，如下是关闭的配置\n\n    ```yaml\n    server:\n      enable-self-preservation: false\n      eviction-interval-timer-in-ms: 2000\n    ```\n\n  - eureakeClient端\n\n    - eureka.instance.lease-renewal-interval-in-seconds=30 客户端想法段发送心跳的时间间隔\n    - eureka.instance.lease-expiration-duration-in-seconds=90服务端的心跳超时时间\n  \n  ![](springcloud总结\\11.bmp)\n\n## zookeeper提供服务注册与发现\n\n### 构建步骤\n\n- zookeeer搭建不走此处省略，可参考dubbo文章中安装zookeeper教程，[点此处跳转](../../中间件/dubbo/DUBBO+ZOOKEEPER入门.md)\n\n- pom\n\n```markdown\n  <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n        </dependency>\n\n```\n\n- 由于zookeeper自身就是一个服务提供者，所以不需要新建zkServcer的module了\n- 消费者注册到zookeeper\n  - 可能出现重启失败，zk的jar包冲突导致，spring-cloud-starter-zookeeper-discovery中的jar包和自己使用的zk版本冲突\n  - 服务节点是临时节点~~还是持久节点~~\n\n```yaml\nserver:\n  port: 8004\n\nspring:\n  application:\n    name: cloud-provider-payment\n  cloud:\n    zookeeper:\n      connect-string: 192.168.11.128:2181,192.168.11.129:2181,192.168.11.130:2181\n      base-sleep-time-ms: 10000\n```\n\n- 所有设置参考springcloud2020中，cloud-provider-payment8004和cloud-consumerzk-order80模块\n\n\n\n## Consul服务注册与发现\n\n- 是什么\n\n  https://www.consul.io/intro/index.html\n![](springcloud总结\\12.bmp)\n\n\n\n- 能做什么\n  - 服务发现\n  - 健康检查\n  - KV存储\n  - 安全\n  - 加密服务通信\n  - 多数据中心\n\n![1598160434397](springcloud总结\\13.png)\n\n- 怎么用\n\n  - 下载安装，由于官网软件下载太慢，推荐使用springcloud2020中soft中，我已下载好的，直接安装\n\n  - 双击运行，或使用开发模式启动(\n\n    ```shell\n    consul agent -dev\n    ```\n\n  - 访问Consul的首页：http;//localhost:8500\n\n### 构建步骤\n\n  Consul的构建和zk类似\n\n- 改pom，引入jar包\n\n```markdown\n   <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n```\n\n\n\n- 同样自己就是一个注册中心应用，自己就是server\n- 服务注册者注册consul，改yaml\n\n```yaml\nserver:\n  port: 8006\n\n\nspring:\n  application:\n    name: consul-provider-payment\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        service-name: ${spring.application.name}\n \n```\n\n\n\n## 三个注册中心异同点\n\n### CAP理论\n![](springcloud总结\\14.bmp)\n![](springcloud总结\\15.bmp)\n\n### AP(Eureka)\n![](springcloud总结\\16.bmp)\n\n\n### CP(Zookeeper/Consul)\n![](springcloud总结\\17.bmp)\n\n\n\n# Ribbon负载均衡服务调用\n\n- 是什么\n\n![](springcloud总结\\18.bmp)\n\n- 官网：https://github.com/Netflix/ribbon/wiki/Getting-Started\n- 类别\n  - 集中式LB\n    - 在消费方和提供方之间使用独立的LB设施，将访问请求通过某种策略传给消费方(F5,NGNIX)\n  - 进程内LB\n    - 将LB逻辑集成到消费方，消费方从服务注册中心获取哪些地址可用，然后自己选择一个合适的服务器(Ribbon)\n- 架构说明\n![](springcloud总结\\19.bmp)\n![](springcloud总结\\20.bmp)\n- ribbon的使用\n\n  - ribbon的使用相对很简单，因为eureka已经集成了ribbon，所以不需要我们再导包\n  - 负载均衡+RestTemplate调用\n\n### 核心组件IRule\n\nIRule:根据特定算法从服务列表中选取一个要访问的服务\n\n| 实现类                                  | 作用                                                         |\n| --------------------------------------- | ------------------------------------------------------------ |\n| com.netflix.loadbalancer.RoundRobinRule | 轮询                                                         |\n| com.netflix.loadbalancer.RandomRule     | 随机                                                         |\n| com.netflix.loadbalancer.RetryRule      | 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试 |\n| WeightedResponseTimeRule                | 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择 |\n| BestAvailableRule                       | 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 |\n| AvailabilityFilteringRule               | 先过滤掉故障实例，再选择并发较小的实例                       |\n| ZoneAvoidanceRule                       | 默认规则，复合判断server所在区域的性能和server的可用性选择服务器 |\n\n\n\n### 自定义自己的轮询算法\n\n参见文章，[Ribbon详解](Ribbon详解.md)\n\n# OpenFeign服务接口调用\n\n- 是什么\n\n![](springcloud总结\\21.bmp)\n![](springcloud总结\\22.bmp)\n\n\n\n- 官网：https://github.com/spring-cloud/spring-cloud-openfeign\n- 有什么用\n\n![](springcloud总结\\23.bmp)\n\n## 使用步骤\n\n- 改pom\n\n```markdown\n <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n```\n\n- 主启动类@EnableFeignClients\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n/**\n * @program: springcloud2020\n * @description: feign启动类\n * @author: mk_passby\n * @create: 2020-08-02 15:55\n **/\n@SpringBootApplication\n@EnableFeignClients\npublic class OrderFeignMain80 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(OrderFeignMain80.class, args);\n    }\n}\n\n```\n\n- 业务类，在接口配置@FeignClient\n\n```java\n\npackage com.bli.guigu.springcloud.service;\n\nimport com.bli.guigu.springcloud.entities.CommonResult;\nimport com.bli.guigu.springcloud.entities.Payment;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 15:59\n **/\n@Component\n@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")\npublic interface PaymentFeignService {\n\n    @GetMapping(value = \"payment/get/{id}\")\n    public CommonResult<Payment> getPayment(@PathVariable(\"id\") Long id);\n\n    @GetMapping(value = \"/payment/feign/timeout\")\n    public String paymentFeignTimeout();\n\n\n}\n```\n\n## OpenFeign超时控制\n\nOpenFeign接口调用默认等待一秒钟，超过后报错\n\n- YML文件里需要开启OpenFeign客户端超时控制\n\n```yaml\nribbon:\n  ReadTimeout:  5000\n  ConnectTimeout: 5000\n```\n\n\n\n## OpenFeign日志打印功能\n\nFeign提供了日志打印功能，我们可以通过配置日志的级别来了解到Feign中http请求的细节。(接口调用情况的监控)\n\n- 配置一个日志级别的bean\n\n```java\npackage com.bli.guigu.springcloud.config;\n\nimport feign.Logger;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 16:23\n **/\n@Configuration\npublic class FeignConfig {\n\n    @Bean\n    Logger.Level feignLoggerLevel(){\n        return Logger.Level.FULL;\n    }\n}\n```\n\n- YML文件里需要开启日志的Feign客户端\n\n```yaml\nlogging:\n  level:\n    com.bli.guigu.springcloud.service.PaymentFeignService: debug\n```\n\n# Hystrix断路器\n\n- 是什么\n  ![](springcloud总结\\24.bmp)\n\n- 作用：\n  - 服务降级：服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback\n  - 服务熔断：直接拒绝访问\n  - 接近实时的监控\n\n- 官网：https://github.com/Netflix/Hystrix/wiki/How-To-Use\n\n## 服务降级构建\n\n### pom引入jar包\n\n```markdown\n   <!--新增hystrix-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n```\n\n### 业务类开启服务降级\n\n- @HystrixCommand报异常后如何处理\n- 主启动类添加注解@EnableCircuitBreaker\n\n```java\npackage com.bli.guigu.springcloud.service;\n\nimport cn.hutool.core.util.IdUtil;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport io.micrometer.core.instrument.Meter.Id;\nimport java.util.concurrent.TimeUnit;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n/**\n * @program: springcloud2020\n * @description: service\n * @author: mk_passby\n * @create: 2020-08-02 16:46\n **/\n@Service\npublic class PaymentService {\n\n    public String paymentInfo_OK(Integer id) {\n        return \"线程池：\" + Thread.currentThread().getName() + \",paymentInfo_OK ,id:\" + id\n            + \"----------\";\n    }\n\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\", commandProperties = {\n        @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"5000\")})\n    public String paymentInfo_TimeOut(Integer id) {\n        try {\n            TimeUnit.SECONDS.sleep(id);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return \"线程池：\" + Thread.currentThread().getName() + \"   paymentInfo_TimeOut,id：  \" + id\n            + \"\\t\" + \"呜呜呜\" + \" 耗时(秒)\" + id;\n\n    }\n\n    public String paymentInfo_TimeOutHandler(Integer id) {\n        return \"线程池：\" + Thread.currentThread().getName() + \"  Error or timeout,id：  \" + id\n            + \"\\t\" + \"QAQ\";\n    }\n\n\n    //服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),  //是否开启断路器\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),   //请求次数\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),  //时间范围\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"), //失败率达到多少后跳闸\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id){\n        if (id < 0){\n            throw new RuntimeException(\"*****id 不能负数\");\n        }\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功,流水号：\"+serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id){\n        return \"id 不能负数，请稍候再试,(┬＿┬)/~~     id: \" +id;\n    }\n}\n\n```\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\nimport org.springframework.context.annotation.Bean;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 16:45\n **/\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker\npublic class PaymentHystrixMain8001 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentHystrixMain8001.class, args);\n    }\n\n    /**\n     * 此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     * servletRegistrationBean因为springBoot的默认路径不是\"/hystrix.stream\"\n     * @return\n     */\n    @Bean\n    public ServletRegistrationBean getServlet(){\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);\n        registrationBean.setLoadOnStartup(1);\n        registrationBean.addUrlMappings(\"/hystrix.stream\");\n        registrationBean.setName(\"HystrixMetricsStreamServlet\");\n        return registrationBean;\n    }\n}\n\n```\n\n### 服务调用方开启服务降级\n\n- yaml配置\n\n```yaml\nfeign:\n  hystrix:\n    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样\n```\n\n- 主启动开启@EnableHystrix\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.hystrix.EnableHystrix;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 17:25\n **/\n@SpringBootApplication\n@EnableFeignClients\n@EnableHystrix\npublic class OrderHystrixMain80 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(OrderHystrixMain80.class, args);\n    }\n\n}\n```\n\n- 业务类自己再设置兜底\n\n```java\n  @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    @HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\",\n        commandProperties = {\n            @HystrixProperty(\n                name = \"execution.isolation.thread.timeoutInMilliseconds\",\n                value = \"4000\") //1.5秒钟以内就是正常的业务逻辑\n        })\n    //@HystrixCommand\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n  //兜底方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id) {\n        return \"我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)\";\n    }\n\n```\n\n\n\n### 上述配置的问题\n\n每个方法配置一个兜底方法，过于膨胀\n\n- @DefaultProperties(defaultFallback = \"\")\n\n![](springcloud总结\\25.bmp)\n\n![](springcloud总结\\26.png)\n\n\n\n## 服务熔断\n- 是什么\n\n![](springcloud总结\\27.bmp)\n\n### 怎么配置\n```java\n //服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),  //是否开启断路器\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),   //请求次数\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),  //时间范围\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"), //失败率达到多少后跳闸\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id){\n        if (id < 0){\n            throw new RuntimeException(\"*****id 不能负数\");\n        }\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功,流水号：\"+serialNumber;\n    }\n\n```\n\n### 参数说明\n\n![](springcloud总结\\28.bmp)\n\n## 服务监控hystrixDashboard\n\n- 见springcloud2020下的cloud-consumer-hystrix-dashboard9001\n\n![](springcloud总结\\29.bmp)\n![](springcloud总结\\30.bmp)\n![](springcloud总结\\31.bmp)\n\n\n\n# Gateway新一代网关\n\n- 官网：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/\n- 是什么\n  - Spring Cloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架\n ![](springcloud总结\\32.bmp)\n ![](springcloud总结\\33.bmp)\n ![](springcloud总结\\34.bmp)\n- 作用\n  - 反向代理\n  - 鉴权\n  - 流控\n  - 熔断\n  - 日志监控\n\n## 微服务架构中的网关\n\n ![](springcloud总结\\35.bmp)\n\n## 为什么选用springcloud gateway\n\n- neflix不太靠谱，zuul2.0一直跳票,迟迟不发布\n- SpringCloud Gateway与Zuul的区别\n ![](springcloud总结\\36.bmp)\n\n## spingcloudgateway的特点\n ![](springcloud总结\\37.bmp)\n\n- Route路由\n  - 路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由\n- Predicate断言\n  - 参考的是java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由\n- Filter(过滤)\n  - 指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。\n\n![](springcloud总结\\38.bmp)\n\n## 路由和断言配置方式\n\n### 在配置文件yaml中配置\n\n- pom\n\n```markdown\n   <dependencies>\n        <!--新增gateway-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n```\n\n- 改yaml\n\n```yaml\nserver:\n  port: 9527\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001   #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**   #断言,路径相匹配的进行路由\n\n        - id: payment_routh2\n          uri: http://localhost:8001\n          predicates:\n            - Path=/payment/lb/**   #断言,路径相匹配的进行路由\n            #- After=2020-03-08T10:59:34.102+08:00[Asia/Shanghai]\n            #- Cookie=username,zhangshuai #并且Cookie是username=zhangshuai才能访问\n            #- Header=X-Request-Id, \\d+ #请求头中要有X-Request-Id属性并且值为整数的正则表达式\n            #- Host=**.atguigu.com\n            #- Method=GET\n            #- Query=username, \\d+ #要有参数名称并且是正整数才能路由\n\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client:\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n###  代码中注入RouteLocator的Bean\n\n- 配置类如下\n\n```java\npackage com.bli.guigu.springcloud.config;\n\nimport org.springframework.cloud.gateway.route.RouteLocator;\nimport org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n *\n * @program: springcloud2020\n * @description:文档路径：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/\n * @author: mk_passby\n * @create: 2020-08-03 23:01\n **/\n@Configuration\npublic class GatewayConfig {\n\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n        //http://news.baidu.com/guoji\n        return builder.routes()\n            .route(\"path_route_bliguigu\",\n                r -> r.path(\"/guonei\").uri(\"http://news.baidu.com/guonei\")).build();\n    }\n\n\n```\n\n## 使用网关做过滤\n\n### 在配置文件yaml中配置i \n\n- 这里就取一个springcloudGateway的官网的例子吧，Example 13. application.yml\n\n  ```yaml\n  spring:\n    cloud:\n      gateway:\n        routes:\n        - id: add_request_header_route\n          uri: https://example.org\n          filters:\n          - AddRequestHeader=X-Request-red, blue\n          - AddRequestParameter=red, blue\n  ```\n  - 注意这里的过滤是指可以修改传入或传出的HTTP请求响应。\n  - 如上 - AddRequestHeader=X-Request-red, blue表示给所有匹配的请求头中添加了 X-Request-red: blue\n  - AddRequestParameter=red, blue表示给所有匹配的请求添加查询字符串`red=blue`，比如我的请求是localhost/getUser，实际传过去的就是多传了一个red=blue的传参过去，类似get请求的localhost/getUser?red=blue\n\n### 代码中注入RouteLocator的Bean\n\n```java\n\npackage com.bli.guigu.springcloud.config;\n\nimport org.springframework.cloud.gateway.route.RouteLocator;\nimport org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @program: springcloud2020\n * @description:文档路径：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/\n * @author: mk_passby\n * @create: 2020-08-03 23:01\n **/\n@Configuration\npublic class GatewayConfig {\n\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n        //http://news.baidu.com/guoji\n        return builder.routes()\n            .route(\"path_route_bliguigu\",\n                r -> r.path(\"/guonei\")\n                    .filters(f -> f.addRequestHeader(\"X-Request-red\", \"blue\"))\n                    .uri(\"http://news.baidu.com/guonei\")).build();\n    }\n}\n\n```\n\n## 自定义全局gatewayfilter方式\n\n\n\n- 官网描述如下\n\n```java\n6.1. Combined Global Filter and GatewayFilter Ordering\nWhen a request matches a route, the filtering web handler adds all instances of GlobalFilter and all route-specific instances of GatewayFilter to a filter chain. This combined filter chain is sorted by the org.springframework.core.Ordered interface, which you can set by implementing the getOrder() method.\n\nAs Spring Cloud Gateway distinguishes between “pre” and “post” phases for filter logic execution (see How it Works), the filter with the highest precedence is the first in the “pre”-phase and the last in the “post”-phase.\n\nThe following listing configures a filter chain:\n\nExample 56. ExampleConfiguration.java\n@Bean\npublic GlobalFilter customFilter() {\n    return new CustomGlobalFilter();\n}\n\npublic class CustomGlobalFilter implements GlobalFilter, Ordered {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        log.info(\"custom global filter\");\n        return chain.filter(exchange);\n    }\n\n    @Override\n    public int getOrder() {\n        return -1;\n    }\n}\n```\n\n- 实现接口GlobalFilter, Ordered\n- 注意，此处就是一个责任链的设计模式\n\n```java\n\npackage com.bli.guigu.springcloud.filter;\n\nimport java.time.ZonedDateTime;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.core.Ordered;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-04 21:55\n **/\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter, Ordered {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        log.info(\"***********come in :\" + ZonedDateTime.now());\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n        if (StringUtils.isEmpty(uname)) {\n            log.info(\"用户名为null，非法用户\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        return chain.filter(exchange);\n    }\n\n    @Override\n    public int getOrder() {\n        return 0;\n    }\n}\n\n```\n\n# SpringCloud config分布式配置中心\n\n- 解决分布式系统中配置散乱的不好维护的问题，统一由配置中心管理，所有的应用都从配置中心去获取参数设置\n\n- 官网https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/\n\n- 作用\n\n  - 集中管理配置文件\n  - 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n  - 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n  - 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n  - 将配置信息以REST接口的形式暴露，post、curl访问刷新均可....\n\n- 配置文件修改后，需要运维人员发送Post请求刷新3355(curl -X POST \"http://localhost:3355/actuator/refresh\")，但是每次刷新的都是一个configClient，如果有一万台configClient，那运维不得疯？怎么处理呢？详见CommandBus的使用\n\n  \n\n### configServer的构建\n\n- pom\n\n```markdown\n  <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n      <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n```\n\n\n\n- 改yaml\n\n```yaml\nserver:\n  port: 3344\nspring:\n  application:\n    name: cloud-config-center\n  cloud:\n    config:\n      server:\n        git:\n          uri:  https://github.com/mk-passby/sprincloud-config.git #填写你自己的github路径\n          # 搜索路径\n          search-paths:\n            - springcloud-config\n      # 读取分支\n      label: master\neureka:\n  client:\n    service-url:\n      defaultZone:  http://localhost:7001/eureka\n\nrabbitmq:\n  host: localhost\n  port: 5672\n  username: guest\n  password: guest\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: 'bus-refresh'\n```\n\n- 启动类\n\n\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.config.server.EnableConfigServer;\n\n/**\n * @program: springcloud2020\n * @description: 配置中心3344\n * @author: mk_passby\n * @create: 2020-08-04 22:48\n **/\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigCenterMain3344 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigCenterMain3344.class, args);\n    }\n}\n\n```\n\n\n\n### configClient的构建\n\n- pom\n\n```markdown\n <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-config</artifactId>\n    </dependency>\n      <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n\n```\n\n- yarm\n\n```yaml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称，读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n```\n\n- 启动类\n\n```java\npackage com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class ConfigClientMain3355 {\n    public static void main(String[] args) {\n            SpringApplication.run( ConfigClientMain3355.class,args);\n        }\n}\n \n \n\n```\n\n\n\n\n\n- 业务类\n\n```java\npackage com.atguigu.springcloud.Controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RefreshScope\n@RestController//自动刷新\npublic class ConfigClientController {\n\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/configInfo\")\n    public String getConfigInfo(){\n        return configInfo;\n    }\n}\n```\n\n\n\n# SpringCloud Bus 消息总线\n\n- Spring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新\n![](./springcloud总结/39.bmp)\n- Bus支持两种消息代理：RabbitMQ和Kafka\n- SpringCloudBus可以管理和传播分布式系统之间的消息，可用于广播状态更新，事件推送等，也可以作为微服务之前的通讯通道\n- 为什么称为总线：<img src=\"./springcloud总结/40.bmp\"  />\n\n- 一次修改，广播通知，处处生效\n\n## 构建\n\n- pom\n\n```markdown\n<dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n```\n\n- yaml\n\n```yaml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    config:\n      label: master\n      name: config\n      profile: dev\n      uri: http://localhost:3344\n\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n \n```\n\n## 通知总结\n\n\n\n\n\n![](springcloud总结/41.bmp)\n![](springcloud总结/42.bmp)\n\n- 利用消息总线触发一个服务端ConfigServer的/bus/refresh端点,而刷新所有客户端的配置\n\n","tags":["springcloud"]},{"title":"springcloud项目搭建","url":"/2020/08/22/框架系列/springcloud/SpringCloud项目搭建/","content":"\n# SpringCloud:\n\n\n\n## 0,SpringCloud升级,部分组件停用:\n\n1,Eureka停用,可以使用zk作为服务注册中心\n\n2,服务调用,Ribbon准备停更,代替为LoadBalance\n\n3,Feign改为OpenFeign\n\n4,Hystrix停更,改为resilence4j\n\n​\t\t或者阿里巴巴的sentienl\n\n5.Zuul改为gateway\n\n6,服务配置Config改为  Nacos\n\n7,服务总线Bus改为Nacos\n\n\n\n\n\n# 环境搭建:\n\n\n\n## 1,创建父工程,pom依赖\n\n```java\n....\n```\n\n## 2,创建子模块,pay模块\n\n![](SpringCloud项目搭建\\sc的3.png)\n\n### 1,子模块名字:\n\n​\t\tcloud_pay_8001\n\n### 2,pom依赖\n\n### 3,创建application.yml\n\n```yml\nserver:\n\tport: 8001   \nspring:\n\tapplication:\n\t\tname: cloud-payment-service\n\tdatasource:\n    # 当前数据源操作类型\n    type: com.alibaba.druid.pool.DruidDataSource\n    # mysql驱动类\n    driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=\n            UTF-8&useSSL=false&serverTimezone=GMT%2B8\t\t\t\t\t\t\t\t\n    username: root\n    password: root\nmybatis:\t\t\t\n    mapper-locations: classpath*:mapper/*.xml\n   \ttype-aliases-package: com.eiletxie.springcloud.entities\n   \t\t\t它一般对应我们的实体类所在的包，这个时候会自动取对应包中不包括包名的简单类名作为包括包名的别名。多个package之间可以用逗号或者分号等来进行分隔（value的值一定要是包的全）\n```\n\n### 4,主启动类    \n\n​\t\t....\n\n### 5,业务类\n\n#### 1,sql\n\n![](SpringCloud项目搭建\\sc的4.png)\n\n#### \t2,实体类\n\n![](SpringCloud项目搭建\\sc的5.png)\n\n#### 3,.entity类\n\n![](SpringCloud项目搭建\\sc的6.png)\n\n#### 4,dao层:\n\n![](SpringCloud项目搭建\\sc的7.png)\n\n#### 5,mapper配置文件类\n\n​\t\t\t\t**在resource下,创建mapper/PayMapper.xml**\n\n![](SpringCloud项目搭建\\sc的8.png)\n\n#### 6,写service和serviceImpl\n\n![](SpringCloud项目搭建\\sc的9.png)\n\n![sc的9](SpringCloud项目搭建\\sc的10.png)\n\n#### 7,controller\n\n![](SpringCloud项目搭建\\sc的11.png)\n\n![](SpringCloud项目搭建\\sc的12.png)\n\n\n\n\n\n\n\n## 3,热部署:\n\n![](SpringCloud项目搭建\\sc的13.png)\n\n![](SpringCloud项目搭建\\sc的14.png)\n\n.....\n\n.....\n\n....\n\n\n\n\n\n## 4,order模块\n\n![](SpringCloud项目搭建\\sc的3.png)\n\n### **1,pom**\t\t\n\n### **2,yml配置文件**\n\n![](SpringCloud项目搭建\\order模块1.png)\n\n### **3,主启动类**\n\n### **4.复制pay模块的实体类,entity类**\n\n### **5,写controller类**\n\n​\t\t因为这里是消费者类,主要是消费,那么就没有service和dao,需要调用pay模块的方法\n\n​\t\t并且这里还没有微服务的远程调用,那么如果要调用另外一个模块,则需要使用基本的api调用\n\n使用RestTemplate调用pay模块,\n\n​\t![](SpringCloud项目搭建\\order模块2.png)\n\n![](SpringCloud项目搭建\\order模块3.png)\n\n\n\n​\t将restTemplate注入到容器\n\n![](SpringCloud项目搭建\\order模块4.png)\n\n编写controller:\n\n![](SpringCloud项目搭建\\order模块5.png)\n\n\n\n## 5,重构,\n\n新建一个模块,将重复代码抽取到一个公共模块中\n\n### 1,创建commons模块\n\n### 2,抽取公共pom\n\n![](SpringCloud项目搭建\\commons模块.png)\n\n### 3,entity和实体类放入commons中\n\n![](SpringCloud项目搭建\\commons模块2.png)\n\n### 4,使用mavne,将commone模块打包(install),\n\n​\t\t其他模块引入commons\n\n\n\n\n\n\n\n# 2,服务注册与发现\n\n\n\n## 6,Eureka:\n\n前面我们没有服务注册中心,也可以服务间调用,为什么还要服务注册?\n\n当服务很多时,单靠代码手动管理是很麻烦的,需要一个公共组件,统一管理多服务,包括服务是否正常运行,等\n\nEureka用于**==服务注册==**,目前官网**已经停止更新**\n\n​\t![](SpringCloud项目搭建\\Eureka的1.png)\n\n\n\n![](SpringCloud项目搭建\\Eureka的2.png)\n\n![](SpringCloud项目搭建\\Eureka的3.png)\n\n\n\n ![](SpringCloud项目搭建\\Eureka的4.png)\n\n\n\n### **单机版eureka:**\n\n#### **1,创建项目cloud_eureka_server_7001**\n\n#### **2,引入pom依赖**\n\n​\t\teurka最新的依赖变了\n\n![](SpringCloud项目搭建\\Eureka的5.png)\n\n#### 3,配置文件:\n\n![](SpringCloud项目搭建\\Eureka的6.png)\n\n#### 4,主启动类\t\n\n![](SpringCloud项目搭建\\Eureka的7.png)\n\n#### **5,此时就可以启动当前项目了**\n\n#### **6,其他服务注册到eureka:**\n\n比如此时pay模块加入eureka:\n\n##### 1.主启动类上,加注解,表示当前是eureka客户端\n\n![](SpringCloud项目搭建\\Eureka的10.png)\n\n##### 2,修改pom,引入\n\n![](SpringCloud项目搭建\\Eureka的8.png)\n\n##### 3,修改配置文件:\n\n![](SpringCloud项目搭建\\Eureka的9.png)\n\n##### 4,pay模块重启,就可以注册到eureka中了\n\n\n\n\n\n**==order模块的注册是一样的==**\n\n\n\n\n\n### 集群版eureka:\n\n#### 集群原理:\n\n![](SpringCloud项目搭建\\Eureka的11.png)\n\n ```java\n1,就是pay模块启动时,注册自己,并且自身信息也放入eureka\n2.order模块,首先也注册自己,放入信息,当要调用pay时,先从eureka拿到pay的调用地址\n3.通过HttpClient调用\n \t并且还会缓存一份到本地,每30秒更新一次\n ```\n\n![](SpringCloud项目搭建\\Eureka的12.png)\n\n**集群构建原理:**\n\n​\t\t互相注册\n\n![](SpringCloud项目搭建\\Eureka的13.png)\n\n\n\n#### **构建新erueka项目**\n\n名字:cloud_eureka_server_7002\n\n##### 1,pom文件:\n\n​\t\t粘贴7001的即可\n\n##### 2,配置文件:\n\n​\t\t在写配置文件前,修改一下主机的hosts文件\n\n![](SpringCloud项目搭建\\Eureka的14.png)\n\n首先修改之前的7001的eureka项目,因为多个eureka需要互相注册\n\n![](SpringCloud项目搭建\\Eureka的15.png)\n\n然后修改7002\n\n​\t\t\t**7002也是一样的,只不过端口和地址改一下**\n\n##### 3,主启动类:\n\n​\t\t复制7001的即可\n\n##### 4,然后启动7001,7002即可\n\n*![](SpringCloud项目搭建\\Eureka的16.png)*\n\n\n\n\n\n#### 将pay,order模块注册到eureka集群中:\n\n##### 1,只需要修改配置文件即可:\n\n![](SpringCloud项目搭建\\Eureka的17.png)\n\n##### 2,两个模块都修改上面的都一样即可\n\n​\t\t\t然后启动两个模块\n\n​\t\t\t要先启动7001,7002,然后是pay模块8001,然后是order(80)\n\n\n\n### 3,将pay模块也配置为集群模式:\n\n#### 0,创建新模块,8002\n\n​\t名称: cloud_pay_8002\n\n#### 1,pom文件,复制8001的\n\n#### 2,pom文件复制8001的\n\n#### 3,配置文件复制8001的\n\n​\t\t端口修改一下,改为8002\n\n​\t\t服务名称不用改,用一样的\n\n#### 4.主启动类,复制8001的\n\n#### 5,mapper,service,controller都复制一份\n\n​\t\t然后就启动服务即可\n\n​\t\t此时访问order模块,发现并没有负载均衡到两个pay,模块中,而是只访问8001\n\n​\t\t虽然我们是使用RestTemplate访问的微服务,但是也可以负载均衡的\n\n​\t\t![](SpringCloud项目搭建\\Eureka的18.png)\n\n**注意这样还不可以,需要让RestTemplate开启负载均衡注解,还可以指定负载均衡算法,默认轮询**\n\n![](SpringCloud项目搭建\\Eureka的19.png)\n\n\n\n\n\n\n\n### 4,修改服务主机名和ip在eureka的web上显示\n\n比如修改pay模块\n\n#### 1,修改配置文件:\n\n![](SpringCloud项目搭建\\Eureka的20.png)\n\n\n\n\n\n### 5,eureka服务发现:\n\n![](SpringCloud项目搭建\\Eureka的21.png)\n\n以pay模块为例\n\n#### 1,首先添加一个注解,在controller中\n\n![](SpringCloud项目搭建\\Eureka的22.png)\n\n![](SpringCloud项目搭建\\Eureka的23.png)\n\n\n\n#### 2,在主启动类上添加一个注解\n\n![](SpringCloud项目搭建\\Eureka的24.png)\n\n**然后重启8001.访问/payment/discover**y\n\n\n\n\n\n### 6,Eureka自我保护:\n\n![](SpringCloud项目搭建\\Eureka的26.png)\n\n![](SpringCloud项目搭建\\Eureka的27.png)\n\n![](SpringCloud项目搭建\\Eureka的25.png)\n\n\n\n![](SpringCloud项目搭建\\Eureka的28.png)\n\n\n\n**eureka服务端配置:**\n\n![](SpringCloud项目搭建\\Eureka的29.png)\n\n![](SpringCloud项目搭建\\Eureka的30.png)\n\n​\t\t\t**设置接受心跳时间间隔**\n\n\n\n**客户端(比如pay模块):**\n\n![](SpringCloud项目搭建\\Eureka的31.png)\n\n\n\n\n\n**此时启动erueka和pay.此时如果直接关闭了pay,那么erueka会直接删除其注册信息**\n\n\n\n\n\n\n\n\n\n## 7,Zookeeper服务注册与发现:\n\n### 1,启动zk,到linux上\n\n\n\n### 2,创建新的pay模块,\n\n单独用于注册到zk中  \n\n名字 : cloud_pay_8003\n\n#### 1,pom依赖\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\zookeeper的3.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\zookeeper的1.png)\n\n#### 4,controller\n\n![](SpringCloud项目搭建\\zookeeper的2.png)\n\n#### 5,然后就可以启动\n\n**此时启动,会报错,因为jar包与我们的zk版本不匹配**\n\n解决:\n\t\t修改pom文件,改为与我们zk版本匹配的jar包\n\n![](SpringCloud项目搭建\\zookeeper的4.png)\n\n**此时8003就注册到zk中了**\n\n```java\n我们在zk上注册的node是临时节点,当我们的服务一定时间内没有发送心跳\n  \t那么zk就会`将这个服务的node删除了\n```\n\n\n\n**这里测试,就不写service与dao什么的了**\n\n\n\n\n\n\n\n\n\n### 3,创建order消费模块注册到zk\n\n#### 1,创建项目\n\n名字: cloud_order_zk_80\n\n#### 2,pom\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\zookeeper的5.png)\n\n#### 4主启动类:\n\n![](SpringCloud项目搭建\\zookeeper的1.png)\n\n#### 5,RestTemolate\n\n![注意,这里使用RestTemolate,要先注册它](SpringCloud项目搭建\\zookeeper的6.png)\n\n#### 6,controller\n\n![](SpringCloud项目搭建\\zookeeper的7.png)\n\n**然后启动即可注册到zk**\n\n#### 8,集群版zk注册:\n\n只需要修改配置文件:\n\n![](SpringCloud项目搭建\\zookeeper的5.png)\n\n这个connect-string指定多个zk地址即可\n\nconnect-string: 1.2.3.4,2.3.4.5\n\n#### \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 8,Consul:\n\n![](SpringCloud项目搭建\\consul的1.png)\n\n\n\n![](SpringCloud项目搭建\\consul的2.png)\n\n\n\n\n\n### 1,按照consul\n\n需要下载一个安装包\n\n![](SpringCloud项目搭建\\consul的3.png)\n\n启动是一个命令行界面,需要输入consul agen-dev启动\n\n\n\n### 2,创建新的pay模块,8006\n\n#### 1,项目名字\n\ncloud_consule_pay_8006\n\n#### 2,pom依赖\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\consul的4.png)\n\n#### 4,主启动类\n\n![](SpringCloud项目搭建\\consul的5.png)\n\n#### 5,controller\n\n![](SpringCloud项目搭建\\consul的6.png)\n\n#### 6,启动服务\n\n\n\n#### \n\n\n\n### 3,创建新order模块\n\ncloud-consul-order-80\n\n\n\n#### 1,pom文件\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\consul的7.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\consul的5.png)\n\n#### 4,RestTemplate注册\n\n配置类注册\n\n#### 5,controller\n\n![](SpringCloud项目搭建\\consul的8.png)\n\n#### 6,启动服务,测试\n\n\n\n\n\n\n\n## 9,三个注册中心的异同:\n\n![](SpringCloud项目搭建\\consul的9.png)\n\n![](SpringCloud项目搭建\\consul的10.png)\n\n![](SpringCloud项目搭建\\consul的11.png)\n\n\n\n\n\n\n\n# 3,服务调用\n\n\n\n## 10,Ribbon负载均衡:\n\n![](SpringCloud项目搭建\\Ribbon.png)\n\n**Ribbon目前也进入维护,基本上不准备更新了**\n\n![](SpringCloud项目搭建\\Ribbon的2.png)\n\n**进程内LB(本地负载均衡)**\n\n![](SpringCloud项目搭建\\Ribbon的5.png)\n\n\n\n\n\n**集中式LB(服务端负载均衡)**\n\n![](SpringCloud项目搭建\\Ribbon的4.png)\n\n\n\n\n\n\n\n**区别**\n\n![](SpringCloud项目搭建\\Ribbon的3.png)\n\n\n\n**Ribbon就是负载均衡+RestTemplate**\n\n![](SpringCloud项目搭建\\Ribbon的6.png)\n\n\n\n![](SpringCloud项目搭建\\Ribbon的7.png)\n\n\n\n![](SpringCloud项目搭建\\Ribbon的8.png)\n\n\n\n\n\n\n\n### 使用Ribbon:\n\n#### 1,默认我们使用eureka的新版本时,它默认集成了ribbon:\n\n![](SpringCloud项目搭建\\Ribbon的9.png)\n\n**==这个starter中集成了reibbon了==**\n\n\n\n#### 2,我们也可以手动引入ribbon\n\n**放到order模块中,因为只有order访问pay时需要负载均衡**\n\n![](SpringCloud项目搭建\\Ribbon的10.png)\n\n\n\n#### 3,RestTemplate类:\n\n![](SpringCloud项目搭建\\Ribbon的11.png)\n\n![](SpringCloud项目搭建\\Ribbon的12.png)\n\n```java\nRestTemplate的:\n\t\txxxForObject()方法,返回的是响应体中的数据\n    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)\n```\n\n\n\n\n\n#### Ribbon常用负载均衡算法:\n\n**IRule接口,Riboon使用该接口,根据特定算法从所有服务中,选择一个服务,**\n\n**Rule接口有7个实现类,每个实现类代表一个负载均衡算法**\n\n![](SpringCloud项目搭建\\Ribbon的14.png)\n\n\n\n\n\n\n\n#### 使用Ribbon:\n\n**==这里使用eureka的那一套服务==**\n\n![](SpringCloud项目搭建\\Ribbon的15.png)\n\n**==也就是不能放在主启动类所在的包及子包下==**\n\n##### 1,修改order模块\n\n##### 2,额外创建一个包\n\n![](SpringCloud项目搭建\\Ribbon的16.png)\n\n##### 3,创建配置类,指定负载均衡算法\n\n![](SpringCloud项目搭建\\Ribbon的17.png)\n\n##### 4,在主启动类上加一个注解\n\n![](SpringCloud项目搭建\\Ribbon的18.png)\n\n**表示,访问CLOUD_pAYMENT_SERVICE的服务时,使用我们自定义的负载均衡算法**\n\n\n\n\n\n\n\n#### 自定义负载均衡算法:\n\n##### 1,ribbon的轮询算法原理\n\n![](SpringCloud项目搭建\\Ribbon的19.png)\n\n![](SpringCloud项目搭建\\Ribbon的21.png)\n\n\n\n##### 2,自定义负载均衡算法:\n\n**1,给**pay模块(8001,8002),的controller方法添加一个方法,返回当前节点端口\n\n![](SpringCloud项目搭建\\Ribbon的23.png)\n\n![](SpringCloud项目搭建\\Ribbon的22.png)\n\n**2,修改order模块**\n\n去掉@LoadBalanced\n\n![](SpringCloud项目搭建\\Ribbon的24.png)\n\n\n\n##### 3,自定义接口\n\n![](SpringCloud项目搭建\\Ribbon的29.png)\n\n​\t\t\t\t\t==具体的算法在实现类中实现==\n\n##### 4,接口实现类\n\n![](SpringCloud项目搭建\\Ribbon的25.png)\n\n![](SpringCloud项目搭建\\Ribbon的26.png)\n\n\n\n##### 5,修改controller:\n\n![](SpringCloud项目搭建\\Ribbon的27.png)\n\n![](SpringCloud项目搭建\\Ribbon的28.png)\n\n\n\n##### 6,启动服务,测试即可\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11,OpenFeign\n\n![](SpringCloud项目搭建\\Feign的1.png)\n\n**是一个声明式的web客户端,只需要创建一个接口,添加注解即可完成微服务之间的调用**\n\n\n\n![](SpringCloud项目搭建\\Feign的2.png)\n\n==就是A要调用B,Feign就是在A中创建一个一模一样的B对外提供服务的的接口,我们调用这个接口,就可以服务到B==\n\n\n\n### **Feign与OpenFeign区别**\n\n![](SpringCloud项目搭建\\Feign的3.png)\n\n\n\n\n\n### 使用OpenFeign\n\n```java\n之前的服务间调用,我们使用的是ribbon+RestTemplate\n\t\t现在改为使用Feign\n```\n\n#### 1,新建一个order项目,用于feign测试\n\n名字cloud_order_feign-80\n\n#### 2,pom文件\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\Feign的4.png)\n\n#### 4,主启动类\n\n![](SpringCloud项目搭建\\Feign的5.png)\n\n#### 5,fegin需要调用的其他的服务的接口\n\n![](SpringCloud项目搭建\\Feign的6.png)\n\n#### 6,controller\n\n![](SpringCloud项目搭建\\Feign的7.png)\n\n#### 7测试:\n\n启动两个erueka(7001,7002)\n\n启动两个pay(8001,8002)\n\n启动当前的order模块\n\n\n\n**Feign默认使用ribbon实现负载均衡**\n\n\n\n\n\n### OpenFeign超时机制:\n\n==OpenFeign默认等待时间是1秒,超过1秒,直接报错==\n\n#### 1,设置超时时间,修改配置文件:\n\n**因为OpenFeign的底层是ribbon进行负载均衡,所以它的超时时间是由ribbon控制**\n\n![](SpringCloud项目搭建\\Feign的8.png)\n\n\n\n\n\n### OpenFeign日志:\n\n![](SpringCloud项目搭建\\Feign的9.png)\n\n\n\n**OpenFeign的日志级别有:**\n![](SpringCloud项目搭建\\Feign的10.png)\n\n\n\n\n\n#### \t1,使用OpenFeign的日志:\n\n**实现在配置类中添加OpenFeign的日志类**\n\n![](SpringCloud项目搭建\\Feign的11.png)\n\n#### 2,为指定类设置日志级别:\n\n![](SpringCloud项目搭建\\Feign的13.png)\n\n**配置文件中:**\n\n![](SpringCloud项目搭建\\Feign的12.png)\n\n\n\n#### \t3,启动服务即可\n\n\n\n# 4,服务降级:\n\n\n\n## 12,Hystrix服务降级\n\n![](SpringCloud项目搭建\\Hystrix的2.png)\n\n\n\n![](SpringCloud项目搭建\\Hystrix的3.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\Hystrix的4.png)\n\n\n\n\n\n\n\n### hystrix中的重要概念:\n\n#### 1,服务降级\n\n**比如当某个服务繁忙,不能让客户端的请求一直等待,应该立刻返回给客户端一个备选方案**\n\n\n\n#### 2,服务熔断\n\n**当某个服务出现问题,卡死了,不能让用户一直等待,需要关闭所有对此服务的访问**\n\n​\t\t\t**然后调用服务降级**\n\n\n\n#### 3,服务限流\n\n**限流,比如秒杀场景,不能访问用户瞬间都访问服务器,限制一次只可以有多少请求**\n\n\n\n\n\n### 使用hystrix,服务降级:\n\n#### 1,创建带降级机制的pay模块 :\n\n名字: cloud-hystrix-pay-8007\n\n##### 2,pom文件\n\n##### 3,配置文件\n\n![](SpringCloud项目搭建\\Hystrix的5.png)\n\n##### 4,主启动类\n\n![](SpringCloud项目搭建\\Hystrix的8.png)\n\n##### 5,service\n\n![](SpringCloud项目搭建\\Hystrix的6.png)\n\n##### 6controller\n\n![](SpringCloud项目搭建\\Hystrix的7.png)\n\n##### 7,先测试:\n\n```java\n此时使用压测工具,并发20000个请求,请求会延迟的那个方法,\n\t\t压测中,发现,另外一个方法并没有被压测,但是我们访问它时,却需要等待\n\t\t这就是因为被压测的方法它占用了服务器大部分资源,导致其他请求也变慢了\n```\n\n\n\n##### 8,先不加入hystrix,\n\n\n\n#### 2,创建带降级的order模块:\n\n##### 1,名字:  cloud-hystrix-order-80\n\n##### 2,pom\n\n##### 3,配置文件\n\n![](SpringCloud项目搭建\\Hystrix的9.png)\n\n##### 4,主启动类\n\n![](SpringCloud项目搭建\\Hystrix的11.png)\n\n##### 5,远程调用pay模块的接口:\n\n![](SpringCloud项目搭建\\Hystrix的12.png)\n\n##### 6,controller:\n\n![](SpringCloud项目搭建\\Hystrix的13.png)\n\n##### 7,测试\n\n​\t\t\t启动order模块,访问pay\n\n​\t\t\t再次压测2万并发,发现order访问也变慢了\n\n![](SpringCloud项目搭建\\Hystrix的14.png)\n\n\n\n**解决:**\n\n![](SpringCloud项目搭建\\Hystrix的15.png)\n\n##### ![](SpringCloud项目搭建\\Hystrix的16.png)\n\n\n\n\n\n\n\n#### 3,配置服务降级:\n\n##### 1,修改pay模块\n\n###### 1,为service的指定方法(会延迟的方法)添加@HystrixCommand注解\n\n![](SpringCloud项目搭建\\Hystrix的17.png)\n\n###### 2,主启动类上,添加激活hystrix的注解\n\n![](SpringCloud项目搭建\\Hystrix的18.png)\n\n###### 3,触发异常\n\n![](SpringCloud项目搭建\\Hystrix的19.png)\n\n![](SpringCloud项目搭建\\Hystrix的20.png)**可以看到,也触发了降级**\n\n\n\n##### 2,修改order模块,进行服务降级\n\n一般服务降级,都是放在客户端(order模块),\n\n![](SpringCloud项目搭建\\Hystrix的21.png)\n\n###### 1,修改配置文件:\n\n![](SpringCloud项目搭建\\Hystrix的22.png)\n\n###### **2,主启动类添加直接,启用hystrix:**\n\n![](SpringCloud项目搭建\\Hystrix的23.png)\n\n​\t\n\n###### 3,修改controller,添加降级方法什么的\n\n![](SpringCloud项目搭建\\Hystrix的24.png)\n\n\n\n###### 4,测试\n\n启动pay模块,order模块,\n\n**注意:,这里pay模块和order模块都开启了服务降级**\n\n​\t\t\t但是order这里,设置了1.5秒就降级,所以访问时,一定会降级\n\n \n\n##### 4,重构:\n\n**上面出现的问题:**\n\t\t1,降级方法与业务方法写在了一块,耦合度高\n\n​\t\t2.每个业务方法都写了一个降级方法,重复代码多\n\n##### **解决重复代码的问题**:\n\n**配置一个全局的降级方法,所有方法都可以走这个降级方法,至于某些特殊创建,再单独创建方法**\n\n###### 1,创建一个全局方法\n\n![](SpringCloud项目搭建\\Hystrix的26.png)\n\n###### 2,使用注解指定其为全局降级方法(默认降级方法)\n\n![](SpringCloud项目搭建\\Hystrix的27.png)\n\n![](SpringCloud项目搭建\\Hystrix的25.png)\n\n\n\n###### 3,业务方法使用默认降级方法:\n\n![](SpringCloud项目搭建\\Hystrix的28.png)\n\n\n\n###### 4,测试:\n\n![](SpringCloud项目搭建\\Hystrix的29.png)\n\n\n\n\n\n\n\n\n\n\n\n##### 解决代码耦合度的问题:\n\n修改order模块,这里开始,pay模块就不服务降级了,服务降级写在order模块即可\n\n###### 1,Payservice接口是远程调用pay模块的,我们这里创建一个类实现service接口,在实现类中统一处理异常\n\n![](SpringCloud项目搭建\\Hystrix的30.png)\n\n###### 2,修改配置文件:添加:\n\n![](SpringCloud项目搭建\\Hystrix的31.png)\n\n###### \t3,让PayService的实现类生效:\n\n![](SpringCloud项目搭建\\Hystrix的32.png)\n\n```java\n它的运行逻辑是:\n\t\t当请求过来,首先还是通过Feign远程调用pay模块对应的方法\n    但是如果pay模块报错,调用失败,那么就会调用PayMentFalbackService类的\n    当前同名的方法,作为降级方法\n```\n\n###### 4,启动测试\n\n启动order和pay正常访问--ok\n\n==此时将pay服务关闭,order再次访问==\n\n![](SpringCloud项目搭建\\Hystrix的33.png)\n\n可以看到,并没有报500错误,而是降级访问==实现类==的同名方法\n\n这样,即使服务器挂了,用户要不要一直等待,或者报错\n\n问题:\n\n​\t\t**这样虽然解决了代码耦合度问题,但是又出现了过多重复代码的问题,每个方法都有一个降级方法**\n\n\n\n\n\n\n\n### 使用服务熔断:\n\n![](SpringCloud项目搭建\\Hystrix的34.png)\n\n**比如并发达到1000,我们就拒绝其他用户访问,在有用户访问,就访问降级方法**\n\n\n\n![](SpringCloud项目搭建\\Hystrix的35.png)\n\n\n\n#### 1,修改前面的pay模块\n\n##### **1,修改Payservice接口,添加服务熔断相关的方法:**\n\n![](SpringCloud项目搭建\\Hystrix的37.png)\n\n这里属性整体意思是:\n\t\t\t10秒之内(窗口,会移动),如果并发==超过==10个,或者10个并发中,失败了6个,就开启熔断器\n\n![image-20200414152637247](SpringCloud项目搭建\\Hystrix的43.png)\n\n\n\nIdUtil是Hutool包下的类,这个Hutool就是整合了所有的常用方法,比如UUID,反射,IO流等工具方法什么的都整合了\n\n\n\n\n\n![](SpringCloud项目搭建\\Hystrix的36.png)\n\n```java\n断路器的打开和关闭,是按照一下5步决定的\n  \t1,并发此时是否达到我们指定的阈值\n  \t2,错误百分比,比如我们配置了60%,那么如果并发请求中,10次有6次是失败的,就开启断路器\n  \t3,上面的条件符合,断路器改变状态为open(开启)\n  \t4,这个服务的断路器开启,所有请求无法访问\n  \t5,在我们的时间窗口期,期间,尝试让一些请求通过(半开状态),如果请求还是失败,证明断路器还是开启状态,服务没有恢复\n  \t\t如果请求成功了,证明服务已经恢复,断路器状态变为close关闭状态\n```\n\n\n\n##### 2,修改controller\n\n添加一个测试方法;\n\n![](SpringCloud项目搭建\\Hystrix的39.png)\n\n\n\n##### 3,测试:\n\n启动pay,order模块\n\n==多次访问,并且错误率超过60%:==\n\n![](SpringCloud项目搭建\\Hystrix的40.png)\n\n此时服务熔断,此时即使访问正确的也会报错:\n\n![](SpringCloud项目搭建\\Hystrix的41.png)\n\n**但是,当过了几秒后,又恢复了**\n\n​\t\t\t\t因为在10秒窗口期内,它自己会尝试接收部分请求,发现服务可以正常调用,慢慢的当错误率低于60%,取消熔断\n\n\n\n\n\n\n\n\n\n\n\n### Hystrix所有可配置的属性:\n\n**全部在这个方法中记录,以成员变量的形式记录,**\n\n​\t\t以后需要什么属性,查看这个类即可\n\n![](SpringCloud项目搭建\\Hystrix的38.png)\n\n\n\n\n\n\n\n\n\n### 总结:\n\n![](SpringCloud项目搭建\\Hystrix的42.png)\n\n**==当断路器开启后:==**\n\n​\t![](SpringCloud项目搭建\\Hystrix的44.png)\n\n\n\n**==其他参数:==**\n\n![](SpringCloud项目搭建\\Hystrix的45.png)\n\n![](SpringCloud项目搭建\\Hystrix的46.png)\n\n![](SpringCloud项目搭建\\Hystrix的47.png)\n\n![](SpringCloud项目搭建\\Hystrix的48.png)\n\n![](SpringCloud项目搭建\\Hystrix的49.png)\n\n\n\n**熔断整体流程:**\n\n```java\n1请求进来,首先查询缓存,如果缓存有,直接返回\n  \t如果缓存没有,--->2\n2,查看断路器是否开启,如果开启的,Hystrix直接将请求转发到降级返回,然后返回\n  \t如果断路器是关闭的,\n\t\t\t\t判断线程池等资源是否已经满了,如果已经满了\n  \t\t\t\t\t也会走降级方法\n  \t\t\t如果资源没有满,判断我们使用的什么类型的Hystrix,决定调用构造方法还是run方法\n        然后处理请求\n        然后Hystrix将本次请求的结果信息汇报给断路器,因为断路器此时可能是开启的\n          \t\t\t(因为断路器开启也是可以接收请求的)\n        \t\t断路器收到信息,判断是否符合开启或关闭断路器的条件,\n\t\t\t\t如果本次请求处理失败,又会进入降级方法\n        如果处理成功,判断处理是否超时,如果超时了,也进入降级方法\n        最后,没有超时,则本次请求处理成功,将结果返回给controller\n         \n \n```\n\n\n\n\n\n\n\n### Hystrix服务监控:\n\n#### HystrixDashboard\n\n![](SpringCloud项目搭建\\Hystrix的51.png)\n\n#### 2,使用HystrixDashboard:\n\n##### 1,创建项目:\n\n名字: cloud_hystrixdashboard_9001\n\n##### 2,pom文件\n\n##### 3,配置文件\n\n![](SpringCloud项目搭建\\Hystrix的52.png)\n\n##### 4,主启动类\n\n![](SpringCloud项目搭建\\Hystrix的53.png)\n\n##### 5,修改所有pay模块(8001,8002,8003...)\n\n**他们都添加一个pom依赖:**\n\n![](SpringCloud项目搭建\\Hystrix的54.png)\n\n之前的pom文件中都添加过了,==这个是springboot的监控组件==\n\n##### 6,启动9001即可\n\n​\t\t\t访问: **localhost:9001/hystrix**\n\n##### 7,注意,此时仅仅是可以访问HystrixDashboard,并不代表已经监控了8001,8002\n\n​\t\t\t\t\t\t\t如果要监控,还需要配置:(8001为例)\n\n==8001的主启动类添加:==\n\n![](SpringCloud项目搭建\\Hystrix的55.png)\n\n**其他8002,8003都是一样的**\n\n##### 8,到此,可以启动服务\n\n启动7001,8001,9001\n\n**然后在web界面,指定9001要监控8001:**\n\n##### ![](SpringCloud项目搭建\\Hystrix的56.png)\n\n\n\n![](SpringCloud项目搭建\\Hystrix的57.png)\n\n![](SpringCloud项目搭建\\Hystrix的59.png)\n\n![](SpringCloud项目搭建\\Hystrix的58.png)\n\n![](SpringCloud项目搭建\\Hystrix的60.png)\n\n![](SpringCloud项目搭建\\Hystrix的61.png)\n\n![](SpringCloud项目搭建\\Hystrix的62.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 5,服务网关:\n\nzuul停更了,\n\n## 13,GateWay\n\n\n\n![](SpringCloud项目搭建\\gateway的1.png)\n\n![](SpringCloud项目搭建\\gateway的2.png)\n\n**gateway之所以性能号,因为底层使用WebFlux,而webFlux底层使用netty通信(NIO)**\n\n\n\n![](SpringCloud项目搭建\\gateway的3.png)\n\n\n\n### GateWay的特性:\n\n![](SpringCloud项目搭建\\gateway的4.png)\n\n\n\n### GateWay与zuul的区别:\n\n![](SpringCloud项目搭建\\gateway的5.png)\n\n\n\n### zuul1.x的模型:\n\n![](SpringCloud项目搭建\\gateway的6.png)\n\n![](SpringCloud项目搭建\\gateway的7.png)\n\n\n\n\n\n### 什么是webflux:\n\n**是一个非阻塞的web框架,类似springmvc这样的**\n\n![](SpringCloud项目搭建\\gateway的8.png)\n\n\n\n### GateWay的一些概念:\n\n#### 1,路由:\n\n![](SpringCloud项目搭建\\gateway的9.png)\n\n就是根据某些规则,将请求发送到指定服务上\n\n\n\n#### 2,断言:\n\n![](SpringCloud项目搭建\\gateway的10.png)\n\n就是判断,如果符合条件就是xxxx,反之yyyy\n\n\n\n#### 3,过滤:\n\n![](SpringCloud项目搭建\\gateway的11.png)\n\n​\t**路由前后,过滤请求**\n\n\n\n\n\n### GateWay的工作原理:\n\n![](SpringCloud项目搭建\\gateway的12.png)\n\n![](SpringCloud项目搭建\\gateway的13.png)\n\n\n\n\n\n### 使用GateWay:\n\n想要新建一个GateWay的项目\n\n名字: \tcloud_gateway_9527\n\n#### 1,pom\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\gateway的14.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\gateway的15.png)\n\n#### 4,针对pay模块,设置路由:\n\n![](SpringCloud项目搭建\\gateway的16.png)\n\n![](SpringCloud项目搭建\\gateway的18.png)\n\n**==修改GateWay模块(9527)的配置文件==:**\n\n![](SpringCloud项目搭建\\gateway的17.png)\n\n这里表示,\n\n​\t\t\t当访问localhost:9527/payment/get/1时,     \n\n​\t\t\t路由到localhost:8001/payment/get/1\n\n\n\n#### 5,开始测试\n\n**启动7001,8001,9527**\n\n```java\n如果启动GateWay报错\n  \t可能是GateWay模块引入了web和监控的starter依赖,需要移除\n```\n\n访问:\n\n​\t\tlocalhost:9527/payment/get/1\n\n![](SpringCloud项目搭建\\gateway的19.png)\n\n\n\n\n\n\n\n#### 6,GateWay的网关配置,\n\n​\t\t**GateWay的网关配置,除了支持配置文件,还支持硬编码方式**\n\n#### 7使用硬编码配置GateWay:\n\n##### 创建配置类:\n\n![](SpringCloud项目搭建\\gateway的20.png)\n\n#### 8,然后重启服务即可\n\n \n\n\n\n### 重构:\n\n上面的配置虽然首先了网关,但是是在配置文件中写死了要路由的地址\n\n现在需要修改,不指定地址,而是根据微服务名字进行路由,我们可以在注册中心获取某组微服务的地址\n\n需要:\n\n​\t\t1个eureka,2个pay模块\n\n#### 修改GateWay模块的配置文件:\n\n![](SpringCloud项目搭建\\gateway的21.png)\n\n\n\n#### 然后就可以启动微服务.测试\n\n\n\n\n\n\n\n### Pridicate断言:\n\n![](SpringCloud项目搭建\\gateway的24.png)\n\n**我们之前在配置文件中配置了断言:**\n\n![](SpringCloud项目搭建\\gateway的22.png)\n\n**这个断言表示,如果外部访问路径是指定路径,就路由到指定微服务上**\n\n可以看到,这里有一个Path,这个是断言的一种,==断言的类型==:\n\n![](SpringCloud项目搭建\\gateway的23.png)\n\n\n\n```java\nAfter:\n\t\t可以指定,只有在指定时间后,才可以路由到指定微服务\n```\n\n![](SpringCloud项目搭建\\gateway的26.png)\n\n​\t\t\t\t这里表示,只有在==2020年的2月21的15点51分37秒==之后,访问==才可以路由==\n\n​\t\t\t\t在此之前的访问,都会报404\n\n如何获取当前时区?**\n\n![](SpringCloud项目搭建\\gateway的25.png)\n\n\n\n```java\nbefore:\n\t\t与after类似,他说在指定时间之前的才可以访问\nbetween:\n\t\t需要指定两个时间,在他们之间的时间才可以访问\n```\n\n![](SpringCloud项目搭建\\gateway的27.png)\n\n\n\n\n\n```java\ncookie:\n\t\t只有包含某些指定cookie(key,value),的请求才可以路由\n```\n\n![](SpringCloud项目搭建\\gateway的28.png)\n\n![](SpringCloud项目搭建\\gateway的29.png)\n\n\n\n```java\nHeader:\n\t\t只有包含指定请求头的请求,才可以路由\n```\n\n![](SpringCloud项目搭建\\gateway的31.png)\n\n![](SpringCloud项目搭建\\gateway的32.png)\n\n测试:\n![](SpringCloud项目搭建\\gateway的33.png)\n\n\n\n\n\n\n\n```java\nhost:\n\t\t只有指定主机的才可以访问,\n\t\t比如我们当前的网站的域名是www.aa.com\n    那么这里就可以设置,只有用户是www.aa.com的请求,才进行路由\n```\n\n![](SpringCloud项目搭建\\gateway的34.png)\n\n![gateway的34](SpringCloud项目搭建\\gateway的35.png)\n\n![](SpringCloud项目搭建\\gateway的36.png)\n\n![](SpringCloud项目搭建\\gateway的37.png)\n\n可以看到,如果带了域名访问,就可以,但是直接访问ip地址.就报错了\n\n\n\n\n\n\n\n```java\nmethod:\n\t\t只有指定请求才可以路由,比如get请求...\n```\n\n![](SpringCloud项目搭建\\gateway的38.png)\n\n```java\npath:\n\t\t只有访问指定路径,才进行路由\n     比如访问,/abc才路由\n```\n\n![](SpringCloud项目搭建\\gateway的39.png)\n\n\n\n```java\nQuery:\n\t\t必须带有请求参数才可以访问\n```\n\n![](SpringCloud项目搭建\\gateway的40.png)\n\n\n\n\n\n\n\n### Filter过滤器:\n\n![](SpringCloud项目搭建\\gateway的41.png)\n\n\n\n#### 生命周期:\n\n**在请求进入路由之前,和处理请求完成,再次到达路由之前**\n\n\n\n#### 种类:\n\n![](SpringCloud项目搭建\\gateway的42.png)\n\nGateWayFilter,单一的过滤器\n\n**与断言类似,比如闲置,请求头,只有特定的请求头才放行,反之就过滤**:\n\n![](SpringCloud项目搭建\\gateway的43.png)\n\nGlobalFilter,全局过滤器:\n\n\n\n\n\n#### **自定义过滤器:**\n\n实现两个接口\n\n![](SpringCloud项目搭建\\gateway的44.png)\n\n​\t**然后启动服务,即可,因为过滤器通过@COmponet已经加入到容器了**\n\n![](SpringCloud项目搭建\\gateway的46.png)\n\n![](SpringCloud项目搭建\\gateway的45.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 6,服务配置:\n\n## Spring Config分布式配置中心:\n\n==微服务面临的问题==\n\n```java\n可以看到,每个微服务都需要一个配置文件,并且,如果有几个微服务都需要连接数据库\n\t\t那么就需要配4次数据库相关配置,并且当数据库发生改动,那么需要同时修改4个微服务的配置文件才可以\n```\n\n所以有了springconfig配置中心\n\n![](SpringCloud项目搭建\\springconfig的1.png)\n\n![](SpringCloud项目搭建\\springconfig的2.png)\n\n![](SpringCloud项目搭建\\springconfig的3.png)\n\n![](SpringCloud项目搭建\\springconfig的4.png)\n\n\n\n\n\n### 使用配置中心:\n\n#### 0,使用github作为配置中心的仓库:\n\n**初始化git环境:**\n\n![](SpringCloud项目搭建\\springconfig的5.png)\n\n\n\n#### 1,新建config模块:\n\n名字:   cloud-config-3344\n\n#### 2,pom\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\springconfig的6.png)\n\n#### 4,主启动类\n\n![](SpringCloud项目搭建\\springconfig的7.png)\n\n#### 5,修改hosts:\n\n![](SpringCloud项目搭建\\springconfig的8.png)\n\n#### 6,配置完成\n\n测试,3344是否可以从github上获取配置\n\n启动3344\t(要先启动eureka)\n\n![](SpringCloud项目搭建\\springconfig的9.png)\n\n它实际上就是,读取到配置文件中的GitHub的地址,然后拼接上/master/config-dev.yml\n\n#### 7,读取配置文件的规则:\n\n![](SpringCloud项目搭建\\springconfig的10.png)\n\n\n\n==2,==\n\n![](SpringCloud项目搭建\\springconfig的11.png)\n\n**这里默认会读取master分支,因为我们配置文件中配置了**\n\n![](SpringCloud项目搭建\\springconfig的12.png)\n\n==3==\n\n![](SpringCloud项目搭建\\springconfig的13.png)\n\n注意,这个方式读取到的配置是==json格式==的\n\n**所有规则:**\n\n![](SpringCloud项目搭建\\springconfig的14.png)\n\n\n\n### 2,创建配置中心客户端:\n\n#### 1,创建config客户端项目\n\n名字: \tcloud-config-client-3355\n\n#### 2,pom\n\n#### 3,配置文件\n\n注意这个配置文件就不是application.yml\n\n​\t\t\t而是bootstrap.yml\n\n这个配置文件的作用是,先到配置中心加载配置,然后加载到application.yml中\n\n![](SpringCloud项目搭建\\springconfig的15.png)\n\n![](SpringCloud项目搭建\\springconfig的16.png)\n\n\n\n#### 4,主启动类:\n\n![](SpringCloud项目搭建\\springconfig的17.png)\n\n#### 5,controller类\n\n就是上面提到的,以rest风格将配置对外暴露\n\n![](SpringCloud项目搭建\\springconfig的18.png)\n\n![](SpringCloud项目搭建\\springconfig的19.png)\n\n**如果客户端运行正常,就会读取到github上配置文件的,config.info下的配置**\n\n#### 6,测试:\n\n启动3344,3355\n\n​\t访问3355的  /configInfo\n\n![](SpringCloud项目搭建\\springconfig的21.png)\n\n\n\n\n\n#### 7,问题::\n\n```java\n上面3355确实获取到了配置文件,但是如果此时配置文件修改了,3355是获取不到的\n\t\t3344可以实时获取到最新配置文件,但是3355却获取不到\n  \t除非重启服务\n```\n\n#### **8,实现动态刷新:**\n\n##### 1,修改3355,添加一个pom依赖:\n\n![](SpringCloud项目搭建\\springconfig的22.png)\n\n##### 2,修改配置文件,添加一个配置:\n\n![](SpringCloud项目搭建\\springconfig的23.png)\n\n##### 3,修改controller:\n\n![](SpringCloud项目搭建\\springconfig的24.png)\n\n\n\n##### 4,此时重启服务\n\n**此时3355还不可以动态获取**\n\n因为此时,还需要==外部==发送post请求通知3355\n\n![](SpringCloud项目搭建\\springconfig的25.png)\n\n**此时在刷新3355,发现可以获取到最新的配置文件了,这就实现了动态获取配置文件,因为3355并没有重启**\n\n\n\n具体流程就是:\n\n​\t\t\t我们启动好服务后\n\n​\t\t\t运维人员,修改了配置文件,然后发送一个post请求通知3355\n\n​\t\t\t3355就可以获取最新配置文件\n\n\n\n\n\n**问题:**\n\n​\t\t如果有多个客户端怎么办(3355,3356,3357.....)\n\n​\t\t\t\t\t\t虽然可以使用shell脚本,循环刷新\n\n​\t\t但是,可不可以使用广播,一次通知??\n\n​\t\t\t\t\t这些springconfig做不到,需要使用springcloud Bus消息总线\n\n\n\n\n\n\n\n# 消息总线:\n\n## SpringCloud Bus:\n\n![](/SpringCloud项目搭建/springconfig的26.png)\n\n\n\n\n\n\n\n![](SpringCloud项目搭建\\springconfig的27.png)\n\n![](SpringCloud项目搭建\\springconfig的31.png)\n\n注意,这里年张SpringCloud项目搭建,就代表两种广播方式\n\n​\t\t\t图1:\t\t**它是Bus直接通知给其中一个客户端,由这个客户端开始蔓延,传播给其他所有客户端**\n\n​\t\t\t图2:\t\t它**是通知给配置中心的服务端,有服务端广播给所有客户端**\n\n\n\n\n\n**为什么被称为总线?**\n\n![](SpringCloud项目搭建\\springconfig的28.png)\n\n```java\n就是通过消息队列达到广播的效果\n  \t\t我们要广播每个消息时,主要放到某个topic中,所有监听的节点都可以获取到\n```\n\n\n\n\n\n### 使用Bus:\n\n#### 1,配置rabbitmq环境:\n\n![](SpringCloud项目搭建\\springconfig的29.png)\n\n\n\n#### **2,之前只有一个配置中心客户端,这里在创建一个**\n\n​\t\t==**复制3355即可,创建为3366**==\n\n![](SpringCloud项目搭建\\springconfig的30.png)\n\n全部复制3355的即可\n\n\n\n#### 2,使用Bus实现全局广播\n\n**Bus广播有两种方式:**\n\n​\t\t==就是上面两个SpringCloud项目搭建的两种方式==\n\n![](SpringCloud项目搭建\\springconfig的32.png)\n\n**这两种方式,第二种跟合适,因为:**\n\n​\t\t\t==第一种的缺点:==\n\n![](SpringCloud项目搭建\\springconfig的33.png)\n\n\n\n\n\n#### **配置第二种方式:**\n\n##### **1,配置3344(配置中心服务端):**\n\n###### 1,修改配置文件:\n\n![](SpringCloud项目搭建\\Bus的1.png)\n\n###### 2,添加pom\n\n**springboot的监控组件,和消息总线**\n\n![](SpringCloud项目搭建\\Bus的3.png)\n\n![](SpringCloud项目搭建\\Bus的2.png)\n\n\n\n##### 2,修改3355(配置中心的客户端)\n\n###### 1,pom:\n\n![](SpringCloud项目搭建\\Bus的3.png)\n\n![Bus的2](SpringCloud项目搭建\\Bus的2.png)\n\n\n\n###### 2,配置文件:\n\n==注意配置文件的名字,要改为bootstrap.yml==\n\n![](SpringCloud项目搭建\\Bus的5.png)\n\n![image-20200415102708661](SpringCloud项目搭建\\Bus的4)\n\n\n\n\n\n##### 3,修改3366(也是配置中心的客户端)\n\n​\t\t\t修改与3355是一模一样的\n\n\n\n\n\n\n\n##### 4,测试\n\n启动7001,3344,3355,3366\n\n此时修改GitHub上的配置文件\n\n==此时只需要刷新3344,即可让3355,3366动态获取最新的配置文件==\n\n![](SpringCloud项目搭建\\Bus的6.png)\n\n\n\n其原理就是:\n\n![](SpringCloud项目搭建\\Bus的7.png)\n\n**所有客户端都监听了一个rabbitMq的topic,我们将信息放入这个topic,所有客户端都可以送到,从而实时更新**\n\n\n\n\n\n\n\n\n\n#### 配置定点通知\n\n​\t\t就是只通知部分服务,比如只通知3355,不通知3366\n\n![](SpringCloud项目搭建\\Bus的8.png)\n\n![Bus的8](SpringCloud项目搭建\\Bus的9.png)\n\n\n\n**只通知3355**\n\n![](SpringCloud项目搭建\\Bus的11.png)\n\n​\t![](SpringCloud项目搭建\\Bus的12.png)\n\n**可以看到,实际上就是通过==微服务的名称+端口号==进行指定**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 8,消息驱动:\n\n## Spring Cloud Stream:\n\n```java\n现在一个很项目可能分为三部分:\n\t\t\t前端--->后端---->大数据\n\t\t\t而后端开发使用消息中间件,可能会使用RabbitMq\n\t\t\t而大数据开发,一般都是使用Kafka,\n\t\t\t那么一个项目中有多个消息中间件,对于程序员,因为人员都不友好\n```\n\n而Spring Cloud Stream就类似jpa,屏蔽底层消息中间件的差异,程序员主要操作Spring Cloud Stream即可\n\n​\t\t\t不需要管底层是kafka还是rabbitMq\n\n![](SpringCloud项目搭建\\SpringCloudStream的1.png)\n\n### ==什么是Spring Cloud Stream==\n\n![](SpringCloud项目搭建\\SpringCloudStream的2.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\SpringCloudStream的3.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的4.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的5.png)\n\n\n\n\n\n### ==**Spring Cloud Stream是怎么屏蔽底层差异的?**==\n\n![](SpringCloud项目搭建\\SpringCloudStream的6.png)\n\n\n\n\n\n**绑定器:**\n\n![](SpringCloud项目搭建\\SpringCloudStream的7.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的8.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的9.png)\n\n\n\n\n\n### **Spring Cloud Streamd 通信模式:**\n\n![](SpringCloud项目搭建\\SpringCloudStream的10.png)![](SpringCloud项目搭建\\SpringCloudStream的11.png)\n\n\n\n\n\n### Spring Cloud Stream的业务流程:\n\n![](SpringCloud项目搭建\\SpringCloudStream的12.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的14.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的13.png)\n\n```java\n类似flume中的channel,source,sink  估计是借鉴(抄袭)的\n  \tsource用于获取数据(要发送到mq的数据)\n  \tchannel类似SpringCloudStream中的中间件,用于存放source接收到的数据,或者是存放binder拉取的数据\t\n```\n\n\n\n\n\n\n\n### 常用注解和api:\n\n![](SpringCloud项目搭建\\SpringCloudStream的15.png)\n\n\n\n\n\n### 使用SpringCloudStream:\n\n需要创建三个项目,一个生产者,两个消费者\n\n![](SpringCloud项目搭建\\SpringCloudStream的16.png)\n\n### 1,创建生产者\n\n#### 1,pom\n\n#### 2,配置文件\n\n![image-20200415114816133](SpringCloud项目搭建\\SpringCloudStream的17)\n\n![](SpringCloud项目搭建\\SpringCloudStream的18.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\SpringCloudStream的19.png)\n\n#### 4,service和实现类\n\nservice定义发送消息\n\n![](SpringCloud项目搭建\\SpringCloudStream的20.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的21.png)\n\n**这里,就会调用send方法,将消息发送给channel,**\n\n​\t\t\t\t**然后channel将消费发送给binder,然后发送到rabbitmq中**\n\n#### 5,controller\n\n![](SpringCloud项目搭建\\SpringCloudStream的22.png)\n\n#### 6,可以测试\n\n**启动rabbitmq**\n\n**启动7001,8801**\n\n​\t\t确定8801后,会在rabbitmq中创建一个Exchange,就是我们配置文件中配置的exchange\n\n**访问8801的/sendMessage**\n\n\n\n\n\n\n\n### 创建消费者:\n\n#### 1,pom文件\n\n#### 2,配置文件\n\n==**这里排版一点问题**==\n\n**==input==就表示,当前服务是一个消费者,需要消费消息,下面就是指定消费哪个Exchange中的消息**\n\n![](SpringCloud项目搭建\\SpringCloudStream的23.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的24.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\SpringCloudStream的25.png)\n\n#### 4,业务类(消费数据)\n\n![](SpringCloud项目搭建\\SpringCloudStream的26.png)\n\n**生产者发送消息时,使用send方法发送,send方法发送的是一个个Message,里面封装了数据**\n\n#### 5,测试:\n\n启动7001.8801.8802\n\n**此时使用生产者生产消息**\n\n![](SpringCloud项目搭建\\SpringCloudStream的27.png)\n\n==可以看到,消费者已经接收到消息了==\n\n\n\n\n\n### 创建消费者2\n\n创建8803,\n\n==与8802创建一模一样,就不写了==\n\n**创建8803主要是为了演示重复消费等问题**\n\n...\n\n....\n\n...\n\n\n\n\n\n### ==重复消费问题:==\n\n此时启动7001.8801.8802.8803\n\n此时生产者生产一条消息\n\n但是此时查询消费者,发现8802,8803==都消费到了同一条数据==\n\n![](SpringCloud项目搭建\\SpringCloudStream的28.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的29.png)\n\n#### 1,自定义分组\n\n**修改8802,8803的配置文件**\n\n![](SpringCloud项目搭建\\SpringCloudStream的30.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的31 - 副本.png)\n\n**现在将8802,8803都分到了A组**\n\n然后去重启02,03\n\n**然后此时生产者生产两条消息**\n\n![](SpringCloud项目搭建\\SpringCloudStream的33.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的34.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的35.png)\n\n**可以看到,每人只消费了一条消息,并且没有重复消费**\n\n\n\n\n\n\n\n### 持久化问题:\n\n就是当服务挂了,怎么消费没有消费的数据??\n\n\n\n这里,先将8802移除A组,\n\n​\t\t然后将02,03服务关闭\n\n此时生产者开启,发送3条消息\n\n​\t\t此时重启02,03\n\n​\t\t可以看到,当02退出A组后,它就获取不到在它宕机的时间段内的数据\n\n​\t\t但是03重启后,直接获取到了宕机期间它没有消费的数据,并且消费了\n\n总结:\n\t\t也就是,当我们没有配置分组时,会出现消息漏消费的问题\n\n​\t\t而配置分组后,我们可以自动获取未消费的数据\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 9,链路追踪:\n\n## Spring Cloud Sleuth\n\n**sleuth要解决的问题:**\n\n![](SpringCloud项目搭建\\sleuth的1.png)\n\n**而来sleuth就是用于追踪每个请求的整体链路**\n\n![](SpringCloud项目搭建\\sleuth的2.png)\n\n\n\n### 使用sleuth:\n\n#### 1,安装zipkin:\n\n![](SpringCloud项目搭建\\sleuth的3.png)\n\n**运行jar包**\n\n​\t\t\tjava -jar xxxx.jar\n\n**然后就可以访问web界面,  默认zipkin监听的端口是9411**\n\n​\t\t\tlocalhost:9411/zipkin/\n\n![](SpringCloud项目搭建\\sleuth的4.png)\n\n\n\n**一条链路完整SpringCloud项目搭建:**\n\n![](SpringCloud项目搭建\\sleuth的5.png)\n\n**精简版:**\n\n![](SpringCloud项目搭建\\sleuth的6.png)\n\n**可以看到,类似链表的形式**\n\n\n\n\n\n\n\n#### 2,使用sleuth:\n\n不需要额外创建项目,使用之前的8001和order的80即可\n\n\n\n##### 1,修改8001\n\n**引入pom:**\n\n![](SpringCloud项目搭建\\sleuth的7.png)\n\n这个包虽然叫zipkin但是,里面包含了zpikin与sleuth\n\n**修改配置文件:**\n\n![](SpringCloud项目搭建\\sleuth的8.png)\n\n\n\n##### 2,修改80\n\n**添加pom**\n\n与上面是一样的\n\n\n\n**添加配置**:\n\n与上面也是一样的\n\n\n\n\n\n\n\n##### 3,测试:\n\n启动7001.8001,80,9411\n\n![](SpringCloud项目搭建\\sleuth的9.png)\n\n\n\n\n\n\n\n\n\n\n\n# 10,Spring CloudAlibaba:\n\n**之所以有Spring CloudAlibaba,是因为Spring Cloud Netflix项目进入维护模式**\n\n​\t\t**也就是,就不是不更新了,不会开发新组件了**\n\n​\t\t**所以,某些组件都有代替版了,比如Ribbon由Loadbalancer代替,等等**\n\n==支持的功能==\n\n![](SpringCloud项目搭建\\Alibaba的1.png)\n\n几乎可以将之前的Spring Cloud代替\n\n\n\n\n\n\n\n==具体组件==:\n![](SpringCloud项目搭建\\Alibaba的2.png)\n\n\n\n\n\n\n\n\n\n\n\n## Nacos:\n\n**服务注册和配置中心的组合**\n\n​\t\t\tNacos=erueka+config+bus\n\n\n\n\n\n### 安装Nacos:\n\n需要java8  和 Mavne\n\n**1,到github上下载安装包**\n\n​\t\t解压安装包\n\n**2,启动Nacos**\n\n​\t\t在bin下,进入cod\n\n​\t\t./startup.cmd\n\n**3,访问Nacos**\n\n​\t\tNacos默认监听8848\n\n​\t\tlocalhost:8848/nacos\n\n​\t\t账号密码:默认都是nacos\n\n\n\n\n\n### 使用Nacos:\n\n新建pay模块\n\n​\t\t**现在不需要额外的服务注册模块了,Nacos单独启动了**\n\n名字: cloudalibaba-pay-9001\n\n#### 1,pom\n\n父项目管理alibaba的依赖:\n\n![](SpringCloud项目搭建\\Alibaba的4.png)\n\n![](SpringCloud项目搭建\\Alibaba的3.png)\n\n==9001的pom==:\n\n​\t\t\t另外一个文件.....\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\Alibaba的5.png)\n\n#### 3,启动类\n\n![](SpringCloud项目搭建\\Alibaba的6.png)\n\n#### 4,controller:\n\n![](SpringCloud项目搭建\\Alibaba的7.png)\n\n#### 5,测试\n\n启动9001\n\n然后查看Nacos的web界面,可以看到9001已经注册成功\n\n\n\n### \n\n\n\n\n\n### 创建其他Pay模块\n\n​\t\t额外在创建9002,9003\n\n​\t\t直接复制上面的即可\n\n### 创建order模块\n\n名字:  cloudalibaba-order-83\n\n#### 1,pom\n\n**为什么Nacos支持负载均衡?**\n\n​\t\t\t\tNacos直接集成了Ribon,所以有负载均衡\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\Alibaba的8.png)\n\n**这个server-url的作用是,我们在controller,需要使用RestTempalte远程调用9001,**\n\n​\t\t**这里是指定9001的地址**\n\n\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\Alibaba的9.png)\n\n#### 4,编写配置类\n\n​\t==因为Naocs要使用Ribbon进行负载均衡,那么就需要使用RestTemplate==\n\n![](SpringCloud项目搭建\\Alibaba的10.png)\n\n#### 5,controller:\n\n![](SpringCloud项目搭建\\Alibaba的11.png)\n\n\n\n#### 6,测试\n\n启动83,访问9001,9002,可以看到,实现了负载均衡\n\n\n\n\n\n### Nacos与其他服务注册的对比\n\nNacos它既可以支持CP,也可以支持AP,可以切换\n\n![](SpringCloud项目搭建\\Alibaba的12.png)\n\n![](SpringCloud项目搭建\\Alibaba的13.png)\n\n==下面这个curl命令,就是切换模式==\n\n\n\n\n\n### 使用Nacos作为配置中心:\n\n![](SpringCloud项目搭建\\Alibaba的14.png)\n\n**==需要创建配置中心的客户端模块==**\n\ncloudalibaba-Nacos-config-client-3377\n\n#### 1,pom\n\n#### 2,配置文件\n\n这里需要配置两个配置文件,application.ymk和bootstarp.yml\n\n​\t\t\t主要是为了可以与spring clodu config无缝迁移\n\n![](SpringCloud项目搭建\\Alibaba的15.png)\n\n```java\n可以看到\n```\n\n![](SpringCloud项目搭建\\Alibaba的16.png)\n\n\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\Alibaba的18.png)\n\n#### 4,controller\n\n![](SpringCloud项目搭建\\Alibaba的17.png)\n\n```java\n可以看到,这里也添加了@RefreshScope\n  \t\t之前在Config配置中心,也是添加这个注解实现动态刷新的\t\n  \n```\n\n![](SpringCloud项目搭建\\Alibaba的19.png)\n\n#### 5,在Nacos添加配置信息:\n\n==**Nacos的配置规则:**==\n\n![](SpringCloud项目搭建\\Alibaba的20.png)\n\n**配置规则,就是我们在客户端如何指定读取配置文件,配置文件的命名的规则**\n\n默认的命名方式:\n\n![](SpringCloud项目搭建\\Alibaba的21.png)\n\n```java\nprefix:\n\t\t默认就是当前服务的服务名称\n \t\t也可以通过spring.cloud.necos.config.prefix配置\nspring.profile.active:\n\t\t就是我们在application.yml中指定的,当前是开发环境还是测试等环境\n    这个可以不配置,如果不配置,那么前面的 -  也会没有\nfile-extension\n     就是当前文件的格式(后缀),目前只支持yml和properties\n```\n\n![](SpringCloud项目搭建\\Alibaba的24.png)\n\n![](SpringCloud项目搭建\\Alibaba的25.png)\n\n==在web UI上创建配置文件:==\n\n![](SpringCloud项目搭建\\Alibaba的22.png)\n\n![](SpringCloud项目搭建\\Alibaba的23.png)\n\n注意,DataId就是配置文件名字:\n\n​\t\t名字一定要按照上面的==规则==命名,否则客户端会读取不到配置文件\n\n#### 6,测试\n\n重启3377客户端\n\n访问3377\n\n![](SpringCloud项目搭建\\Alibaba的26.png)\n\n**拿到了配置文件中的值**\n\n\n\n#### 7,注意默认就开启了自动刷新\n\n此时我们修改了配置文件\n\n客户端是可以立即更新的\n\n​\t\t\t因为Nacos支持Bus总线,会自动发送命令更新所有客户端\n\n\n\n\n\n### Nacos配置中心之分类配置:\n\n![](SpringCloud项目搭建\\Alibaba的27.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\Alibaba的28.png)\n\n![](SpringCloud项目搭建\\Alibaba的29.png)\n\nNameSpace默认有一个:public名称空间\n\n这三个类似java的: 包名 + 类名 + 方法名\n\n![](SpringCloud项目搭建\\Alibaba的30.png)\n\n\n\n![](SpringCloud项目搭建\\Alibaba的31.png)\n\n\n\n\n\n#### 1,配置不同DataId:\n\n![](SpringCloud项目搭建\\Alibaba的32.png)\n\n![](SpringCloud项目搭建\\Alibaba的33.png)\n\n\n\n​\t==通过配置文件,实现多环境的读取:==\n\n![](SpringCloud项目搭建\\Alibaba的34.png)\n\n```java\n此时,改为dev,就会读取dev的配置文件,改为test,就会读取test的配置文件\n```\n\n\n\n\n\n#### 2,配置不同的GroupID:\n\n直接在新建配置文件时指定组\n\n![](SpringCloud项目搭建\\Alibaba的35.png)\n\n![](SpringCloud项目搭建\\Alibaba的36.png)\n\n\n\n==在客户端配置,使用指定组的配置文件:==\n\n![](SpringCloud项目搭建\\Alibaba的37.png)\n\n**这两个配置文件都要修改**\n\n![](SpringCloud项目搭建\\Alibaba的38.png)\n\n​\t\n\n重启服务,即可\n\n\n\n\n\n\n\n#### 配置不同的namespace:\n\n![](SpringCloud项目搭建\\Alibaba的39.png)\n\n![](SpringCloud项目搭建\\Alibaba的42.png)\n\n==客户端配置使用不同名称空间:==\n\n![](SpringCloud项目搭建\\Alibaba的41.png)\n\n**要通过命名空间id指定**\n\nOK,测试\n\n\n\n\n\n\n\n\n\n### Nacos集群和持久化配置:\n\n![](SpringCloud项目搭建\\Alibaba的45.png)\n\nNacos默认有自带嵌入式数据库,derby,但是如果做集群模式的话,就不能使用自己的数据库\n\n​\t\t\t不然每个节点一个数据库,那么数据就不统一了,需要使用外部的mysql\n\n![](SpringCloud项目搭建\\Alibaba的43.png)\n\n\n\n#### 1,单机版,切换mysql数据库:\n\n​\t\t\t\t\t**将nacos切换到使用我们自己的mysql数据库:**\n\n**1,nacos默认自带了一个sql文件,在nacos安装目录下**\n\n​\t\t\t将它放到我们的mysql执行\n\n**2,修改Nacos安装目录下的安排application.properties,添加:**\n\n![](SpringCloud项目搭建\\Alibaba的46.png)\n\n\n\n\n\n**3,此时可以重启nacos,那么就会改为使用我们自己的mysql**\n\n\n\n\n\n\n\n#### Linux上配置Nacos集群+Mysql数据库\n\n==官方架构图:==\n\n![](SpringCloud项目搭建\\Alibaba的45.png)\n\n**需要一个Nginx作为VIP**\n\n\n\n1,下载安装Nacos的Linux版安装包\n\n2,进入安装目录,现在执行自带的sql文件\n\n​\t\t\t进入mysql,执行sql文件\n\n3.修改配置文件,切换为我们的mysql\n\n​\t\t\t就是上面windos版要修改的几个属性\n\n4,修改cluster.conf,指定哪几个节点是Nacos集群\n\n​\t\t\t这里使用3333,4444,5555作为三个Nacos节点监听的端口\n\n![](SpringCloud项目搭建\\Alibaba的47.png)\n\n5,我们这里就不配置在不同节点上了,就放在一个节点上\n\n​\t\t\t既然要在一个节点上启动不同Nacos实例,就要修改startup.sh,使其根据不同端口启动不同Nacos实例\n\n![](SpringCloud项目搭建\\Alibaba的48.png)\n\n![](SpringCloud项目搭建\\Alibaba的49.png)\n\n可以看到,这个脚本就是通过jvm启动nacos\n\n​\t\t所以我们最后修改的就是,nohup java -Dserver.port=3344\n\n\n\n\n\n6,配置Nginx:\n\n​\t\t\t![](SpringCloud项目搭建\\Alibaba的50.png)\n\n7,启动Nacos:\n\t\t\t./startup.sh -p 3333\n\n​\t\t\t./startup.sh -p 4444\n\n​\t\t\t./startup.sh -p 5555\n\n7,启动nginx\n\n8,测试:\n\n​\t\t访问192.168.159.121:1111\n\n​\t\t如果可以进入nacos的web界面,就证明安装成功了\n\n\n\n\n\n9,将微服务注册到Nacos集群:\n![](SpringCloud项目搭建\\Alibaba的51.png)\n\n10,进入Nacos的web界面\n\n​\t\t可以看到,已经注册成功\n\n![](SpringCloud项目搭建\\Alibaba的52.png)\n\n\n\n\n\n\n\n\n\n\n\n## Sentinel:\n\n实现熔断与限流,就是Hystrix\n\n![](SpringCloud项目搭建\\Alibaba的53.png)\n\n​\t![](SpringCloud项目搭建\\Alibaba的54.png)\n\n### ==使用sentinel:==\n\n\n\n1,下载sentinel的jar包\n\n2,运行sentinel\n\n​\t\t由于是一个jar包,所以可以直接java -jar运行\t\n\n​\t\t注意,默认sentinel占用8080端口\n\n3,访问sentinel\n\n​\t\tlocalhost:8080\n\n\n\n\n\n### 微服务整合sentinel:\n\n##### 1,启动Nacos\n\n##### 2,新建一个项目,8401,主要用于配置sentinel\n\n1.  pom\n\n2.   配置文件\n\n    ![](SpringCloud项目搭建\\Alibaba的55.png)\n\n3.   主启动类\n\n    ![](SpringCloud项目搭建\\Alibaba的56.png)\n\n4.   controller\\\n\n    ![](SpringCloud项目搭建\\sentinel的1.png)\n\n5.   到这里就可以启动8401\n\n    ​\t此时我们到sentinel中查看,发现并8401的任何信息\n\n    ​\t是因为,sentinel是懒加载,需要我们执行一次访问,才会有信息\n\n    ​\t访问localhost/8401/testA\n\n    ![](SpringCloud项目搭建\\sentinel的2.png)\n\n6.   可以看到.已经开始监听了\n\n​    \n\n\n\n### sentinel的流控规则\n\n流量限制控制规则\n\n![](SpringCloud项目搭建\\sentinel的7.png)\n\n![](SpringCloud项目搭建\\sentinel的3.png)\n\n\n\n![](SpringCloud项目搭建\\sentinel的4.png)\n\n==流控模式==:\n\n1.   直接快速失败\n\n    ![](SpringCloud项目搭建\\sentinel的9.png)\n\n    ![](SpringCloud项目搭建\\sentinel的5.png)\n\n       ==直接失败的效果:==\n\n    ![](SpringCloud项目搭建\\sentinel的6.png)\n\n2.  线程数:\n\n    ​\t\t![](SpringCloud项目搭建\\sentinel的8.png)\n\n    ​\t![](SpringCloud项目搭建\\sentinel的10.png)\n\n    ```\n    比如a请求过来,处理很慢,在一直处理,此时b请求又过来了\n    \t\t此时因为a占用一个线程,此时要处理b请求就只有额外开启一个线程\n    \t\t那么就会报错\n    ```\n\n    ![](SpringCloud项目搭建\\sentinel的11.png)\n\n    \n\n3.   关联:\n\n     ![](SpringCloud项目搭建\\sentinel的12.png)\n\n     ==应用场景:  比如**支付接口**达到阈值,就要限流下**订单的接口**,防止一直有订单==\n\n     ![](SpringCloud项目搭建\\sentinel的13.png)\n\n     **当testA达到阈值,qps大于1,就让testB之后的请求直接失败**\n\n     可以使用postman压测\n\n​    \n\n4.   链路:\n     多个请求调用同一个微服务\n\n5.   预热Warm up:\n\n    ​\t ![](SpringCloud项目搭建\\sentinel的14.png)\n\n      ![](SpringCloud项目搭建\\sentinel的15.png)\n\n     ![](SpringCloud项目搭建\\sentinel的16.png)\n\n     ==应用场景==\n\n     ![](SpringCloud项目搭建\\sentinel的17.png)\n\n6.   排队等待:\n\n    ![](SpringCloud项目搭建\\sentinel的18.png)\n\n    ![](SpringCloud项目搭建\\sentinel的19.png)\n\n\n\n\n\n\n\n\n\n### 降级规则:\n\n**就是熔断降级**\n\n![](SpringCloud项目搭建\\sentinel的21.png)\n\n![](SpringCloud项目搭建\\sentinel的20.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\sentinel的22.png)\n\n![](SpringCloud项目搭建\\sentinel的23.png)\n\n\n\n#### 1,RT配置:\n\n新增一个请求方法用于测试\n\n![](SpringCloud项目搭建\\sentinel的24.png)\n\n==配置RT:==\n\n​\t\t\t\t这里配置的PT,默认是秒级的平均响应时间\n\n![](SpringCloud项目搭建\\sentinel的25.png)\n\n默认计算平均时间是: 1秒类进入5个请求,并且响应的平均值超过阈值(这里的200ms),就报错]\n\n​\t\t\t1秒5请求是Sentinel默认设置的\n\n==测试==\n\n![](SpringCloud项目搭建\\sentinel的27.png)\n\n![](SpringCloud项目搭建\\sentinel的26.png)\n\n**默认熔断后.就直接抛出异常**\n\n\n\n\n\n\n\n#### 2,异常比例:\n\n![](SpringCloud项目搭建\\sentinel的28.png)\n\n修改请求方法\n\n![](SpringCloud项目搭建\\sentinel的29.png)\n\n配置:\n\n![](SpringCloud项目搭建\\sentinel的31.png)\n\n\n\n==如果没触发熔断,这正常抛出异常==:\n\n![](SpringCloud项目搭建\\sentinel的32.png)\n\n==触发熔断==:\n\n![](SpringCloud项目搭建\\sentinel的33.png)\n\n\n\n\n\n\n\n\n\n#### 3, 异常数:\n\n![](SpringCloud项目搭建\\sentinel的34.png)\n\n![](SpringCloud项目搭建\\sentinel的35.png)\n\n一分钟之内,有5个请求发送异常,进入熔断\n\n\n\n\n\n\n\n\n\n### 热点规则:\n\n![](SpringCloud项目搭建\\sentinel的36.png)\n\n​\t![](SpringCloud项目搭建\\sentinel的37.png)\n\n比如:\n\n​\t\t\tlocalhost:8080/aa?name=aa\n\n​\t\t\tlocalhost:8080/aa?name=b'b\n\n​\t\t\t加入两个请求中,带有参数aa的请求访问频次非常高,我们就现在name==aa的请求,但是bb的不限制\n\n\n\n==如何自定义降级方法,而不是默认的抛出异常?==\n\n![](SpringCloud项目搭建\\sentinel的38.png)\n\n**使用@SentinelResource直接实现降级方法,它等同Hystrix的@HystrixCommand**\n\n![](SpringCloud项目搭建\\sentinel的39.png)\n\n\n\n==定义热点规则:==\n\n ![](SpringCloud项目搭建\\sentinel的40.png)\n\n![](SpringCloud项目搭建\\sentinel的42.png)\n\n**此时我们访问/testHotkey并且带上才是p1**\n\n​\t\t\t如果qps大于1,就会触发我们定义的降级方法\n\n![](SpringCloud项目搭建\\sentinel的41.png)\n\n**但是我们的参数是P2,就没有问题**\n\n![](SpringCloud项目搭建\\sentinel的44.png)\n\n\n\n只有带了p1,才可能会触发热点限流\n\n![](SpringCloud项目搭建\\sentinel的43.png)\n\n\n\n\n\n#### 2,设置热点规则中的其他选项:\n\n![](SpringCloud项目搭建\\sentinel的45.png)\n\n**需求:**\n\n![](SpringCloud项目搭建\\sentinel的46.png)\n\n\n\n![](SpringCloud项目搭建\\sentinel的47.png)\n\n==测试==\n\n![](SpringCloud项目搭建\\sentinel的48.png)\n\n![](SpringCloud项目搭建\\sentinel的49.png)\n\n\n\n**注意:**\n\n参数类型只支持,8种基本类型+String类\n\n\n\n\n\n==注意:==\n\n如果我们程序出现异常,是不会走blockHander的降级方法的,因为这个方法只配置了热点规则,没有配置限流规则\n\n我们这里配置的降级方法是sentinel针对热点规则配置的\n\n只有触发热点规则才会降级\n\n![](SpringCloud项目搭建\\sentinel的50.png)\n\n\n\n\n\n\n\n\n\n### 3,系统规则:\n\n系统自适应限流:\n\t\t\t从整体维度对应用入口进行限流\n\n对整体限流,比如设置qps到达100,这里限流会限制整个系统不可以\n\n*![](SpringCloud项目搭建\\sentinel的51.png)*\n\n\n\n![](SpringCloud项目搭建\\sentinel的52.png)\n\n==测试==:\n![](SpringCloud项目搭建\\sentinel的53.png)\n\n![](SpringCloud项目搭建\\sentinel的54.png)\n\n\n\n\n\n\n\n\n\n\n\n### @SentinelResource注解:\n\n**用于配置降级等功能**\n\n1,环境搭建\n\n1.  为8401添加依赖\n\n    添加我们自己的commone包的依赖\n\n    ![](SpringCloud项目搭建\\sentinel的55.png)\n\n2.   额外创建一个controller类\n\n    ​\t ![](SpringCloud项目搭建\\sentinel的56.png)\n\n     \n\n3.   配置限流\n\n    **注意,我们这里配置规则,资源名指定的是@SentinelResource注解value的值,**\n\n    **这样也是可以的,也就是不一定要指定访问路径**\n\n    ![](SpringCloud项目搭建\\sentinel的57.png)\n\n4.   测试.\n\n    可以看到已经进入降级方法了\n\n    ![](SpringCloud项目搭建\\sentinel的58.png)\n\n5.   ==此时我们关闭8401服务==\n\n    可以看到,这些定义的规则是临时的,关闭服务,规则就没有了\n\n    ![](SpringCloud项目搭建\\sentinel的59.png)\n\n\n\n**可以看到,上面配置的降级方法,又出现Hystrix遇到的问题了**\n\n​\t\t\t降级方法与业务方法耦合\n\n​\t\t\t每个业务方法都需要对应一个降级方法\n\n#### 自定义限流处理逻辑:\n\n1.  ==单独创建一个类,用于处理限流==\n\n    ![](SpringCloud项目搭建\\sentinel的的1.png)\n\n2.  ==在controller中,指定使用自定义类中的方法作为降级方法==\n\n    ![](SpringCloud项目搭建\\sentinel的的2.png)\n\n3.   ==Sentinel中定义流控规则==:\n\n     这里资源名,是以url指定,也可以使用@SentinelResource注解value的值指定\n\n     ![](SpringCloud项目搭建\\sentinel的的5.png)\n\n     \n\n4.  ==测试==:\n\n    ![](SpringCloud项目搭建\\sentinel的的3.png)\n\n5.  ==整体==:\n\n    ![](SpringCloud项目搭建\\sentinel的的4.png)\n\n6.   \n\n\n\n\n\n#### @SentinelResource注解的其他属性:\n\n\n\n![](SpringCloud项目搭建\\sentinel的的7.png)\n\n![](SpringCloud项目搭建\\sentinel的的6.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 服务熔断:\n\n1.  **启动nacos和sentinel**\n\n2.   **新建两个pay模块  9003和9004**\n\n    1.   pom\n\n    2.   配置文件\n\n        ![](SpringCloud项目搭建\\sentinel的的8.png)*\n\n    3.   主启动类 \n\n        ```java\n        @SpringBootApplication\n        @EnableDiscoveryClient\n        public class PaymentMain9003 {\n        \n            public static void main(String[] args) {\n                SpringApplication.run(PaymentMain9003.class,args);\n            }\n        }\n         \n        \n        ```\n\n    4.   controller\n\n        ![](SpringCloud项目搭建\\sentinel的的9.png)\n\n         **然后启动9003.9004**\n\n3.   **新建一个order-84消费者模块:**\n\n    1.   pom\n\n        与上面的pay一模一样\n\n    2.   配置文件\n\n        ![](SpringCloud项目搭建\\sentinel的的10.png)\n\n    3.   主启动类\n\n        ![](SpringCloud项目搭建\\sentinel的的11.png)\n\n    4.  配置类\n\n        ![](SpringCloud项目搭建\\sentinel的的12.png)\n\n    5.   controller\n\n        ![](SpringCloud项目搭建\\sentinel的的13.png)\n\n        \n\n    6.   **==为业务方法添加fallback来指定降级方法==**:\n\n        ![](SpringCloud项目搭建\\sentinel的的14.png)\n\n        ​\t==重启order==\n\n        测试:\n\n        ![](SpringCloud项目搭建\\sentinel的的15.png)\n\n         \n\n         ==所以,fallback是用于管理异常的,当业务方法发生异常,可以降级到指定方法==\n\n        ​\t\t\t注意,我们这里==并没有使用sentinel配置任何规则==,但是却降级成功,就是因为\n\n        ​\t\t\tfallback是用于管理异常的,当业务方法发生异常,可以降级到指定方法==\n\n        \n\n    7.   **==为业务方法添加blockHandler,看看是什么效果==**\n\n         ![](SpringCloud项目搭建\\sentinel的的16.png)\n\n         **重启84,访问业务方法:**\n\n        ![](SpringCloud项目搭建\\sentinel的的17.png)\n\n         可以看到.,直接报错了,并没有降级\n\n        ​\t\t\t\t也就是说,blockHandler==只对sentienl定义的规则降级==\n\n         \n\n    8.   **==如果fallback和blockHandler都配置呢?==**]\n\n         ![](SpringCloud项目搭建\\sentinel的的18.png)\n\n         **设置qps规则,阈值1**\n\n         ![](SpringCloud项目搭建\\sentinel的的19.png)\n\n         ==测试:==\n\n        ![](SpringCloud项目搭建\\sentinel的的20.png)\n\n         \n\n         可以看到,当两个都同时生效时,==blockhandler优先生效==\n\n    9.  **==@SentinelResource还有一个属性,exceptionsToIgnore==**\n\n         ![](SpringCloud项目搭建\\sentinel的的21.png)\n\n         **exceptionsToIgnore指定一个异常类,**\n\n        ​\t\t\t\t\t**表示如果当前方法抛出的是指定的异常,不降级,直接对用户抛出异常**\n\n         ![](SpringCloud项目搭建\\sentinel的的22.png)\n\n         \n\n         \n\n    \n\n\n\n### sentinel整合ribbon+openFeign+fallback\n\n\n\n1.  修改84模块,使其支持feign\n\n    1.  pom\n\n        ![](SpringCloud项目搭建\\sentinel的的23.png)\n\n    2.  配置文件\n\n        ![](SpringCloud项目搭建\\sentinel的的24.png)\n\n    3.  主启动类,也要修改\n\n        ![](SpringCloud项目搭建\\sentinel的的25.png)\n\n    4.  创建远程调用pay模块的接口\n\n        ![](SpringCloud项目搭建\\sentinel的的26.png)\n\n    5.  创建这个接口的实现类,用于降级\n\n        ![](SpringCloud项目搭建\\sentinel的的27.png)\n\n    6.   再次修改接口,指定降级类\n\n        ![](SpringCloud项目搭建\\sentinel的的28.png)\n\n    7.   controller添加远程调用\n\n        ![](SpringCloud项目搭建\\sentinel的的29.png)\n\n    8.  测试\n\n        启动9003,84\n\n    9.   测试,如果关闭9003.看看84会不会降级\n\n        ![](SpringCloud项目搭建\\sentinel的的30.png)\n\n        **可以看到,正常降级了**\n\n        \n\n**熔断框架比较**\n\n![](SpringCloud项目搭建\\sentinel的的31.png)\n\n\n\n\n\n\n\n\n\n### sentinel持久化规则\n\n默认规则是临时存储的,重启sentinel就会消失\n\n![](SpringCloud项目搭建\\sentinel的的32.png)\n\n**这里以之前的8401为案例进行修改:**\n\n1.  修改8401的pom\n\n    ```xml\n    添加:\n    <!-- SpringCloud ailibaba sentinel-datasource-nacos 持久化需要用到-->\n    <dependency>\n        <groupId>com.alibaba.csp</groupId>\n        <artifactId>sentinel-datasource-nacos</artifactId>\n    </dependency>\n     \n    ```\n\n    \n\n2.   修改配置文件:\n\n    添加:\n\n     ![](SpringCloud项目搭建\\sentinel的的33.png)\n\n     **实际上就是指定,我们的规则要保证在哪个名称空间的哪个分组下**\n\n     \t\t\t这里没有指定namespace, 但是是可以指定的\n\n    ​\t\t\t**注意,这里的dataid要与8401的服务名一致**\n\n3.   **在nacos中创建一个配置文件,dataId就是上面配置文件中指定的**\n\n     ![](SpringCloud项目搭建\\sentinel的的34.png)\n\n     ==json中,这些属性的含义:==\n\n    ​\t![](SpringCloud项目搭建\\sentinel的的35.png)\n\n     \n\n    \n\n4.   启动8401:\n\n     ![](SpringCloud项目搭建\\sentinel的的36.png)\n\n     可以看到,直接读取到了规则\n\n5.   关闭8401\n\n    ![](SpringCloud项目搭建\\sentinel的的37.png)\n\n6.   此时重启8401,如果sentinel又可以正常读取到规则,那么证明持久化成功\n\n    可以看到,又重新出现了\n\n     ![](SpringCloud项目搭建\\sentinel的的38.png)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Seata:\n\n是一个分布式事务的解决方案,\n\n**分布式事务中的一些概念,也是seata中的概念:**\n\n​\t\t![](SpringCloud项目搭建\\seala.png)\n\n![](SpringCloud项目搭建\\seala的2.png)\n\n![](SpringCloud项目搭建\\seala的3.png)\n\n\n\n\n\n### seata安装:\n\n1.  **下载安装seata的安装包**\n\n2.  **修改file.conf**\n\n     ![](SpringCloud项目搭建\\seala的4.png)\n\n     ![](SpringCloud项目搭建\\seala的5.png)\n\n     ![](SpringCloud项目搭建\\seala的6.png)\n\n3.   **mysql建库建表**\n\n     1,上面指定了数据库为seata,所以创建一个数据库名为seata\n\n     2,建表,在seata的安装目录下有一个db_store.sql,运行即可\n\n4.   **继续修改配置文件,修改registry.conf**\n\n    配置seata作为微服务,指定注册中心\n\n    ![](SpringCloud项目搭建\\seala的7.png)\n\n5.   启动\n\n    先启动nacos\n\n    在启动seata-server(运行安装目录下的,seata-server.bat)\n\n    \n\n**业务说明**\n\n![](SpringCloud项目搭建\\seala的8.png)\n\n下单--->库存--->账号余额\n\n\n\n1.  创建三个数据库\n\n    ![](SpringCloud项目搭建\\seala的9.png)\n\n2.   创建对应的表\n\n    ![](SpringCloud项目搭建\\seala的10.png)\n\n3.   创建回滚日志表,方便查看\n\n    ![](SpringCloud项目搭建\\seala的11.png)\n\n    **注意==每个库都要执行一次==这个sql,生成回滚日志表**\n\n4.   ==每个业务都创建一个微服务,也就是要有三个微服务,订单,库存,账号==\n\n    ​     ==订单==,seta-order-2001\n\n    1.   pom\n\n    2.   配置文件\n\n        ```yaml\n        server:\n          port: 2001\n        \n        spring:\n          application:\n            name: seata-order-service\n          cloud:\n            alibaba:\n              seata:\n                # 自定义事务组名称需要与seata-server中的对应,我们之前在seata的配置文件中配置的名字\n                tx-service-group: fsp_tx_group\n            nacos:\n              discovery:\n                server-addr: 127.0.0.1:8848\n          datasource:\n            # 当前数据源操作类型\n            type: com.alibaba.druid.pool.DruidDataSource\n            # mysql驱动类\n            driver-class-name: com.mysql.cj.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/seata_order?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=GMT%2B8\n            username: root\n            password: root\n        feign:\n          hystrix:\n            enabled: false\n        logging:\n          level:\n            io:\n              seata: info\n        \n        mybatis:\n          mapperLocations: classpath*:mapper/*.xml\n        \n         \n         \n        \n        ```\n\n        还要额外创建其他配置文件,创建一个file.conf:\n\n         ```.conf\n        transport {\n          # tcp udt unix-domain-socket\n          type = \"TCP\"\n          #NIO NATIVE\n          server = \"NIO\"\n          #enable heartbeat\n          heartbeat = true\n          #thread factory for netty\n          thread-factory {\n            boss-thread-prefix = \"NettyBoss\"\n            worker-thread-prefix = \"NettyServerNIOWorker\"\n            server-executor-thread-prefix = \"NettyServerBizHandler\"\n            share-boss-worker = false\n            client-selector-thread-prefix = \"NettyClientSelector\"\n            client-selector-thread-size = 1\n            client-worker-thread-prefix = \"NettyClientWorkerThread\"\n            # netty boss thread size,will not be used for UDT\n            boss-thread-size = 1\n            #auto default pin or 8\n            worker-thread-size = 8\n          }\n          shutdown {\n            # when destroy server, wait seconds\n            wait = 3\n          }\n          serialization = \"seata\"\n          compressor = \"none\"\n        }\n        service {\n          #vgroup->rgroup\n          # 事务组名称\n          vgroup_mapping.fsp_tx_group = \"default\"\n          #only support single node\n          default.grouplist = \"127.0.0.1:8091\"\n          #degrade current not support\n          enableDegrade = false\n          #disable\n          disable = false\n          #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent\n          max.commit.retry.timeout = \"-1\"\n          max.rollback.retry.timeout = \"-1\"\n        }\n         \n        client {\n          async.commit.buffer.limit = 10000\n          lock {\n            retry.internal = 10\n            retry.times = 30\n          }\n          report.retry.count = 5\n          tm.commit.retry.count = 1\n          tm.rollback.retry.count = 1\n        }\n         \n        ## transaction log store\n        store {\n          ## store mode: file、db\n          #mode = \"file\"\n          mode = \"db\"\n         \n          ## file store\n          file {\n            dir = \"sessionStore\"\n         \n            # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions\n            max-branch-session-size = 16384\n            # globe session size , if exceeded throws exceptions\n            max-global-session-size = 512\n            # file buffer size , if exceeded allocate new buffer\n            file-write-buffer-cache-size = 16384\n            # when recover batch read size\n            session.reload.read_size = 100\n            # async, sync\n            flush-disk-mode = async\n          }\n         \n          ## database store\n          db {\n            ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.\n            datasource = \"dbcp\"\n            ## mysql/oracle/h2/oceanbase etc.\n            db-type = \"mysql\"\n            driver-class-name = \"com.mysql.jdbc.Driver\"\n            url = \"jdbc:mysql://127.0.0.1:3306/seata\"\n            user = \"root\"\n            password = \"root\"\n            min-conn = 1\n            max-conn = 3\n            global.table = \"global_table\"\n            branch.table = \"branch_table\"\n            lock-table = \"lock_table\"\n            query-limit = 100\n          }\n        }\n        lock {\n          ## the lock store mode: local、remote\n          mode = \"remote\"\n         \n          local {\n            ## store locks in user's database\n          }\n         \n          remote {\n            ## store locks in the seata's server\n          }\n        }\n        recovery {\n          #schedule committing retry period in milliseconds\n          committing-retry-period = 1000\n          #schedule asyn committing retry period in milliseconds\n          asyn-committing-retry-period = 1000\n          #schedule rollbacking retry period in milliseconds\n          rollbacking-retry-period = 1000\n          #schedule timeout retry period in milliseconds\n          timeout-retry-period = 1000\n        }\n         \n        transaction {\n          undo.data.validation = true\n          undo.log.serialization = \"jackson\"\n          undo.log.save.days = 7\n          #schedule delete expired undo_log in milliseconds\n          undo.log.delete.period = 86400000\n          undo.log.table = \"undo_log\"\n        }\n         \n        ## metrics settings\n        metrics {\n          enabled = false\n          registry-type = \"compact\"\n          # multi exporters use comma divided\n          exporter-list = \"prometheus\"\n          exporter-prometheus-port = 9898\n        }\n         \n        support {\n          ## spring\n          spring {\n            # auto proxy the DataSource bean\n            datasource.autoproxy = false\n          }\n        }\n        \n         ```\n\n        创建registry.conf:\n\n        ```conf\n        registry {\n          # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa\n          type = \"nacos\"\n         \n          nacos {\n            #serverAddr = \"localhost\"\n            serverAddr = \"localhost:8848\"\n            namespace = \"\"\n            cluster = \"default\"\n          }\n          eureka {\n            serviceUrl = \"http://localhost:8761/eureka\"\n            application = \"default\"\n            weight = \"1\"\n          }\n          redis {\n            serverAddr = \"localhost:6379\"\n            db = \"0\"\n          }\n          zk {\n            cluster = \"default\"\n            serverAddr = \"127.0.0.1:2181\"\n            session.timeout = 6000\n            connect.timeout = 2000\n          }\n          consul {\n            cluster = \"default\"\n            serverAddr = \"127.0.0.1:8500\"\n          }\n          etcd3 {\n            cluster = \"default\"\n            serverAddr = \"http://localhost:2379\"\n          }\n          sofa {\n            serverAddr = \"127.0.0.1:9603\"\n            application = \"default\"\n            region = \"DEFAULT_ZONE\"\n            datacenter = \"DefaultDataCenter\"\n            cluster = \"default\"\n            group = \"SEATA_GROUP\"\n            addressWaitTime = \"3000\"\n          }\n          file {\n            name = \"file.conf\"\n          }\n        }\n         \n        config {\n          # file、nacos 、apollo、zk、consul、etcd3\n          type = \"file\"\n         \n          nacos {\n            serverAddr = \"localhost\"\n            namespace = \"\"\n          }\n          consul {\n            serverAddr = \"127.0.0.1:8500\"\n          }\n          apollo {\n            app.id = \"seata-server\"\n            apollo.meta = \"http://192.168.1.204:8801\"\n          }\n          zk {\n            serverAddr = \"127.0.0.1:2181\"\n            session.timeout = 6000\n            connect.timeout = 2000\n          }\n          etcd3 {\n            serverAddr = \"http://localhost:2379\"\n          }\n          file {\n            name = \"file.conf\"\n          }\n        }\n        \n        ```\n\n        ==实际上,就是要将seata中的我们之前修改的两个配置文件复制到这个项目下==\n\n    3.   **主启动类**\n\n        ```java\n        @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //取消数据源的自动创建\n        @EnableDiscoveryClient\n        @EnableFeignClients\n        public class SeataOrderMain2001 {\n        \n            public static void main(String[] args) {\n                SpringApplication.run(SeataOrderMain2001.class,args);\n            }\n        }\n        ```\n\n        \n\n    4.   **service层**\n\n         ```xml\n        public interface OrderService {\n        \n            /**\n             * 创建订单\n             * @param order\n             */\n            void create(Order order);\n        }\n        ```\n\n        ```xml\n        @FeignClient(value = \"seata-storage-service\")\n        public interface StorageService {\n        \n            /**\n             * 减库存\n             * @param productId\n             * @param count\n             * @return\n             */\n            @PostMapping(value = \"/storage/decrease\")\n            CommonResult decrease(@RequestParam(\"productId\") Long productId, @RequestParam(\"count\") Integer count);\n        }\n        ```\n\n        ```xml\n        @FeignClient(value = \"seata-account-service\")\n        public interface AccountService {\n        \n            /**\n             * 减余额\n             * @param userId\n             * @param money\n             * @return\n             */\n            @PostMapping(value = \"/account/decrease\")\n            CommonResult decrease(@RequestParam(\"userId\") Long userId, @RequestParam(\"money\") BigDecimal money);\n        }\n         \n         \n        \n        ```\n\n        ```xml\n        @Service\n        @Slf4j\n        public class OrderServiceImpl implements OrderService {\n        \n            @Resource\n            private OrderDao orderDao;\n            @Resource\n            private AccountService accountService;\n            @Resource\n            private StorageService storageService;\n        \n            /**\n             * 创建订单->调用库存服务扣减库存->调用账户服务扣减账户余额->修改订单状态\n             * 简单说:\n             * 下订单->减库存->减余额->改状态\n             * GlobalTransactional seata开启分布式事务,异常时回滚,name保证唯一即可\n             * @param order 订单对象\n             */\n            @Override\n            ///@GlobalTransactional(name = \"fsp-create-order\", rollbackFor = Exception.class)\n            public void create(Order order) {\n                // 1 新建订单\n                log.info(\"----->开始新建订单\");\n                orderDao.create(order);\n        \n                // 2 扣减库存\n                log.info(\"----->订单微服务开始调用库存,做扣减Count\");\n                storageService.decrease(order.getProductId(), order.getCount());\n                log.info(\"----->订单微服务开始调用库存,做扣减End\");\n        \n                // 3 扣减账户\n                log.info(\"----->订单微服务开始调用账户,做扣减Money\");\n                accountService.decrease(order.getUserId(), order.getMoney());\n                log.info(\"----->订单微服务开始调用账户,做扣减End\");\n        \n                // 4 修改订单状态,从0到1,1代表已完成\n                log.info(\"----->修改订单状态开始\");\n                orderDao.update(order.getUserId(), 0);\n        \n                log.info(\"----->下订单结束了,O(∩_∩)O哈哈~\");\n            }\n        }\n        ```\n\n        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n         \n\n    5.   **dao层,也就是接口**\n\n        ```java\n        @Mapper\n        public interface OrderDao {\n            /**\n             * 1 新建订单\n             * @param order\n             * @return\n             */\n            int create(Order order);\n        \n            /**\n             * 2 修改订单状态,从0改为1\n             * @param userId\n             * @param status\n             * @return\n             */\n            int update(@Param(\"userId\") Long userId, @Param(\"status\") Integer status);\n        }\n        ```\n\n         ==在resource下创建mapper文件夹,编写mapper.xml==\n\n        ```xml\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n                \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n        <mapper namespace=\"com.eiletxie.springcloud.alibaba.dao.OrderDao\">\n        \n            <resultMap id=\"BaseResultMap\" type=\"com.eiletxie.springcloud.alibaba.domain.Order\">\n                <id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"></id>\n                <result column=\"user_id\" property=\"userId\" jdbcType=\"BIGINT\"></result>\n                <result column=\"product_id\" property=\"productId\" jdbcType=\"BIGINT\"></result>\n                <result column=\"count\" property=\"count\" jdbcType=\"INTEGER\"></result>\n                <result column=\"money\" property=\"money\" jdbcType=\"DECIMAL\"></result>\n                <result column=\"status\" property=\"status\" jdbcType=\"INTEGER\"></result>\n            </resultMap>\n        \n            <insert id=\"create\" parameterType=\"com.eiletxie.springcloud.alibaba.domain.Order\" useGeneratedKeys=\"true\"\n                    keyProperty=\"id\">\n                insert into t_order(user_id,product_id,count,money,status) values (#{userId},#{productId},#{count},#{money},0);\n            </insert>\n        \n            <update id=\"update\">\n                update t_order set status =1 where user_id =#{userId} and status=#{status};\n           </update>\n        </mapper>\n         \n        ```\n\n    6.   **controller层**\n\n        ```java\n        @RestController\n        public class OrderController {\n            @Resource\n            private OrderService orderService;\n        \n        \n            /**\n             * 创建订单\n             *\n             * @param order\n             * @return\n             */\n            @GetMapping(\"/order/create\")\n            public CommonResult create(Order order) {\n                orderService.create(order);\n                return new CommonResult(200, \"订单创建成功\");\n            }\n        \n        \n        }\n        ```\n\n        \n\n    7.   **entity类(也叫domain类)**\n\n         ```java\n        @Data\n        @AllArgsConstructor\n        @NoArgsConstructor\n        public class CommonResult<T> {\n            private Integer code;\n            private String message;\n            private T data;\n        \n            public CommonResult(Integer code, String message) {\n                this(code, message, null);\n            }\n        }\n         \n        ```\n\n        ![](SpringCloud项目搭建\\seala的12.png)\n\n         \n\n         \n\n        \n\n    8.   config配置类\n\n        ```java\n        @Configuration\n        @MapperScan({\"com.eiletxie.springcloud.alibaba.dao\"})\t\t指定我们的接口的位置\n        public class MyBatisConfig {\n        \n        \n        }\n         \n         \n        \n        ```\n\n        ```java\n        \n        \n        /**\n         * @Author EiletXie\n         * @Since 2020/3/18 21:51\n         * 使用Seata对数据源进行代理\n         */\n        @Configuration\n        public class DataSourceProxyConfig {\n        \n            @Value(\"${mybatis.mapperLocations}\")\n            private String mapperLocations;\n        \n            @Bean\n            @ConfigurationProperties(prefix = \"spring.datasource\")\n            public DataSource druidDataSource() {\n                return new DruidDataSource();\n            }\n        \n            @Bean\n            public DataSourceProxy dataSourceProxy(DataSource druidDataSource) {\n                return new DataSourceProxy(druidDataSource);\n            }\n        \n            @Bean\n            public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception {\n                SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n                bean.setDataSource(dataSourceProxy);\n                ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n                bean.setMapperLocations(resolver.getResources(mapperLocations));\n                return bean.getObject();\n            }\n        }\n         \n         \n        \n        ```\n\n        \n\n    9.   \n\n    10.   \n\n    11.  \n\n      ==库存==,seta-storage-2002\n\n    **==看脑图==**\n\n    1.    pom   \n    2.   配置文件\n    3.   主启动类\n    4.    service层\n    5.    dao层\n    6.    controller层\n    7.   \n    8.   \n\n     \n\n     ==账号==,seta-account-2003\n\n    **==看脑图==**\n\n    1.    pom     \n    2.   配置文件\n    3.   主启动类\n    4.   service层\n    5.    dao层\n    6.   controller层\n    7.   \n    8.   \n\n5.   **全局创建完成后,首先测试不加seata**\n\n     ![](SpringCloud项目搭建\\seala的14.png)\n\n     \n\n     ![](SpringCloud项目搭建\\seala的13.png)\n\n​    \n\n​    \n\n​     \n\n6.   使用seata:\n\n     **在==订单模块==的serviceImpl类中的==create方法==添加启动分布式事务的注解**\n\n     ```java\n    /**\n    \t这里添加开启分布式事务的注解,name指定当前全局事务的名称\n    \trollbackFor表示,发生什么异常需要回滚\n    \tnoRollbackFor:表示,发生什么异常不需要回滚\n    */\n    @GlobalTransactional(name = \"fsp-create-order\",rollbackFor = Exception.class)\n    ///@GlobalTransactional(name = \"fsp-create-order\", rollbackFor = Exception.class)\n    public void create(Order order) {\n        // 1 新建订单\n        log.info(\"----->开始新建订单\");\n        orderDao.create(order);\n    \n        // 2 扣减库存\n        log.info(\"----->订单微服务开始调用库存,做扣减Count\");\n        storageService.decrease(order.getProductId(), order.getCount());\n        log.info(\"----->订单微服务开始调用库存,做扣减End\");\n    \n        // 3 扣减账户\n        log.info(\"----->订单微服务开始调用账户,做扣减Money\");\n        accountService.decrease(order.getUserId(), order.getMoney());\n        log.info(\"----->订单微服务开始调用账户,做扣减End\");\n    \n        // 4 修改订单状态,从0到1,1代表已完成\n        log.info(\"----->修改订单状态开始\");\n        orderDao.update(order.getUserId(), 0);\n    \n        log.info(\"----->下订单结束了,O(∩_∩)O哈哈~\");\n    }\n    \n    ```\n\n     \n\n7.   此时在测试\n\n    发现,发生异常后,直接回滚了,前面的修改操作都回滚了\n\n \n\n\n\n### setat原理:\n\n![](SpringCloud项目搭建\\seala的15.png)\n\n![](SpringCloud项目搭建\\seala的16.png)\n\n\n\n**seata提供了四个模式:**\n\n![](SpringCloud项目搭建\\seala的17.png)\n\n\n\n![](SpringCloud项目搭建\\seala的18.png)\n\n==第一阶段:==\n\n![](SpringCloud项目搭建\\seala的20.png)\n\n​\t![](SpringCloud项目搭建\\seala的19.png)\n\n\n\n\n\n==二阶段之提交==:\n\n![](SpringCloud项目搭建\\seala的21.png)\n\n\n\n==二阶段之回滚:==\n\n![](SpringCloud项目搭建\\seala的22.png)\n\n![](SpringCloud项目搭建\\seala的23.png)\n\n\n\n\n\n\n\n==断点==:\n\n![](SpringCloud项目搭建\\seala的24.png)\n\n**可以看到,他们的xid全局事务id是一样的,证明他们在一个事务下**\n\n\n\n\n\n![](SpringCloud项目搭建\\seala的25.png)\n\n**before 和 after的原理就是**\n\n![](SpringCloud项目搭建\\seala的26.png)\n\n**在更新数据之前,先解析这个更新sql,然后查询要更新的数据,进行保存**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["springcloud"]},{"title":"生产消费者模型","url":"/2020/08/20/JUC/生产消费者模型/","content":"\n\n\n- \n\n\n\n\n\n# 通过上面的题目，思考生产消费者模型是怎么实现的？\n\n### 堵塞队列生消\n\n- 代码(线程去操作资源类，一个消费方法，一个生产方法，搞清楚什么时候生产什么时候消费，其原理也明白了)\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.SynchronousQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 堵塞队列生消\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-23 22:19\n **/\npublic class BlockingQueueDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        //生产一个消费一个\n       // demo1();\n        BlockingQueueResource<String> queueResource = new BlockingQueueResource<>(\n            new SynchronousQueue());\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                queueResource.produce(\"AA\" + i);\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                queueResource.consumer();\n            }\n        }, \"t2\").start();\n\n        //控制生产消费者的中止\n       // TimeUnit.SECONDS.sleep(5);\n        // queueResource.stop();\n    }\n\n\n    private static void demo1() {\n        SynchronousQueue<String> synchronousQueue = new SynchronousQueue<>();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(\"生产一个：\" + Thread.currentThread().getName());\n                    synchronousQueue.put(Thread.currentThread().getName());\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(Thread.currentThread().getName() + \":sleep 3s\");\n                    TimeUnit.SECONDS.sleep(3);\n                    System.out.println(\n                        Thread.currentThread().getName() + \"消费：\" + synchronousQueue.take());\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t2\").start();\n    }\n\n}\n\nclass BlockingQueueResource<T> {\n\n    private BlockingQueue<T> blockingQueue = null;\n    private volatile boolean FLAG = true;\n\n    public BlockingQueueResource(BlockingQueue blockingQueue) {\n        this.blockingQueue = blockingQueue;\n    }\n\n    public boolean produce(T t) {\n        while (FLAG) {\n            try {\n                TimeUnit.SECONDS.sleep(3);\n                boolean result = blockingQueue.offer(t, 2, TimeUnit.SECONDS);\n                System.out.println(\n                    Thread.currentThread().getName()\n                        + \"：blockingQueue 生产\" + t + \" status:\" + result);\n                return result;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"FLAG :\" + FLAG + \",停止生产\");\n        return false;\n    }\n\n    public T consumer() {\n        while (FLAG) {\n            try {\n                T t = blockingQueue.poll(5, TimeUnit.SECONDS);\n                System.out.println(\n                    Thread.currentThread().getName() + \"：取出结果--->\" + t);\n                if (t == null) {\n                    System.out.println(\"超过5s没有消费，模拟退出\");\n                    FLAG = false;\n                }\n                return t;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n        System.out.println(\"FLAG :\" + FLAG + \",停止消费\");\n        return null;\n    }\n    public void stop(){\n        this.FLAG=false;\n    }\n\n\n}\n```\n\n- 结果\n\n```java\nt1：blockingQueue 生产AA0 status:true\nt2：取出结果--->AA0\nt1：blockingQueue 生产AA1 status:true\nt2：取出结果--->AA1\nt1：blockingQueue 生产AA2 status:true\nt2：取出结果--->AA2\nt1：blockingQueue 生产AA3 status:true\nt2：取出结果--->AA3\nt1：blockingQueue 生产AA4 status:true\nt2：取出结果--->AA4\n\nProcess finished with exit code 0\n```\n\n","tags":["JUC"]},{"title":"JUC基础","url":"/2020/08/20/JUC/JUC基础/","content":"\n# JUC\n\n- JUC就是指java.util.concurrent在并发编程中使用的工具类\n\n## 进程和线程\n\n- 进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。\n- 线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。\n\n## 线程的状态\n\n- java.lang.Thread.State\n  - new:为开始start的线程\n  - RUNNABLE:在JVM中运行但是正在等待其他资源操作，自身还没得到调用\n  - BLOCKED：blocked状态就是在等待监视器的(释放)锁时阻塞的线程。\n  - WAITING：由于调用了一下方法处于waiting状态\n    - Object#wait() Object.wait} with no timeout\n    - #join() Thread.join} with no timeout\n    - LockSupport#park() LockSupport.park\n  - TIMED_WAITING:\n    - sleep Thread.sleep\n    - Object#wait(long) Object.wait} with timeout\n    - #join(long) Thread.join} with timeout\n    - LockSupport#parkNanos LockSupport.parkNanos\n    - LockSupport#parkUntil LockSupport.parkUntil\n  - TERMINATED:已经完成执行的线程\n\n```java\nThread.State\n \n \n \npublic enum State {\n    /**\n     * Thread state for a thread which has not yet started.\n     */\n    NEW,(新建)\n\n    /**\n     * Thread state for a runnable thread.  A thread in the runnable\n     * state is executing in the Java virtual machine but it may\n     * be waiting for other resources from the operating system\n     * such as processor.\n     */\n    RUNNABLE,（准备就绪）\n\n    /**\n     * Thread state for a thread blocked waiting for a monitor lock.\n     * A thread in the blocked state is waiting for a monitor lock\n     * to enter a synchronized block/method or\n     * reenter a synchronized block/method after calling\n     * {@link Object#wait() Object.wait}.\n     */\n    BLOCKED,（阻塞）\n\n    /**\n     * Thread state for a waiting thread.\n     * A thread is in the waiting state due to calling one of the\n     * following methods:\n     * <ul>\n     *   <li>{@link Object#wait() Object.wait} with no timeout</li>\n     *   <li>{@link #join() Thread.join} with no timeout</li>\n     *   <li>{@link LockSupport#park() LockSupport.park}</li>\n     * </ul>\n     *\n     * <p>A thread in the waiting state is waiting for another thread to\n     * perform a particular action.\n     *\n     * For example, a thread that has called <tt>Object.wait()</tt>\n     * on an object is waiting for another thread to call\n     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on\n     * that object. A thread that has called <tt>Thread.join()</tt>\n     * is waiting for a specified thread to terminate.\n     */\n    WAITING,（不见不散）\n\n    /**\n     * Thread state for a waiting thread with a specified waiting time.\n     * A thread is in the timed waiting state due to calling one of\n     * the following methods with a specified positive waiting time:\n     * <ul>\n     *   <li>{@link #sleep Thread.sleep}</li>\n     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>\n     *   <li>{@link #join(long) Thread.join} with timeout</li>\n     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>\n     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>\n     * </ul>\n     */\n    TIMED_WAITING,（过时不候）\n\n    /**\n     * Thread state for a terminated thread.\n     * The thread has completed execution.\n     */\n    TERMINATED;(终结)\n}\n```\n\n\n\n![](JUC基础/1.jpg)\n\n\n\n## 线程相关几个方法的比较\n\n1. Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。\n2. Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。\n3. t.join()/t.join(long millis)，当前线程里调用其它线程1的join方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。\n4. obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。\n5. obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。\n\n## wait/sleep的区别？\n\n- wait/sleep功能都是当前线程暂停，有什么区别？\n  - wait释放手里的锁，等待xx时间\n  - sleep持有锁，等待xx时间\n\n## 怎么样写一个单例模式\n\n- 为什么要要用双端加锁？防止并发访问不安全\n- 为什么singletonDemo需要加上volatile？防止指令重排\n\n\n\n```java\npackage com.mk.learn.juc;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-19 22:49\n **/\npublic class SingletonDemo {\n\n    private static volatile SingletonDemo singletonDemo = null;\n\n    private SingletonDemo() {}\n\n    //DCL双端加锁机制\n    public SingletonDemo getInstance() {\n        if (singletonDemo == null) {\n            synchronized (SingletonDemo.class) {\n                if (singletonDemo == null) {\n                    singletonDemo = new SingletonDemo();\n                    return singletonDemo;\n                }\n            }\n        }\n        return singletonDemo;\n    }\n\n}\n\n```\n\n\n\n","tags":["JUC"]},{"title":"多线程锁","url":"/2020/08/20/JUC/多线程锁/","content":"\n\n\n# Synchronized\n\n## Synchronized锁的原理\n\n- 通过查看.class文件的字节码，通过命令 javap -verbose SynchronizedObj.class\n  - 可以看到，我们编译出来的子解码中通过**monitorenter和monitorexit**执行加锁和释放锁的\n\n    - ```JAVA\n      \t\t 4: monitorenter//加锁\n               5: iconst_1\n               6: aload_1\n               7: monitorexit//释放锁\n               8: ireturn\n               9: astore_2\n              10: aload_1\n              11: monitorexit//思考为什么会有二次释放锁?\n      ```\n\n    - 为什么会二次释放锁？catch异常，类似finally的作用，保证锁释放\n\n## 锁的粒度\n\nA 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，\n其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法\n锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法\n\n加个普通方法后发现和同步锁无关\n换成两个对象后，不是同一把锁了，情况立刻变化。\n\nsynchronized实现同步的基础：Java中的每一个对象都可以作为锁。\n具体表现为以下3种形式。\n**对于普通同步方法，锁是当前实例对象。**\n**对于静态同步方法，锁是当前类的Class对象。**\n**对于同步方法块，锁是Synchonized括号里配置的对象**\n\n当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。\n\n也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，\n可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，\n所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。\n\n**所有的静态同步方法用的也是同一把锁——类对象本身，**\n这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。\n但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，\n而不管是同一个实例对象的静态同步方法之间，\n还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！\n\n \n\n- 原文件(内容忽略)\n\n```java\npublic class SynchronizedObj {\n    public int getA() {\n        synchronized (SynchronizedObj.class) {\n            return 1;\n        }\n    }\n}\n```\n\n- javap -verbose SynchronizedObj.class后\n\n```java\nE:\\developProject\\github\\mk_learn\\juc-demo\\target\\classes\\com\\mk\\learn\\juc>javap -verbose SynchronizedObj.class\nClassfile /E:/developProject/github/mk_learn/juc-demo/target/classes/com/mk/learn/juc/SynchronizedObj.class\n  Last modified 2020-8-30; size 482 bytes\n  MD5 checksum 58e3157b30b0053d2519325a88478783\n  Compiled from \"SynchronizedObj.java\"\npublic class com.mk.learn.juc.SynchronizedObj\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #3.#19         // java/lang/Object.\"<init>\":()V\n   #2 = Class              #20            // com/mk/learn/juc/SynchronizedObj\n   #3 = Class              #21            // java/lang/Object\n   #4 = Utf8               <init>\n   #5 = Utf8               ()V\n   #6 = Utf8               Code\n   #7 = Utf8               LineNumberTable\n   #8 = Utf8               LocalVariableTable\n   #9 = Utf8               this\n  #10 = Utf8               Lcom/mk/learn/juc/SynchronizedObj;\n  #11 = Utf8               getA\n  #12 = Utf8               ()I\n  #13 = Utf8               StackMapTable\n  #14 = Class              #20            // com/mk/learn/juc/SynchronizedObj\n  #15 = Class              #21            // java/lang/Object\n  #16 = Class              #22            // java/lang/Throwable\n  #17 = Utf8               SourceFile\n  #18 = Utf8               SynchronizedObj.java\n  #19 = NameAndType        #4:#5          // \"<init>\":()V\n  #20 = Utf8               com/mk/learn/juc/SynchronizedObj\n  #21 = Utf8               java/lang/Object\n  #22 = Utf8               java/lang/Throwable\n{\n  public com.mk.learn.juc.SynchronizedObj();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 9: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/mk/learn/juc/SynchronizedObj;\n\n  public int getA();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: ldc           #2                  // class com/mk/learn/juc/SynchronizedObj\n         2: dup\n         3: astore_1\n         4: monitorenter//加锁\n         5: iconst_1\n         6: aload_1\n         7: monitorexit//释放锁\n         8: ireturn\n         9: astore_2\n        10: aload_1\n        11: monitorexit//思考为什么会有二次释放锁?\n        12: aload_2\n        13: athrow\n      Exception table:\n         from    to  target type\n             5     8     9   any\n             9    12     9   any\n      LineNumberTable:\n        line 12: 0\n        line 13: 5\n        line 14: 9\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      14     0  this   Lcom/mk/learn/juc/SynchronizedObj;\n      StackMapTable: number_of_entries = 1\n        frame_type = 255 /* full_frame */\n          offset_delta = 9\n          locals = [ class com/mk/learn/juc/SynchronizedObj, class java/lang/Object ]\n          stack = [ class java/lang/Throwable ]\n}\nSourceFile: \"SynchronizedObj.java\"  \n```\n\n# Lock接口\n\n## ReentrantLock可重入锁\n\n- 使用：\n\n```java\nclass X {\n   private final ReentrantLock lock = new ReentrantLock();\n   // ...\n \n   public void m() {\n     lock.lock();  // block until condition holds\n     try {\n       // ... method body\n     } finally {\n       lock.unlock()\n     }\n   }\n }\n \n```\n\n\n\n## 创建线程的方法\n\n- 继承Thread\n- 实现Runnable\n- java5以后\n  - 实现callable接口\n  - 使用java的线程池获得\n\n\n\n# synchronized和Condition的用法\n\n## synchronized与Lock的区别 \n\n![](多线程锁/1.bmp)\n\n两者区别：\n1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；\n2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\n3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\n5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\n6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n## 题目1\n\n### 题目1：现在两个线程，可以操作初始值为零的一个变量。实现一个线程对该变量加1，一个线程对该变量-1，\n\n- 实现交替，来10轮，变量初始值为0.\n  - 1.高内聚低耦合前提下，线程操作资源类\n  - 2.判断/干活/通知\n  - 3.防止虚假唤醒(判断只能用while，不能用if)\n  - 知识小总结：多线程编程套路+while判断+新版写法\n\n#### 传统写法synchronized\n\n- 通过synchronized加锁，避免并发执行\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\n/**\n * @program: learning-demo\n * @description: 传统的生产消费模式\n * @author: mk_passby\n * @create: 2020-08-30 18:49\n **/\npublic class TraditionnaDemo0 {\n\n    public static void main(String[] args) {\n        Resource0 resource0 = new Resource0();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    resource0.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"AA\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    resource0.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"BB\").start();\n    }\n\n}\n\nclass Resource0 {\n\n    private int number = 0;\n\n    public synchronized void increment() throws InterruptedException {\n        //1.判断，不等于0，不该我执行\n        while (number != 0) {\n            this.wait();\n        }\n        //2.干活\n        number++;\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n        //3.通知\n        this.notifyAll();\n    }\n\n    public synchronized void decrement() throws InterruptedException {\n        //1.判断，等于0，不该我执行\n        while (number == 0) {\n            this.wait();\n        }\n        //2.干活\n        number--;\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n        //3.通知\n        this.notifyAll();\n    }\n}\n```\n\n- 结果\n\n```java\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\n\nProcess finished with exit code 0\n```\n\n#### 新写法Condition\n\n- 代码\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 生产一个消费一个\n * @program: learning-demo\n * @description: 传统生产消模型\n * @author: mk_passby\n * @create: 2020-07-23 19:56\n **/\npublic class ConditionDemo {\n\n    //交换打印线程\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    resource.increase();\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    resource.decrease();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t2\").start();\n    }\n\n\n}\n\nclass Resource {\n\n    private int number = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    public void increase() throws InterruptedException {\n        lock.lock();\n        try {\n            //不等于0，不该我执行\n            while (number != 0) {\n                condition.await();\n            }\n            number++;\n            System.out.println(Thread.currentThread().getName() + \":number is \" + number);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n\n    public void decrease() throws InterruptedException {\n        lock.lock();\n        try {\n            //不等于1，不该我执行\n            while (number != 1) {\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName() + \":number is \" + number);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n}\n\n```\n\n- 结果\n\n```java\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\n\nProcess finished with exit code 0\n```\n\n\n\n\n\n## 题目2\n\n### 如题目1所示，如果再加入一个线程，需要三个线程有顺序的交替执行，怎么报错\n\n- 代码\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * @program: learning-demo\n * @description: 多个线程交替执行\n * @author: mk_passby\n * @create: 2020-07-23 20:44\n **/\npublic class ConditionDemo1 {\n\n    public static void main(String[] args) {\n        Resource1 resource1 = new Resource1();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                resource1.printT1(i);\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                resource1.printT2(i);\n            }\n        }, \"t2\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                resource1.printT3(i);\n            }\n        }, \"t3\").start();\n    }\n\n}\n\nclass Resource1 {\n\n    private int num;\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n    private Condition condition1 = lock.newCondition();\n    private Condition condition2 = lock.newCondition();\n\n\n    public void printT1(int i) {\n        lock.lock();\n        try {\n            while (num != 0) {\n\n                condition.await();\n\n            }\n            num = 1;\n            System.out.println(Thread.currentThread().getName() + \"：开始执行\"+i);\n            condition1.signal();\n        } catch (Exception e) {\n            System.out.println(e);\n        } finally {\n            lock.unlock();\n        }\n\n    }\n\n    public void printT2(int i) {\n        lock.lock();\n        try {\n            while (num != 1) {\n\n                condition1.await();\n\n            }\n            num = 2;\n            System.out.println(Thread.currentThread().getName() + \"：开始执行\"+i);\n            condition2.signal();\n        } catch (Exception e) {\n            System.out.println(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void printT3(int i) {\n        lock.lock();\n        try {\n            while (num != 2) {\n                condition2.await();\n            }\n            num = 0;\n            System.out.println(Thread.currentThread().getName() + \"：开始执行\"+i);\n            condition.signal();\n        } catch (Exception e) {\n            System.out.println(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n- 结果\n\n```java\nt1：开始执行0\nt2：开始执行0\nt3：开始执行0\nt1：开始执行1\nt2：开始执行1\nt3：开始执行1\nt1：开始执行2\nt2：开始执行2\nt3：开始执行2\nt1：开始执行3\nt2：开始执行3\nt3：开始执行3\nt1：开始执行4\nt2：开始执行4\nt3：开始执行4\n\nProcess finished with exit code 0\n```\n\n## 题目3\n\n### 多线程之间按顺序调用，实现A->B->C，三个线程启动，要求如下：AA打印5次，BB打印10次，CC打印15次\n\n- 参数题目2，自己思考。实现很简单了已经\n\n\n\n# Q&A\n\n## AQS原理\n\n- ReentrantLock源码分析：https://blog.csdn.net/u010452388/article/details/90485326\n- 什么是AQS，是指什么？AbstractQueuedSynchronizer\n\n\n\n## 多线程之间的虚假唤醒是什么？\n\n- 思考为什么多线程里使用while不使用if\n\n## 自己实现一个CAS的场景\n\n- 代码(AtomicInteger),如果是对象使用AtomicReference。\n- 注意CAS不是compareAndSet的意思，而说\n\n```java\npublic class CasDemo {\n\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger=new AtomicInteger(10);\n        System.out.println(\"compareAndSet result:\"+atomicInteger.compareAndSet(10, 100));\n        System.out.println(\"getAtomicInteger:\"+atomicInteger.get());\n        System.out.println(\"compareAndSet result:\"+atomicInteger.compareAndSet(10, 100));\n        System.out.println(\"getAtomicInteger:\"+atomicInteger.get());\n    }\n\n}\n```\n\n- 结果\n\n```java\ncompareAndSet result:true\ngetAtomicInteger:100\ncompareAndSet result:false\ngetAtomicInteger:100\n\nProcess finished with exit code 0\n```\n\n\n\n## ABA问题是什么，怎么解决？\n\n- ABA问题，由于CAS是比较和替换，在期望值为A的情况下，如果过程中该值从A->B->A，最终去比较的时候还是为A，发现不了其被修改过，可能会导致一些业务场景产生问题\n\n- 怎么解决？\n\n  - 引入版本号。类似乐观锁的概念，通过一个版本号做比对\n\n- ABA问题，演示，\n\n  ```java\n  package com.mk.learn.juc.lock.cas;\n  \n  import java.util.concurrent.TimeUnit;\n  import java.util.concurrent.atomic.AtomicReference;\n  import java.util.concurrent.atomic.AtomicStampedReference;\n  \n  /**\n   * @program: learning-demo\n   * @description:\n   * @author: mk_passby\n   * @create: 2020-07-19 22:54\n   **/\n  public class ABADemo {\n  \n      private static AtomicReference<String> atomicReference = new AtomicReference<>(\"AA\");\n      private static AtomicStampedReference<String> atomicStampedReference =\n          new AtomicStampedReference<>(\"AAA\", 1);\n  \n      public static void main(String[] args) {\n          //ABA问题(AAA线程修改内容为BB,在修改为AA，BBB线程执行的时候感知不到过程有修改)\n          new Thread(() -> {\n              atomicReference.compareAndSet(\"AA\", \"BB\");\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + atomicReference.get());\n              atomicReference.compareAndSet(\"BB\", \"AA\");\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + atomicReference.get());\n          }, \"T1\").start();\n          new Thread(() -> {\n              try {\n                  TimeUnit.SECONDS.sleep(1);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              atomicReference.compareAndSet(\"AA\", \"cc\");\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + atomicReference.get());\n          }, \"T2\").start();\n  \n          //AtomicStampedReference\n          new Thread(() -> {\n              atomicStampedReference.compareAndSet(\n                  \"AAA\",\n                  \"BBB\",\n                  1,\n                  2);\n              System.out.println(Thread.currentThread().getName() + \"\\t\"\n                  + atomicStampedReference.getReference());\n              atomicStampedReference.compareAndSet(\n                  \"BBB\",\n                  \"AAA\",\n                  2,\n                  3);\n              System.out.println(Thread.currentThread().getName() + \"\\t\"\n                  + atomicStampedReference.getReference());\n          }, \"T3\").start();\n          new Thread(() -> {\n              try {\n                  TimeUnit.SECONDS.sleep(1);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              atomicStampedReference.compareAndSet(\n                  \"AAA\",\n                  \"CCC\",\n                  1,\n                  4);\n              System.out.println(Thread.currentThread().getName() + \"\\t\"\n                  + atomicStampedReference.getReference());\n          }, \"T4\").start();\n      }\n  \n  }\n  \n  ```\n\n  \n  - 结果如下\n    - T1,T2为ABA问题复现\n      - 1 该代码演示了T1线程执行CAS，将AA修改为BB，然后又将BB修改为AA\n      - 2 T2线程进而去修改CAS，发现可以比对上，修改为了CC。\n    - T3,T4线程为解决ABA问题\n      - 引入了版本号的概念，T4在执行CAS修改值的时候，版本号已经无法匹配，即T4线程修改不成功，解决了ABA问题\n\n  ```java\n  T1\tBB\n  T1\tAA\n  T3\tBBB\n  T3\tAAA\n  T2\tcc\n  T4\tAAA\n  \n  Process finished with exit code 0\n  ```\n\n  \n\n\n\n## 怎么证明synchronized，Lock可重入\n\n- 在synchronize修饰的方法中调用synchronize修饰的方法，可以成功，即为可重入\n\n```java\npackage com.mk.learn.juc.lock;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-20 22:18\n **/\npublic class ReetrantLockDemo {\n\n    public static void main(String[] args) {\n        //synchronized可重入\n        Sport sport = new Sport();\n        new Thread(() -> {\n            sport.walk();\n        }, \"T1\").start();\n        new Thread(() -> {\n            sport.walk();\n        }, \"T2\").start();\n    }\n}\nclass Sport {\n\n    public synchronized void walk() {\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \": walking\");\n        run();\n    }\n\n    public synchronized void run() {\n        System.out.println(Thread.currentThread().getName() + \": running\");\n    }\n}\n```\n\n结果打印：\n\n```java\nT1: walking\nT1: running\nT2: walking\nT2: running\n\nProcess finished with exit code 0\n\n```\n\n\n\n- Lock可重入推荐查看AQS原理中ReentrantLock源码分析，自己思考怎么实现的可重入\n\n\n\n## 写一个死锁的代码\n\n### 怎么定位死锁？\n\n```java\npackage com.mk.learn.juc.lock;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 死锁\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-28 21:12\n **/\npublic class DeadLockDemo {\n\n    public static void main(String[] args) {\n        DeadLock deadLock = new DeadLock();\n\n        new Thread(() -> {\n            deadLock.getA();\n        }, \"A\").start();\n        new Thread(() -> {\n            deadLock.getB();\n        }, \"B\").start();\n\n\n    }\n}\n\nclass DeadLock {\n\n    private Object a = new Object();\n    private Object b = new Object();\n\n    public Object getA() {\n        synchronized (b) {\n            try {\n                System.out.println(Thread.currentThread().getName() + \"\\t持有\" + b + \",想要获得\" + a);\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (a) {\n                System.out.println(Thread.currentThread().getName() + \"\\t持有\" + a);\n            }\n            return a;\n        }\n    }\n\n    public Object getB() {\n        synchronized (a) {\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (b) {\n                System.out.println(Thread.currentThread().getName() + \"\\t持有\" + b);\n            }\n            return b;\n        }\n\n    }\n\n}\n```\n\n\n\n## 手写一个自旋锁\n\n- 什么是自旋锁？怎么理解？\n  - 自己在那里一直循环，知道满足条件为止。\n- 为什么用while不用if？\n  - 并发情况下，都不用if，用while。如果用if判断，当线程执行到if条件判断之后被挂起了，然后等到执行时，if条件已经不满足了。但是判定逻辑已经走过了，这样会继续执行if内的代码，导致数据结果错乱。用while每次被唤醒时都会先检查条件是否满足再继续。\n\n\n```java\npackage com.mk.learn.juc.lock;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * 自旋锁：循环比较获取直到成功为止,没有类似wait的阻塞\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-20 22:34\n **/\npublic class SpinLockDemo {\n\n    AtomicReference<Thread> atomicReference = new AtomicReference<>();\n\n    public void getLock() {\n        System.out.println(Thread.currentThread().getName() + \":try get lock\");\n\n        while (!atomicReference.compareAndSet(null, Thread.currentThread())) {\n        }\n    }\n\n    public void unLock() {\n        System.out.println(Thread.currentThread().getName() + \":release Lock\");\n        while (!atomicReference.compareAndSet(Thread.currentThread(), null)) {\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SpinLockDemo demo = new SpinLockDemo();\n        new Thread(() -> {\n            demo.getLock();\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            demo.unLock();\n        }, \"t1\").start();\n        TimeUnit.SECONDS.sleep(1);\n        new Thread(() -> {\n            demo.getLock();\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            demo.unLock();\n        }, \"t2\").start();\n    }\n\n}\n\n```\n\n\n\n\n\n\n\n# 所有代码示例在github均可找到\n\n- 位置：https://github.com/mk-passby/mk_learn/tree/master/juc-demo/src/main/java/com/mk/learn/juc\n\n","tags":["JUC"]},{"title":"jvm常见问题","url":"/2020/08/20/JVM/jvm常见问题总结/","content":"\n#### JVM问题\n\n##### 1.默认内存大小？如何证明？\n\n​\t最小物理内存的1/64，最大物理内存的1/4，\n\n​\t通过指令查看：\n\n- Windows：java -XX:+PrintFlagsFinal -version | findstr  HeapSize\n- Linux：java -XX:+PrintFlagsFinal -version | grep HeapSize\n\n##### 2.堆为什么分新生代/老年代，为什么新生代1/3，老年代2/3？\n\n- 1.方便垃圾回收，新生代会频繁GC。\n- 2.老年代肯定比新生代大，Eden区90%的对象在第一次GC就被\n\n##### 3.为什么新生代老年代比例是1：2\n\n##### 4.为什么新生代要分三个区，且Eden，From，To为什么是8:1:1？\n\n​\t由于对象的生命周期不一样，出现了分代\n\n​\t基于一个经验值，根据统计调查发现Eden区90%~95%的对象在第一次GC就被回收掉，如果eden设置过低，会导致内存浪费\n\n##### 5.新生代的三个区是如何协同工作的？新生代是如何转移到老年代的\n\n- 1.对象首先在Eden中分配，如果eden中没有足够的空间会触发一次MinorGC。当Minor GC结束后，Eden区会被清空，存活的对象放入survivor中，且对象年龄计算器(Age)+1，当survivor中放不下，分配担保进入老年代中。\n\n##### 6.什么样的对象会进入老年代\n\n- 1.大对象，虚拟机提供了一个-XX:PretenureSizeThreshold参数(字节大小可以设分配到新生代对象的大小限制)，大于这个值的参数会直接在老年代分配。-XX:PretenureSizeThreshold默认值是0，即对象的大小超过Eden区的对象，直接进入老年代\n- 2.GC年龄超过15次还存活的对象\n- 3.空间分配担保的对象\n\n","tags":["jvm"]},{"title":"springcloud版本选型","url":"/2020/08/01/框架系列/springcloud/springcloud_1.版本选型/","content":"\n\n\n## Springboot版本选择\n\n- [SPRING-BOOT-git地址](https://github.com/spring-projects/spring-boot/releases/)\n\n- [SPRING-BOOT2.0新特性](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes)\n\n  ```properties\n  Spring Boot 2.0 Release Notes\n  Phillip Webb edited this page on 8 Jun · 1 revision\n  Upgrading from Spring Boot 1.5\n  Since this is a major release of Spring Boot, upgrading existing applications can be a little more involved that usual. We’ve put together a dedicated migration guide to help you upgrade your existing Spring Boot 1.5 applications.\n  \n  If you’re currently running with an earlier version of Spring Boot, we strongly recommend that you upgrade to Spring Boot 1.5 before migrating to Spring Boot 2.0.\n  ```\n\n  \n\n  ​\t**官方已建议springboot从1.5升级到2.0**\n\n## Springcloud版本选择\n\n- [springcloud-git地址](https://github.com/spring-projects/spring-cloud/wiki)\n\n- [springcloud 官网](https://spring.io/projects/spring-cloud)\n\n  ![](springcloud_1.版本选型\\clound官网.png)\n\n选择[Reference Doc.](https://docs.spring.io/spring-cloud/docs/Hoxton.SR7/reference/html/),如下:\n\n![](springcloud_1.版本选型\\cloudversion.png)\n\n\n\n\n\n## 更多查看springboot和springcloud方法\n\n[https://start.spring.io/actuator/info](https://start.spring.io/actuator/info)\n\n结果如下,查询结果是一个json串，如下所示\n\n```json\n{\"git\":{\"branch\":\"58cb6bccc1be3cdbe108a4609797c53010545926\",\"commit\":{\"id\":\"58cb6bc\",\"time\":\"2020-08-21T06:52:21Z\"}},\"build\":{\"version\":\"0.0.1-SNAPSHOT\",\"artifact\":\"start-site\",\"versions\":{\"spring-boot\":\"2.3.3.RELEASE\",\"initializr\":\"0.9.2-SNAPSHOT\"},\"name\":\"start.spring.io website\",\"time\":\"2020-08-21T07:23:55.515Z\",\"group\":\"io.spring.start\"},\"bom-ranges\":{\"azure\":{\"2.0.10\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.RELEASE\",\"2.1.10\":\"Spring Boot >=2.1.0.RELEASE and <2.2.0.M1\",\"2.2.4\":\"Spring Boot >=2.2.0.M1 and <2.3.0.M1\",\"2.3.1\":\"Spring Boot >=2.3.0.M1\"},\"codecentric-spring-boot-admin\":{\"2.0.6\":\"Spring Boot >=2.0.0.M1 and <2.1.0.M1\",\"2.1.6\":\"Spring Boot >=2.1.0.M1 and <2.2.0.M1\",\"2.2.4\":\"Spring Boot >=2.2.0.M1 and <2.3.0.M1\",\"2.3.0\":\"Spring Boot >=2.3.0.M1 and <2.4.0-M1\"},\"solace-spring-boot\":{\"1.0.0\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\",\"1.1.0\":\"Spring Boot >=2.3.0.M1\"},\"solace-spring-cloud\":{\"1.0.0\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\",\"1.1.1\":\"Spring Boot >=2.3.0.M1\"},\"spring-cloud\":{\"Finchley.M2\":\"Spring Boot >=2.0.0.M3 and <2.0.0.M5\",\"Finchley.M3\":\"Spring Boot >=2.0.0.M5 and <=2.0.0.M5\",\"Finchley.M4\":\"Spring Boot >=2.0.0.M6 and <=2.0.0.M6\",\"Finchley.M5\":\"Spring Boot >=2.0.0.M7 and <=2.0.0.M7\",\"Finchley.M6\":\"Spring Boot >=2.0.0.RC1 and <=2.0.0.RC1\",\"Finchley.M7\":\"Spring Boot >=2.0.0.RC2 and <=2.0.0.RC2\",\"Finchley.M9\":\"Spring Boot >=2.0.0.RELEASE and <=2.0.0.RELEASE\",\"Finchley.RC1\":\"Spring Boot >=2.0.1.RELEASE and <2.0.2.RELEASE\",\"Finchley.RC2\":\"Spring Boot >=2.0.2.RELEASE and <2.0.3.RELEASE\",\"Finchley.SR4\":\"Spring Boot >=2.0.3.RELEASE and <2.0.999.BUILD-SNAPSHOT\",\"Finchley.BUILD-SNAPSHOT\":\"Spring Boot >=2.0.999.BUILD-SNAPSHOT and <2.1.0.M3\",\"Greenwich.M1\":\"Spring Boot >=2.1.0.M3 and <2.1.0.RELEASE\",\"Greenwich.SR6\":\"Spring Boot >=2.1.0.RELEASE and <2.1.17.BUILD-SNAPSHOT\",\"Greenwich.BUILD-SNAPSHOT\":\"Spring Boot >=2.1.17.BUILD-SNAPSHOT and <2.2.0.M4\",\"Hoxton.SR7\":\"Spring Boot >=2.2.0.M4 and <2.3.4.BUILD-SNAPSHOT\",\"Hoxton.BUILD-SNAPSHOT\":\"Spring Boot >=2.3.4.BUILD-SNAPSHOT and <2.4.0.M1\",\"2020.0.0-SNAPSHOT\":\"Spring Boot >=2.4.0.M1\"},\"spring-cloud-alibaba\":{\"2.2.1.RELEASE\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\"},\"spring-cloud-services\":{\"2.0.3.RELEASE\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.RELEASE\",\"2.1.7.RELEASE\":\"Spring Boot >=2.1.0.RELEASE and <2.2.0.RELEASE\",\"2.2.3.RELEASE\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\"},\"spring-statemachine\":{\"2.0.0.M4\":\"Spring Boot >=2.0.0.RC1 and <=2.0.0.RC1\",\"2.0.0.M5\":\"Spring Boot >=2.0.0.RC2 and <=2.0.0.RC2\",\"2.0.1.RELEASE\":\"Spring Boot >=2.0.0.RELEASE\"},\"vaadin\":{\"10.0.17\":\"Spring Boot >=2.0.0.M1 and <2.1.0.M1\",\"14.3.3\":\"Spring Boot >=2.1.0.M1 and <2.4.0-M1\"},\"wavefront\":{\"2.0.0\":\"Spring Boot >=2.1.0.RELEASE\"}},\"dependency-ranges\":{\"okta\":{\"1.2.1\":\"Spring Boot >=2.1.2.RELEASE and <2.2.0.M1\",\"1.4.0\":\"Spring Boot >=2.2.0.M1 and <2.4.0-M1\"},\"mybatis\":{\"2.0.1\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.RELEASE\",\"2.1.3\":\"Spring Boot >=2.1.0.RELEASE and <2.4.0-M1\"},\"geode\":{\"1.2.9.RELEASE\":\"Spring Boot >=2.2.0.M5 and <2.3.0.M1\",\"1.3.3.RELEASE\":\"Spring Boot >=2.3.0.M1 and <2.4.0-M1\",\"1.4.0-M2\":\"Spring Boot >=2.4.0-M1\"},\"camel\":{\"2.22.4\":\"Spring Boot >=2.0.0.M1 and <2.1.0.M1\",\"2.25.2\":\"Spring Boot >=2.1.0.M1 and <2.2.0.M1\",\"3.3.0\":\"Spring Boot >=2.2.0.M1 and <2.3.0.M1\",\"3.4.3\":\"Spring Boot >=2.3.0.M1 and <2.4.0-M1\"},\"open-service-broker\":{\"2.1.3.RELEASE\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.M1\",\"3.0.4.RELEASE\":\"Spring Boot >=2.1.0.M1 and <2.2.0.M1\",\"3.1.1.RELEASE\":\"Spring Boot >=2.2.0.M1 and <2.4.0-M1\"}}}\n\n```\n\n\n\n\n\n转换工具转换后：\n\n\n\n![转换后](springcloud_1.版本选型\\jsonVersion.png)\n\n\n\n## springcloud组件升级\n\nspringcloud停更，官网说明，不再发布新版本，不再接受合并请求\n\n| 组件    | 组件名  |  替换方案|\n|--------|--------|---------|\n|服务注册中心     | ~~Eureka(停更)~~ | Zookeeper/Consul/Nacos |\n|服务调用 | Ribbon | LoadBalancer |\n|服务调用2 | ~~Feign(停更)~~ | OpenFeign |\n|服务降级 | ~~Hystrix(停更)~~ | sentinel/resilience4j |\n|服务网关 | ~~Zuul(停更)~~ | gateway/Zuul2 |\n|服务配置 | ~~Config(停更)~~ | Nacos |\n|服务总线 | ~~Bus(停更)~~ | Nacos |\n| |  |  |\n\n\n\n## 补充，为避免版本差异所有总结均基于以下版本\n\n| 应用                | 版本          |\n| ------------------- | ------------- |\n| springcloud         | Hoxton.SR1    |\n| springboot          | 2.2.2.RELEASE |\n| springcloud alibaba | 2.1.0.RELEASE |\n| java                | 1.8           |\n| mysql               | 5.7(及以上)   |\n\n","tags":["springcloud"]},{"title":"JUC辅助类讲解","url":"/2020/07/25/JUC/JUC辅助类讲解/","content":"\n## CountDownLatch减少计数\n\n### 原理\n\n- CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。\n\n * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，\n * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。\n\n### 代码演示如下\n\n- t10打印“done”的await()和main方法await()需要等待其他线程执行完成后再打印\n\n```java\npackage com.mk.learn.juc.concureenttools;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-21 21:57\n **/\npublic class CountDownLatchDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch = new CountDownLatch(5);\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \" is running\");\n            try {\n                countDownLatch.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \" done\");\n        }, \"t10\").start();\n        for (int i = 0; i <5 ; i++) {\n            TimeUnit.SECONDS.sleep(2);\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + \" is running\");\n                countDownLatch.countDown();\n                System.out.println(Thread.currentThread().getName() + \" done\");\n            }, \"t\"+i).start();\n\n        }\n        countDownLatch.await();\n        System.out.println(\"end-----------------\");\n\n    }\n}\n```\n\n- 结果如下\n\n```java\nt10 is running\nt0 is running\nt0 done\nt1 is running\nt1 done\nt2 is running\nt2 done\nt3 is running\nt3 done\nt4 is running\nt4 done\nt10 done\nend-----------------\n\nProcess finished with exit code 0\n```\n\n## CyclicBarrier循环栅栏\n\n### 原理\n\n * CyclicBarrier\n * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，\n * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，\n * 直到最后一个线程到达屏障时，屏障才会开门，所有\n * 被屏障拦截的线程才会继续干活。\n * 线程进入屏障通过CyclicBarrier的await()方法。\n\n### 代码演示\n\n- 代码\n\n```java\npackage com.mk.learn.juc.concureenttools;\n\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 循环屏障，所有的线程都到达后会一起唤醒\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-21 22:44\n **/\npublic class CyclicBarrierDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        CyclicBarrier cyclicBarrier=new CyclicBarrier(5);\n        for (int i = 0; i <10 ; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName()+\":come in\");\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName()+\":end\");\n            }, \"t\"+i).start();\n        }\n    }\n\n}\n\n```\n\n\n\n- 结果\n\n```java\nt0:come in\nt1:come in\nt2:come in\nt3:come in\nt4:come in\nt4:end\nt0:end\nt1:end\nt2:end\nt3:end\nt5:come in\nt6:come in\nt7:come in\nt8:come in\nt9:come in\nt9:end\nt5:end\nt6:end\nt7:end\nt8:end\n```\n\n\n\n## Semaphore信号灯\n\n### 原理\n\n 在信号量上我们定义两种操作：\n * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），\n *       要么一直等下去，直到有线程释放信号量，或超时。\n * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。\n * \n * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\n\n\n### 代码演示\n\n- 代码(该例子模拟停车，停一段时间后离开，代码可以通过调整停车的时间(sleep的时间)，这样更能看出semaphore的效果)\n\n```java\npackage com.mk.learn.juc.concureenttools;\n\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 信号量，表示只能允许多少个线程同时运行(并发线程数的控制)\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-21 22:55\n **/\npublic class SemaphoreDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i < 7; i++) {\n            new Thread(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName()+\":进入，占用3秒\" );\n                    TimeUnit.SECONDS.sleep(3);\n                    System.out.println(Thread.currentThread().getName() + \":离开\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release();\n                }\n            }, \"t\" + i).start();\n        }\n    }\n}\n\n```\n\n\n\n- 结果\n\n```java\nt0:进入，占用3秒\nt2:进入，占用3秒\nt1:进入，占用3秒\nt0:离开\nt2:离开\nt3:进入，占用3秒\nt1:离开\nt4:进入，占用3秒\nt5:进入，占用3秒\nt3:离开\nt4:离开\nt5:离开\nt6:进入，占用3秒\nt6:离开\n```\n\n## 代码位置\n\n- github:\n\nhttps://github.com/mk-passby/mk_learn/tree/master/juc-demo/src/main/java/com/mk/learn/juc/concureenttools","tags":["JUC"]},{"title":"不安全集合","url":"/2020/07/20/JUC/不安全集合/","content":"\n## 多线程环境下不安全集合类\n\n- 这些集合包括我们常用的ArrayList，HashMap，StringBuilder等等\n\n### 不安全是指什么\n\n- ArrayList在迭代的时候如果同时对其进行修改就会\n  抛出java.util.ConcurrentModificationException异常\n  并发修改异常\n- 代码验证\n\n```java\npackage com.mk.learn.juc.thread;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-30 22:31\n **/\npublic class UnSafeDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        List<Double> list = new ArrayList<>();\n        //线程不安全\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                list.add(Math.random() * 1000);\n                System.out.println(list);\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n\n```\n\n- 结果\n\n```java\nException in thread \"4\" Exception in thread \"3\" Exception in thread \"2\" Exception in thread \"0\" java.util.ConcurrentModificationException\n\tat java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)\n\tat java.util.ArrayList$Itr.next(ArrayList.java:851)\n\tat java.util.AbstractCollection.toString(AbstractCollection.java:461)\n\tat java.lang.String.valueOf(String.java:2994)\n\tat java.io.PrintStream.println(PrintStream.java:821)\n\tat com.mk.learn.juc.thread.UnSafeDemo.lambda$main$0(UnSafeDemo.java:28)\n\tat java.lang.Thread.run(Thread.java:748)\n\n```\n\n### ArrayList不安全，那么怎么解决呢\n\n#### Vector\n\n- 看Vector的源码，有synchronized修饰线程安全\n\n```java\n   public synchronized boolean add(E e) {\n        modCount++;\n        ensureCapacityHelper(elementCount + 1);\n        elementData[elementCount++] = e;\n        return true;\n    }\n```\n\n#### Collections\n\n```java\nList<String> list = Collections.synchronizedList(new ArrayList<>());\n```\n\nCollections提供了方法synchronizedList保证list是同步线程安全的\n\n```java\n public static <T> List<T> synchronizedList(List<T> list) {\n        return (list instanceof RandomAccess ?\n                new SynchronizedRandomAccessList<>(list) :\n                new SynchronizedList<>(list));\n    }\n```\n\n\n\n#### 写时复制\n\n```java\nList<String> list = new CopyOnWriteArrayList<>();\n```\n\n- CopyOnWriteArrayList是arraylist的一种线程安全变体，\n  其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。\n\n- CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，\n  而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。\n  添加元素后，再将原容器的引用指向新的容器setArray(newElements)。\n  这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。\n- CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。\n\n### 扩展对比\n\n#### SET\n\n- Set<String> set = new HashSet<>();//线程不安全\n\n- Set<String> set = new CopyOnWriteArraySet<>();//线程安全\n\n#### HASHMAP\n\n- Map<String,String> map = new HashMap<>();//线程不安全\n\n- Map<String,String> map = new ConcurrentHashMap<>();//线程安全","tags":["JUC"]},{"title":"Callable接口","url":"/2020/07/20/JUC/Callable接口/","content":"\n## Callable是什么\n\n### 获得多线程的方法几种\n\n- 传统的是继承thread类和实现runnable接口\n- java5以后又有实现callable接口和java的线程池获得\n\n```java\npublic class ThreadDemo {\n\n    public static void main(String[] args) {\n        new Thread1().start();\n        new Thread(new Runnable1()).start();\n        FutureTask task = new FutureTask(new Callable1());\n        new Thread(task).start();\n    }\n}\n\nclass Thread1 extends Thread {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread1 start\");\n    }\n}\n\n\nclass Runnable1 implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread2 start\");\n    }\n}\n\nclass Callable1 implements Callable<Integer> {\n\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + \"Thread3 start\");\n        return 0;\n    }\n}\n```\n\n- 结果\n\n```java\nThread-0Thread1 start\nThread-1Thread2 start\nThread-2Thread3 start\n\nProcess finished with exit code 0\n```\n\n\n\n### 与runnable对比\n\n       （1）是否有返回值\n       （2）是否抛异常\n       （3）落地方法不一样，一个是run，一个是call\n```java\nclass MyThread2 implements Callable<Integer>{\n @Override\n public Integer call() throws Exception {\n  return 200;\n } \n}\n```\n\n### 如何获得返回值\n\n- FutureTask.get()\n\n```java\n        FutureTask task = new FutureTask(new Callable1());\n        new Thread(task).start();\n        System.out.println(task.get());\n```\n\n## FutureTask\n\n### 原理\n\n- 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，\n  当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。\n\n  一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。\n\n  仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，\n  就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，\n  然后会返回结果或者抛出异常。 \n\n  只计算一次\n  get方法放到最后\n\n### 验证get 方法阻塞 \n\n- 这个验证就很简单了，在线程里阻塞几秒后，在返回结果，即可查看到\n\n```java\npublic class ThreadDemo {\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        new Thread1().start();\n        new Thread(new Runnable1()).start();\n        FutureTask task = new FutureTask(new Callable1());\n        new Thread(task).start();\n        System.out.println(task.get());\n    }\n}\n\nclass Thread1 extends Thread {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread1 start\");\n    }\n}\n\n\nclass Runnable1 implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread2 start\");\n    }\n}\n\nclass Callable1 implements Callable<Integer> {\n\n    @Override\n    public Integer call() throws Exception {\n        TimeUnit.SECONDS.sleep(5);\n        System.out.println(Thread.currentThread().getName() + \"Thread3 start\");\n        return 0;\n    }\n}\n```\n\n\n\n- 通过控制台可以看到Thread-0Thread1 start和Thread-1Thread2 start很快就打印出来了，但是FutureTask显示sleep了几秒才返回","tags":["JUC"]},{"title":"常见算法排序","url":"/2020/03/29/算法/常见算法排序/","content":"\n\n[TOC]\n\n\n\n#  一、插入排序\n\n**思路**\n\n对于未排序的数据，从第1位从后往前扫描，取出元素，和前面的元素对比，若当前元素小于前一元素，则将前一元素后移，当前元素继续与前两个位置的元素比较，直到找出大于或等于的元素位置，将该元素插入到对应位置\n\n```java\nprivate static int[] insertSort(int[] a) {\n        for (int i = 1; i < a.length; i++) {\n            int temp = a[i];\n            int tempIndex = i;\n            while (tempIndex > 0 && temp < a[tempIndex-1]) {\n                a[tempIndex] = a[tempIndex-1];\n                tempIndex--;\n            }\n            a[tempIndex] = temp;\n        }\n        return a;\n    }\n```\n\n![插入排序](常见算法排序/插入排序.gif)\n\n\n\n# 个人简介\n\n## 二、希尔(Shell )排序\n\n**思路**\n\n将整个待排序序列分成若干个子序列分别进行直接插入排序\n\n- 选择一个增量Tn，其中Tn>1\n- 按增量序列数n，对序列进行n趟排序\n- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n**代码**\n\n<s>待补充</s>\n\n\n\n**动图**\n\n ![希尔排序](常见算法排序/希尔排序.gif)\n\n\n## 三、选择排序\n\n**思路：**\n\n全部遍历找到最小值与第0个元素交换，再从第一个位置开始往后找到最小的，与第1个元素交换，再从第二个位置开始往后找到最小的与第2个元素交换，直到选到最后一个元素\n\n**代码**\n\n```java\n private static int[] selectedSort(int[] a) {\n        for (int i = 0; i < a.length - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < a.length; j++) {\n                if (a[minIndex] > a[j]) {\n                    minIndex = j;\n                }\n            }\n            int temp = a[i];\n            a[i] = a[minIndex];\n            a[minIndex] = temp;\n        }\n        return a;\n    }\n```\n\n**动图**\n\n![快速排序](常见算法排序/选择排序.gif)\n\n\n\n## 四、堆排序\n\n**动图**\n\n![快速排序](常见算法排序/堆排序.gif)\n\n## 五、冒泡排序\n\n**思路**\n\n\n**动图**\n\n![快速排序](常见算法排序/冒泡排序.gif)\n\n\n## 六、快速排序\n\n\n**动图**\n\n![快速排序](常见算法排序/快速排序.gif)\n\n\n## 七、归并排序\n\n**动图**\n\n![快速排序](常见算法排序/归并排序.gif)\n\n## 八、计数排序\n\n\n**动图**\n\n![快速排序](常见算法排序/计数排序.gif)\n## 九、桶排序\n\n**动图**\n\n![快速排序](常见算法排序/桶排序.png)\n\n## 十、基数排序\n\n**动图**\n\n![快速排序](常见算法排序/基数排序.gif)\n","tags":["算法"]},{"title":"算法复杂度","url":"/2020/03/29/算法/算法复杂度/","content":"\n\n\n# 算法复杂度\n\n## 1.怎么分析算法复杂度\n\n#### 一、时间复杂度\n\n所有代码的**执行时间 T(n)** 与每行代码的**执行次数 n** 成正比.\n\n\n```math\nT(n)=O(f(n))\n```\n\n\n- T(n)：所有代码执行的总时间\n- n：数据规模大小\n- f(n)：每行代码执行的次数总和\n\n----\n\n**时间复杂度分析**\n\n- 关注循环次数最多的一段代码\n  - 通常会忽略常熟，系数等，只记录最大的一个量级即可\n  - 只关注执行次数最多的一段代码即可\n  \n- 加法法则：总的时间复杂度等于量级最大的代码的时间复杂度\n  \n  - 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))\n  \n- 乘法法则：嵌套代码的复杂度等于嵌套代码内外复杂度的乘积\n  \n  - 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么 T1(n)*T2(n)=O(f(n)) * O(g(n))=O(f(n)*g(n)) 也就是说，假设T1(n)=O(n),T2(n)=O(n^2)，则有T1(n) * T2(n)=O(n^3)\n  \n  \n  **例:**\n  \n  ```java\n   public int getSum(int n){\n          int sum=0;\n          for (int i = 1; i <= n; i++) {\n              sum+=i;\n          }\n          return sum;\n          \n      }\n  ```\n  \n  结论：常量级第二行不考虑，执行次数最多的是for循环，所以时间复杂度为O(n)\n  \n#### 二、空间复杂度\n\n\n- 空间复杂度：表示算法的**存储空间**与**数据规模**之间的增长关系\n\n**例：**\n\n```java\n public int getSum(int n){\n        int sum=0;\n        int[] a=new int[n];\n        for (int i = 1; i <= a.length; i++) {\n            sum+=i;\n        }\n        return sum;\n\n    }\n```\n\n结论：int sum=0为常量阶，可以忽略，其余的仅int[] a=new int[n]申请了内存，所以空间复杂度为O(n)\n\n#### 3）算法稳定性\n\n假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的\n\n## 2.最好，最坏，平均，均摊时间复杂度\n\n- 最好时间复杂度：最好情况的时间复杂度\n- 最坏时间复杂度：最坏情况的时间复杂度\n- 平均时间复杂度：将所有情况用加权平均值表示，通常没说权值默认是均分，即除以情况种数\n- 均摊时间复杂度：在代码执行的所有复杂度情况中，大部分情况下时间复杂度都很低，只有极个别情况下的时间复杂度比较高，而且发生具有**前后连贯的时序关系**时，可以将个别高级别复杂度均摊到低级别复杂度上。均摊结果一般都等于**低级别复杂度**\n\n# 3.常见的时间复杂度\n\n![时间复杂度](算法复杂度/1.png)","tags":["算法"]},{"title":"springmvc分析","url":"/2020/03/27/框架系列/springMVC/springMVC/","content":"\n# 官网文档\n\nhttps://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html\n\nspring所有官方文档均可以通过此方式找到\n\n# 架构图\n\n![1587994841538](springMVC\\springMVC架构图1.png)\n\n\n\n- 由图中可以看到，DispatcherServlet中又分了Servlet WebApplicationContext和Root WebApplicationContext，且Servlet WebApplicationContext属于上层，if no bean found，才去找root。\n\n  - **Root WebApplicationContext**对应ContextLoaderListener(extends ServletContextListener)创建，对应**spring应用**\n\n  **源码ContextLoaderListener.java**\n\n  ```java\n  \n  public void contextInitialized(ServletContextEvent event) {\n          this.initWebApplicationContext(event.getServletContext());\n      }\n  ```\n\n  ```java\n   public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n          if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n              throw new IllegalStateException(\"Cannot initialize context because there is already a root application context present - check whether you have multiple ContextLoader* definitions in your web.xml!\");\n          } else {\n              .....\n          }\n      }\n  ```\n\n  \n\n  - **Servlet WebApplicationContext**对应为DispatcherServlet，对应**springmvc应用**\n\n    源码如下RequestContextUtils.java\n\n    ```java\n    public static WebApplicationContext findWebApplicationContext(\n    \t\t\tHttpServletRequest request, @Nullable ServletContext servletContext) {\n    \n    \t\tWebApplicationContext webApplicationContext = (WebApplicationContext) request.getAttribute(\n    \t\t\t\tDispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n    \t\tif (webApplicationContext == null) {\n    \t\t\tif (servletContext != null) {\n    \t\t\t\twebApplicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n    \t\t\t}\n    \t\t\tif (webApplicationContext == null) {\n    \t\t\t\twebApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n    \t\t\t}\n    \t\t}\n    \t\treturn webApplicationContext;\n    \t}\n    ```\n\n    \n\n\n\n![](springMVC\\springMVC架构图.png)\n\n\n\n## 关键类\n\norg.springframework.web.servlet.DispatcherServlet类关系图\n\n![sss](springMVC\\DispatcherServlet.png)\n\n\n\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration自动装配\n\norg.springframework.boot.autoconfigure.web.servlet.WebMvcProperties配置类(springboot中可以通过这些参数设置springpropoties文件中)\n\n\n\n\n\n### 基于javaconfig\n\nBelow is an example of the Java configuration that registers and initializes the `DispatcherServlet`. This class is auto-detected by the Servlet container (see [Code-based, Servlet container initialization](https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-container-config)):\n\n```\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n  @Override\n  public void onStartup(ServletContext servletCxt) {\n\n    // Load Spring web application configuration\n    AnnotationConfigWebApplicationContext cxt = new AnnotationConfigWebApplicationContext();\n    cxt.register(AppConfig.class);\n    cxt.refresh();\n\n    // Create DispatcherServlet\n    DispatcherServlet servlet = new DispatcherServlet(cxt);\n\n    // Register and map the Servlet\n    ServletRegistration.Dynamic registration = servletCxt.addServlet(\"app\", servlet);\n    registration.setLoadOnStartup(1);\n    registration.addMapping(\"/app/*\");\n  }\n\n}\n```\n\n### 基于web.xml\n\nBelow is an example of `web.xml` configuration to register and initialize the `DispatcherServlet`:\n\n```\n<web-app>\n\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>/WEB-INF/app-context.xml</param-value>\n  </context-param>\n\n  <servlet>\n    <servlet-name>app</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value></param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n\n  <servlet-mapping>\n    <servlet-name>app</servlet-name>\n    <url-pattern>/app/*</url-pattern>\n  </servlet-mapping>\n\n</web-app>\n```\n\n\n\n\n\n## 整体流程\n\nrequest--》Handler--》结果--》返回--》文本\n\n根据请求的 URL，寻找匹配的Handler，处理数据，返回结果\n\nRequestUrl=servletContext+requestMapping\n\n#### 请求处理映射\n\nRequestMappingHandlerMapping.java类处理\n\n```java\nMap<RequestMappingInfo, HandlerMethod> handlerMethods =requestMappingHandlerMapping.getHandlerMethods();\n```\n\n这个方法可以获取所有类中被@RequestMapping标注过的方法的对象\n\n#### 拦截器\n\n- 实现HandlerInterceptor接口\n\n- 继承`HandlerInterceptorAdapter` \n\nspring官网如下解释，更推荐使用`HandlerInterceptorAdapter` \n\n```\nAs you can see, the Spring adapter class HandlerInterceptorAdapter makes it easier to extend the HandlerInterceptor interface.\n```\n\n\n\n This is shown in the example below:\n\n```xml\n<beans>\n        <bean id=\"handlerMapping\"\n                        class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\">\n                <property name=\"interceptors\">\n                        <list>\n                                <ref bean=\"officeHoursInterceptor\"/>\n                        </list>\n                </property>\n        </bean>\n\n        <bean id=\"officeHoursInterceptor\"\n                        class=\"samples.TimeBasedAccessInterceptor\">\n                <property name=\"openingTime\" value=\"9\"/>\n                <property name=\"closingTime\" value=\"18\"/>\n        </bean>\n</beans>\n```\n\n\n\n\n\n```java\npackage samples;\n\npublic class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {\n\n        private int openingTime;\n        private int closingTime;\n\n        public void setOpeningTime(int openingTime) {\n                this.openingTime = openingTime;\n        }\n\n        public void setClosingTime(int closingTime) {\n                this.closingTime = closingTime;\n        }\n\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response,\n                        Object handler) throws Exception {\n                Calendar cal = Calendar.getInstance();\n                int hour = cal.get(HOUR_OF_DAY);\n                if (openingTime <= hour && hour < closingTime) {\n                        return true;\n                }\n                response.sendRedirect(\"http://host.com/outsideOfficeHours.html\");\n                return false;\n        }\n}\n```\n\n\n\n\n\n","tags":["springmvc"]},{"title":"序列化","url":"/2019/07/20/开发相关/序列化/","content":"\n\n## 实现一个序列化\n\n1.实现Serializable接口\n\n2.ObjectInputStream、ObjectOutputSream\n\n\n\n- 深拷贝：复制对应的所有变量和引用对应的实例，即引用对象为一个新对象而不是原来的对象\n\n  - 实现Cloneable接口，且重写clone()方法，将对象的引用克隆一次，传值\n\n    ```JAVA\n     \t@Override\n        public Object clone() throws CloneNotSupportedException {  \t\t\n    \t\t// 调用父类clone接口复制变量：\n            Student3 student = (Student3) super.clone();\n            // 本来是浅复制，现在将Teacher对象复制一份并重新set进来\n            student.setTeacher((Teacher2) student.getTeacher().clone());\n            return student;\n        }\n    \n    ```\n\n  - 序列化实现深克隆\n\n    ```java\n    public Object deepClone() throws IOException, ClassNotFoundException {\n            //序列化\n            ByteArrayOutputStream baos=new ByteArrayOutputStream();\n            ObjectOutputStream oos=new ObjectOutputStream(baos);\n    \n            oos.writeObject(this);\n    \n            //反序列化\n            ByteArrayInputStream bais=new \t\t\t\t\t\tByteArrayInputStream(baos.toByteArray());\n            ObjectInputStream ois=new ObjectInputStream(bais);\n            return ois.readObject();\n        }\n    ```\n\n    \n\n- 浅拷贝：复制对象的所有变量，但是引用的对象还是以前的对象。\n  \n  - 实现Cloneable接口，直接调用clone()方法\n\n## 序列化技术：\n\n- JACKSON\n\n\n```XML\n\t\t<dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-mapper-asl</artifactId>\n            <version>1.9.13</version>\n        </dependency>\n```\n\n  ```JAVA\nObjectMapper mapper=new ObjectMapper();\n          byte[] writeBytes=null;\n          Long start=System.currentTimeMillis();\n          writeBytes=mapper.writeValueAsBytes(person);//序列化\n          Person person1=mapper.readValue(writeBytes,Person.class);//反序列化\n          System.out.println(person1);\n  ```\n\n  - FastJson\n\n```XML\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.31</version>\n        </dependency>\n```\n\n```JAVA\nString result=JSON.toJSONString(person);//序列化\nPerson person=JSON.parseObject(text,Person.class);//反序列化\n```\n\n  - ProtoBuf\n\n```java\npublic class Person implements Serializable{\n\tprivate static final long serialVersionUID = 5711515415445643416L;\n    @Protobuf(fieldType = FieldType.STRING,order = 1)\n    private String name;\n\n    @Protobuf(fieldType = FieldType.INT32,order = 2)\n    private int age;\n```\n\n```xml\n        <dependency>\n            <groupId>com.baidu</groupId>\n            <artifactId>jprotobuf</artifactId>\n            <version>2.1.2</version>\n        </dependency>\n```\n\n```JAVA\nCodec<Person> personCodec= ProtobufProxy.create(Person.class,false);//此处较耗时\nbyte[] bytes=personCodec.encode(person);//序列化\nPerson person1=personCodec.decode(bytes);//反序列化\n```\n\n  - Hession\n\n```XML\n        <dependency>\n            <groupId>com.caucho</groupId>\n            <artifactId>hessian</artifactId>\n            <version>4.0.38</version>\n        </dependency>\n```\n\n```java\nByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\nHessianOutput ho=new HessianOutput(byteArrayOutputStream);\nho.writeObject(person);//序列化\n\nHessianInput hi=new HessianInput(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));\nPerson person=(Person)hi.readObject();//反序列化\n\n```\n\n\n\n","tags":["序列化"]},{"title":"rmi和webservice","url":"/2019/07/20/开发相关/rmi和webserice/","content":"\n\n\n# RMI\n\n\n\n## 实现一个RMI程序\n\n- 编写服务端程序，暴露端口监听（LocateRegistry.createRegistry(8888);）\n- 绑定对象到对应接口(Naming.bind(\"rmi://localhost:8888/test\",hello);)\n- 客户端寻找接口(Hello hello=(Hello) Naming.lookup(\"rmi://localhost:8888/test\");)\n\n注意：\n\n- 接口hello必须继承java.rmi.Remote(接口方法抛出REMOTEEXCEPTION)\n- 实现类继承java.rmi.server.UnicastRemoteObject对象\n\n","tags":["RMI,WEBSERVICE"]},{"title":"socket连接","url":"/2019/07/17/开发相关/Socket/","content":"\n\n# TCP/IP\n\nTCP/IP（Transmission Control Protocol/Internet Protocol）是一种可靠的网络数据传输控制协议。定义了主机如何连入因特网以及数据如何在他们之间传输的标准\n\n五层/七层模型：应用(表示，会话)，传输，网络，链路，物理传输\n\n![001](socket/001.png)\n\n- 三次握手\n\n  （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。\n\n  （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。\n\n  （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。\n\n- 四次挥手协议\n\n  （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。\n\n  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。\n\n  （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。\n\n  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。\n\n  \n\n  # Socket链接\n\n  \n\n  ## 1v1链接\n  - 客户端\n\n```java\npublic class SocketClient {\n\n  public static void main(String[] args) {\n    try {\n      Socket socket = new Socket(\"localhost\", 8888);\n      PrintWriter printWriter = new PrintWriter(socket.getOutputStream(), true);\n      printWriter.println(\"hello server\");\n      BufferedReader bufferedReader = new BufferedReader(\n          new InputStreamReader(socket.getInputStream()));\n      while (true) {\n        String serverData = bufferedReader.readLine();\n        if (serverData == null) {\n          break;\n        }\n        System.out.println(\"客户端消息：\" + serverData);\n      }\n      printWriter.close();\n      socket.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n```\n\n  - 服务端\n\n```java\n\npublic class SocketServer {\n\n  public static void main(String[] args) throws IOException {\n    ServerSocket serverSocket = null;\n    try {\n      serverSocket = new ServerSocket(8888);\n      while (true) {\n        Socket socket = serverSocket.accept();\n        new Thread(() -> {\n          try {\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(socket.getInputStream()));\n            PrintWriter printWriter = new PrintWriter(\n                new OutputStreamWriter(socket.getOutputStream()));\n            while (true) {\n              String clientData = reader.readLine();\n              if (clientData == null) {\n                break;\n              }\n              System.out.println(\"服务端消息：\" + clientData);\n              printWriter.println(\"hello.mike\");\n              printWriter.flush();\n            }\n\n          } catch (IOException e) {\n            e.printStackTrace();\n          }\n        }).start();\n      }\n    } catch (IOException e) {\n    } finally {\n      if (serverSocket != null) {\n        serverSocket.close();\n      }\n    }\n  }\n\n}\n```\n\n## 组播\n\n```java\npublic class MulticastServer {\n\n  public static void main(String[] args) {\n    //地址段：224.0.0.0-239.255.255.255\n    try {\n      InetAddress group=InetAddress.getByName(\"224.1.2.3\");\n      MulticastSocket multicastSocket=new MulticastSocket();\n      for (int i = 0; i <10 ; i++) {\n        String data=\"hello,index\"+i;\n        byte[] bytes=data.getBytes();\n        multicastSocket.send(new DatagramPacket(bytes,bytes.length,group,8888));\n        TimeUnit.SECONDS.sleep(2);\n      }\n\n    } catch (UnknownHostException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n\n\n}\n\n\n```\n\n\n\n\n\n```java\npublic class MulticastClient {\n\n  public static void main(String[] args) {\n\n    try {\n      InetAddress group=InetAddress.getByName(\"224.1.2.3\");\n      MulticastSocket multicastSocket=new MulticastSocket(8888);\n      multicastSocket.joinGroup(group);\n      byte[] bytes=new byte[1024];\n      while (true){\n        DatagramPacket datagramPacket=new DatagramPacket(bytes,bytes.length);\n        multicastSocket.receive(datagramPacket);\n        String msg=new String(datagramPacket.getData());\n        System.out.println(\"接受到msg：\"+msg);\n      }\n    } catch (UnknownHostException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n\n```\n\n","tags":["socket"]},{"title":"springboot源码分析","url":"/2019/06/22/框架系列/springboot/springboot源码分析/","content":"\n\n\n# springboot项目的创建\n\n- idea创建：File->New->Project...->Spring Initializr->Default:https://start.spring.io\n- web创建：登录https://start.spring.io/  ，选择对应springboot版本，设置group和artifact下载就行\\、\n\n注：springboot项目默认没有加载web，需要自己导入maven依赖\n\n```xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n```\n\n\n\n# springboot启动\n\n这里采用的是web下载方式，打开后，找到springboot启动类\n\n\n\n```java\npackage com.mkpassby.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringbootApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootApplication.class, args);\n\t}\n\n}\n\n```\n\n\n\n## springboot注解分析\n\n### @SpringBootApplication\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n...\n}\n```\n\n主要看有\n\n- @SpringBootConfiguration：声明配置类\n- @EnableAutoConfiguration：自动化配置\n- @ComponentScan：包扫描\n\n\n\n这里@EnableAutoConfiguration是通过将@Import导入AutoConfigurationImportSelector.class注入bean容器中\n\nspringboot中大量使用了@import注解：\n\n### @Import注解介绍\n\n@Import支持三种方式的导入：\n\n1. 直接导入一个配置类或者Bean\n2. 导入ImportSelector的实现类\n3. 导入ImportBeanDefinitionRegistrar的实现类\n\n\n\n```java\npublic class User {\n    private String name=\"aaa\";\n    public String getName() {\n        return name;  }  \n    public void setName(String name) {\n        this.name = name;  }}\n```\n\n```java\n@Import(User.class)\npublic class App {\n\n  public static void main(String[] args) {\n    ConfigurableApplicationContext configurableApplicationContext= SpringApplication.run(App.class,args);\n    System.out.println(configurableApplicationContext.getBean(User.class));\n    System.out.println(configurableApplicationContext.getBean(User.class).getName());\n    configurableApplicationContext.close();\n  }\n}\n```\n\nImportSelector方法的实现，return new String[]｛“com.mkpassby.demo.User”｝\n\n```java\npublic interface ImportSelector {\n  String[] selectImports(AnnotationMetadata var1);\n}\n\n```\n\n\n\nImportBeanDefinitionRegistrar和ImportSelector类似，注册额外的bean\n\n```JAVA\npublic class UserImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n  @Override\n  public void registerBeanDefinitions(AnnotationMetadata annotationMetadata,\n      BeanDefinitionRegistry beanDefinitionRegistry) {\n\n    beanDefinitionRegistry.registerBeanDefinition(\"User\",new RootBeanDefinition(User.class));\n  }\n}\n```\n\n \n\n\n\n## springboot启动分析\n\nSpringBoot启动由一个main方法调入，由静态run方法启动\n\n```java\n@SpringBootApplication\npublic class SpringbootApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootApplication.class, args);\n\t}\n}\n```\n\nrun方法中new SpringApplication(),在构造器调用WebApplicationType.deduceFromClasspath()，判定当前应用类型，我这里用的是2.1.6.RELEASE的版本，这里可以看到有一个WebApplicationType.REACTIVE，这个是对webflux非阻塞web框架的支持。\n\n```java\nstatic WebApplicationType deduceFromClasspath() {\n\t\tif (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\n\t\t\t\t&& !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\n\t\t\treturn WebApplicationType.REACTIVE;\n\t\t}\n\t\tfor (String className : SERVLET_INDICATOR_CLASSES) {\n\t\t\tif (!ClassUtils.isPresent(className, null)) {\n\t\t\t\treturn WebApplicationType.NONE;\n\t\t\t}\n\t\t}\n\t\treturn WebApplicationType.SERVLET;\n\t}\n```\n\n且在构造器中对所有包下的META-INF/spring.factories中配置的ApplicationContextInitializer和ApplicationListener实例化\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n\t\tthis.resourceLoader = resourceLoader;\n\t\tAssert.notNull(primarySources, \"PrimarySources must not be null\");\n\t\tthis.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n\t\tthis.webApplicationType = WebApplicationType.deduceFromClasspath();\n\t\tsetInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n\t\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n\t\tthis.mainApplicationClass = deduceMainApplicationClass();\n\t}\n```\n\n\n\n\n\n实例化SpringApplication完成后，调用run方法，实例化SpringApplicationRunListener，开启监听，准备数据等，其中核心在refreshContext(context)方法。在invokeBeanFactoryPostProcessors()方法中。该方法调用了PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())方法，此处第二个传参getBeanFactoryPostProcessors()传过来的是\n\n```properties\n0 = {SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor@3037} \n1 = {ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor@3038} \n2 = {ConfigurationClassPostProcessor@3787} \n```\n\n\n\n，这里是通过监听add到list中，此处具体实现需要进一步探究，最终通过postProcessBeanDefinitionRegistry进行BeanDefinition注册的处理。\n\n\n\n```java\n/**\n\t * Build and validate a configuration model based on the registry of\n\t * {@link Configuration} classes.\n\t */\n\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n\t\tString[] candidateNames = registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n            //获取所有标记了@Configuration注解类，封装成BeanDefinitionHolder集合\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// 没有 @Configuration 返回\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 根据@configuration中@Order排序\n\t\tconfigCandidates.sort((bd1, bd2) -> {\n\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr = null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr = (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator != null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n\t\t\t\t\tthis.importBeanNameGenerator = generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader == null) {\n\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n\t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n\t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames = newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}\n```\n\n\n\n\n\n继续跟进postProcessBeanDefinitionRegistry方法，后面调用了org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法,这里对@Configuration类进行了解析，包括@PropertySource，@ComponentScan，@Import，@ImportResource等。\n\n```java\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}\n```\n\n后续就是实例化所有的bean(Instantiate all remaining (non-lazy-init) singletons.),这里由于引入了spring-boot-starter-web依赖，特别说明下RequestMappingHandlerAdapter实例化。\n\n## RequestMappingHandlerAdapter实例化\n\n在实例化RequestMappingHandlerAdapter时会调用org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#requestMappingHandlerAdapter\n\n```java\n@Bean\n\tpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n\t\tRequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter();\n\t\tadapter.setContentNegotiationManager(mvcContentNegotiationManager());\n\t\tadapter.setMessageConverters(getMessageConverters());\n\t\tadapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());\n\t\tadapter.setCustomArgumentResolvers(getArgumentResolvers());\n\t\tadapter.setCustomReturnValueHandlers(getReturnValueHandlers());\n\n\t\tif (jackson2Present) {\n\t\t\tadapter.setRequestBodyAdvice(Collections.singletonList(new JsonViewRequestBodyAdvice()));\n\t\t\tadapter.setResponseBodyAdvice(Collections.singletonList(new JsonViewResponseBodyAdvice()));\n\t\t}\n\n\t\tAsyncSupportConfigurer configurer = new AsyncSupportConfigurer();\n\t\tconfigureAsyncSupport(configurer);\n\t\tif (configurer.getTaskExecutor() != null) {\n\t\t\tadapter.setTaskExecutor(configurer.getTaskExecutor());\n\t\t}\n\t\tif (configurer.getTimeout() != null) {\n\t\t\tadapter.setAsyncRequestTimeout(configurer.getTimeout());\n\t\t}\n\t\tadapter.setCallableInterceptors(configurer.getCallableInterceptors());\n\t\tadapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());\n\n\t\treturn adapter;\n\t}\n```\n进入getMessageConverters方法中，这里注意会由configureMessageConverters()方法进入org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#getMessageConverters\n\n```java\n@Override\n\tpublic void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\tfor (WebMvcConfigurer delegate : this.delegates) {\n\t\t\tdelegate.configureMessageConverters(converters);\n\t\t}\n\t}\n```\n\n\n\n\n\ngetMessageConverters方法，这里主要是从configureMessageConverters初始化messageConverters，以后后面的extendMessageConverters扩展messageCoverters。\n\n```java\nprotected final List<HttpMessageConverter<?>> getMessageConverters() {\n\t\tif (this.messageConverters == null) {\n\t\t\tthis.messageConverters = new ArrayList<>();\n\t\t\tconfigureMessageConverters(this.messageConverters);\n\t\t\tif (this.messageConverters.isEmpty()) {\n\t\t\t\taddDefaultHttpMessageConverters(this.messageConverters);\n\t\t\t}\n\t\t\textendMessageConverters(this.messageConverters);\n\t\t}\n\t\treturn this.messageConverters;\n\t}\n\n```\n\n这里如果需要扩展Http的请求扩展则可以查看类WebMvcConfigurer接口的注解说明，这里\n\n主要看\n\n``` JAVA\n\t/**\n\t * Configure the {@link HttpMessageConverter HttpMessageConverters} to use for reading or writing\n\t * to the body of the request or response. If no converters are added, a\n\t * default list of converters is registered.\n\t * <p><strong>Note</strong> that adding converters to the list, turns off\n\t * default converter registration. To simply add a converter without impacting\n\t * default registration, consider using the method\n\t * {@link #extendMessageConverters(java.util.List)} instead.\n\t * @param converters initially an empty list of converters\n\t */\n\tdefault void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}\n\n\t/**\n\t * A hook for extending or modifying the list of converters after it has been\n\t * configured. This may be useful for example to allow default converters to\n\t * be registered and then insert a custom converter through this method.\n\t * @param converters the list of configured converters to extend.\n\t * @since 4.1.3\n\t */\n\tdefault void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}\n```\n\n## 扩展\n\n这里贴出一段测试代码，可调整PostMapping中的produces和consumes查看变化\n\n\n\n通过对HttpConvert的修改，我们的代码可以适配成我们想要的入参或者出参，当然，应用场景多用json格式，可以考虑自己封装json对应的转换器，去除掉springboot中默认的json转换器\n\n```java\n@Configuration\npublic class MyWebMvcConfig implements WebMvcConfigurer {\n  @Override\n  public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n    converters.add(new PropertiesToUserConverter());\n\n  }\n  @Override\n  public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n    converters.add(new PropertiesToUserConverter());\n\n  }\n\n}\n```\n\n```java\n/**\n * @program: springboot\n * @description:\n * @author: mk_passby\n * @create: 2019-06-25 22:19\n **/\npublic class PropertiesToUserConverter extends AbstractHttpMessageConverter<User> {\n\n  public PropertiesToUserConverter() {\n    super(MediaType.valueOf(\"application/properties+person\"));\n    setDefaultCharset(Charset.forName(\"UTF-8\"));\n  }\n\n  @Override\n  protected boolean supports(Class<?> aClass) {\n    return aClass.isAssignableFrom(User.class);\n  }\n\n  //转换入参\n  @Override\n  protected User readInternal(Class<? extends User> aClass, HttpInputMessage httpInputMessage)\n      throws IOException, HttpMessageNotReadableException {\n    InputStream inputStream=httpInputMessage.getBody();\n    Properties properties=new Properties();\n    //请求内容properties转换为User对象\n    properties.load(inputStream);\n    User user=new User();\n    user.setName(properties.getProperty(\"user.name\"));\n    return user;\n  }\n\n  /***\n   * @param user\n   * @param httpOutputMessage\n   * @throws IOException\n   * @throws HttpMessageNotWritableException\n   */\n  //用properties格式写出去\n  @Override\n  protected void writeInternal(User user, HttpOutputMessage httpOutputMessage)\n      throws IOException, HttpMessageNotWritableException {\n    OutputStream outputStream=httpOutputMessage.getBody();\n    Properties properties=new Properties();\n    properties.setProperty(\"user.name\",user.getName());\n    properties.store(new OutputStreamWriter(outputStream,getDefaultCharset()),\"from web server\");\n  }\n}\n```\n\n```JAVA\n@RestController\npublic class RestControllerDemo {\n\n  @PostMapping(\n      value = \"user/properties/to/json\",\n      produces = \"application/properties+person\",//出参类型Accept\n      consumes = \"application/properties+person\"//入参类型Content-Type\n  )\n  public User userToProperties(@RequestBody User user) {\n    return user;\n  }\n}\n```\n\n用postman模拟请求，结果如下\n\n![1562769528306](springboot请求响应分析\\1562769528306.png)\n\n![1562769550293](springboot请求响应分析\\1562769550293.png)\n\n# springboot事件机制\n\n### 设计模式\n\n- 观察者模式\n\n  - `java.util.Observable`发布者\n\n  - `java.util.Observer`订阅者\n\n    ```java\n    package com.mk.demo;\n    \n    import java.util.Observable;\n    import java.util.Observer;\n    \n    /**\n     * @program: springcloud-demo\n     * @description: 观察值demo\n     * @author: mk_passby\n     * @create: 2020-05-25 22:34\n     **/\n    public class ObserverDemo {\n    \n        public static void main(String[] args) {\n            ObservableTest observable = new ObservableTest();\n            observable.setChanged();\n            observable.addObserver(new Observer() {\n                @Override\n                public void update(Observable o, Object arg) {\n                    System.out.println(arg);\n                }\n            });\n            observable.notifyObservers(\"Hello world\");\n        }\n    \n        public static class ObservableTest extends Observable {\n    \n            @Override\n            public synchronized void setChanged() {\n                super.setChanged();\n            }\n        }\n    }\n    \n    ```\n\n    \n\n- 事件监听模式\n\n\n\n### spring核心事件\n\n- ApplictionEvent：应用事件\n- ApplicationListener：应用监听器\n\n```java\npackage com.mk.demo;\n\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\n/**\n * @program: springcloud-demo\n * @description: spring事件监听demo\n * @author: mk_passby\n * @create: 2020-05-25 22:49\n **/\npublic class SpringEvenListenDemo {\n\n    public static void main(String[] args) {\n        //Annotation驱动的spring\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n        //注册监听\n        context.addApplicationListener(new ApplicationListener<ApplicationEventTest>() {\n            @Override\n            public void onApplicationEvent(ApplicationEventTest event) {\n                System.out.println(\"onApplicationEvent:\" + event.getSource());\n            }\n        });\n        //发布事件\n        context.refresh();\n        context.publishEvent(new ApplicationEventTest(\"HELLO WORLD\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 1\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 2\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 3\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 4\"));\n\n    }\n\n    private static class ApplicationEventTest extends ApplicationEvent {\n\n        /**\n         * Create a new ApplicationEvent.\n         *\n         * @param source the object on which the event initially occurred (never {@code null})\n         */\n        public ApplicationEventTest(Object source) {\n            super(source);\n        }\n    }\n}\n\n```\n\n### Springboot核心事件\n\n- ApplicationEnvironmentPreparedEvent\n- ApplicationPreparedEvent\n- ApplicationStartedEvent\n- ApplicationReadyEvent\n- ApplicationFailedEvent\n\n","tags":["springcloud"]},{"title":"hexo搭建博客","url":"/2019/06/20/开发相关/hexo博客搭建/","content":"\n这里主要贴出几个搭建过程中用到链接，自行参考，感谢感谢\n\n- [使用Hexo+Github一步步搭建属于自己的博客（基础）](https://www.cnblogs.com/fengxiongZz/p/7707219.html)\n- [使用Hexo+Github一步步搭建属于自己的博客（进阶）](https://www.cnblogs.com/fengxiongZz/p/7707568.html)\n- [hexo主题](https://hexo.io/themes/)\n- [Hexo-Aircloud-Blog主题安装教程](https://github.com/aircloud/hexo-aircloud-blog)\n\n\n\n| Hexo常用命令  | 作用                                           |\n| ------------- | ---------------------------------------------- |\n| hexo s(erver) | 启动本地服务器                                 |\n| hexo new \"AA\" | 新建\"AA\"文章                                   |\n| hexo d        | 部署到设定的仓库                               |\n| hexo clean    | 清除缓存文件 db.json 和已生成的静态文件 public |\n| hexo g        | 生成网站静态文件                               |\n\n"},{"title":"maven插件","url":"/2019/06/15/开发相关/maven/maven插件/","content":"\n## maven插件\n\n#### 插件网址\n\n * [maven官网](https://maven.apache.org/plugins/,\"MAVEN-PLUGIN\")\n * [MojoHaus官网](http://www.mojohaus.org/plugins.html,\"MojoHous-Plugin\")\n\n#### 常用插件\n * [tomcat](https://tomcat.apache.org/maven-plugin-trunk/)\n\n\n```xml\n        <pluginManagement>\n          <plugins>\n            <plugin>\n              <groupId>org.apache.tomcat.maven</groupId>\n              <artifactId>tomcat6-maven-plugin</artifactId>\n              <version>2.3-SNAPSHOT</version>\n            </plugin>\n            <plugin>\n              <groupId>org.apache.tomcat.maven</groupId>\n              <artifactId>tomcat7-maven-plugin</artifactId>\n              <version>2.3-SNAPSHOT</version>\n            </plugin>\n          </plugins>\n        </pluginManagement>\n```\n* [assembly](https://maven.apache.org/plugins/maven-assembly-plugin/index.html)（打包）\n * zip\n * tar\n * tar.gz (or tgz)\n * tar.bz2 (or tbz2)\n * tar.snappy\n * tar.xz (or txz)\n * jar\n * dir\n * war\n* versions 统一升级版本号\n`mvn versions:set -DnewVersion=1.1`\n\n#### 自定义插件\n* [自定义Mojo](https://maven.apache.org/guides/plugin/guide-java-plugin-development.html)\n\n\n1.extends AbstractMojo\n```java\n    package sample.plugin;\n     \n    import org.apache.maven.plugin.AbstractMojo;\n    import org.apache.maven.plugin.MojoExecutionException;\n    import org.apache.maven.plugins.annotations.Mojo;\n     \n    /**\n     * Says \"Hi\" to the user.\n     *\n     */\n    @Mojo( name = \"sayhi\")\n    public class GreetingMojo extends AbstractMojo\n    {\n        public void execute() throws MojoExecutionException\n        {\n            getLog().info( \"Hello, world.\" );\n        }\n    }\n```\n2.pom参数\n\n```xml\n    <project>\n      <modelVersion>4.0.0</modelVersion>\n     \n      <groupId>sample.plugin</groupId>\n      <artifactId>hello-maven-plugin</artifactId>\n      <version>1.0-SNAPSHOT</version>\n      <packaging>maven-plugin</packaging>\n     \n      <name>Sample Parameter-less Maven Plugin</name>\n     \n      <dependencies>\n        <dependency>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-plugin-api</artifactId>\n          <version>3.0</version>\n        </dependency>\n     \n        <!-- dependencies to annotations -->\n        <dependency>\n          <groupId>org.apache.maven.plugin-tools</groupId>\n          <artifactId>maven-plugin-annotations</artifactId>\n          <version>3.4</version>\n          <scope>provided</scope>\n        </dependency>\n      </dependencies>\n    </project>\n```\n3.引用插件\n\n```xml\n    ...\n      <build>\n        <plugins>\n          <plugin>\n            <groupId>sample.plugin</groupId>\n            <artifactId>hello-maven-plugin</artifactId>\n            <version>1.0-SNAPSHOT</version>\n          </plugin>\n        </plugins>\n      </build>\n    ...\n```\n","tags":["maven"]},{"title":"maven基础","url":"/2019/05/19/开发相关/maven/maven基础/","content":"\n\n## maven基础\n#### 优势\n- 相比传统项目，减少了手动导入工序，更加简便\n- 插件丰富\n- 构建简单\n\n\n#### 安装\n1. [maven下载地址](https://maven.apache.org/download.cgi，\"点击跳转\")\n2. 配置MVN_HOME，如JAVA_HOME类似\n3. 配置完成后，cmd输入`mvn-version` 检测是否配置成功\n4. 配置setting.xml，路径在maven安装目录conf目录下，打开setting.xml配置一个aliyun的仓库(默认仓库下载速度，以前也可以配置oschina打仓库，现在关闭了)\n\n\n```xml\n      <mirrors>\n      <!--aliyun仓库-->\n    \t<mirror>\n    \t  <id>alimaven</id>\n    \t  <name>aliyun maven</name>\n    \t  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    \t  <mirrorOf>central</mirrorOf>\n    \t</mirror>\n    \t<!-- 中央仓库1 -->\n        <mirror>\n            <id>repo1</id>\n            <mirrorOf>central</mirrorOf>\n            <name>Human Readable Name for this Mirror.</name>\n            <url>http://repo1.maven.org/maven2/</url>\n        </mirror>\n    \n        <!-- 中央仓库2 -->\n        <mirror>\n            <id>repo2</id>\n            <mirrorOf>central</mirrorOf>\n            <name>Human Readable Name for this Mirror.</name>\n            <url>http://repo2.maven.org/maven2/</url>\n        </mirror>\n        <!-- mirror\n         | Specifies a repository mirror site to use instead of a given repository. The repository that\n         | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n         | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n         |\n        <mirror>\n          <id>mirrorId</id>\n          <mirrorOf>repositoryId</mirrorOf>\n          <name>Human Readable Name for this Mirror.</name>\n          <url>http://my.repository.com/repo/path</url>\n        </mirror>\n         -->\n      </mirrors>\n```\n#### maven加载顺序\n首先是到用户目录下打.m2目录下setting中去找jar包，再去conf下的setting中找的\nmaven->/.m2/setting.xml->conf/settiong.xml\n\n\n#### pom.xml文件说明\n新建maven此处不做说明\n- groupid：公司名(网址）\n- artifactId：模块功能名(common，web，model，dao)\n- version：版本号\n- pachaging：打包方式，默认jar\n- dependencyManagemanet：依赖管理，统一版本号\n- Dependency：依赖\n * Type：默认jar\n * scope：\n   * complile：编译\n   * test：测试\n   * provided：已经提供了，不需要打进包\n   * runtime：运行时需要\n   * system：本地依赖的jar包 \n * exclusions：剔除不需要的jar包，多用于jar包冲突\n\n\n#### 基本的命令\n- compile:编译(mvn clean:compile)\n- test：运行test\n- package：打包\n- install：install到本地仓库\n- deploy：发布到远程仓库\n\n","tags":["maven"]},{"title":"代理模式","url":"/2018/07/15/设计模式/代理模式/","content":"\n\n\n代理模式就是新增加一个代理类，然后通过代理类来调用我们的实现。\n\n应用场景可以参考中介。\n\n# 1.未使用代理类场景\n\n        未使用代理类，即接口直接通过实现类实现功能\n\n![](代理模式\\1.jpg)\n\n接口：\n\n```java\npublic interface UserDao {\n    public void updateUser();\n    public void delUser();\n}\n```\n\n实现类：\n\n```java\npublic class UserDaoImpl implements UserDao{\n    @Override\n    public void updateUser() {\n        System.out.println(\"更新用户成功\");\n    }\n\n    @Override\n    public void delUser() {\n        System.out.println(\"删除用户成功\");\n    }\n}\n```\n\n测试类：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        UserDao userDao=new UserDaoImpl();\n        userDao.delUser();\n        userDao.updateUser();\n    }\n}\n\n```\n\n![](代理模式\\2.jpg)\n\n# 2.使用代理类\n\n## 2.1静态代理类\n\n即新增一个代理类，来管理我们的实现类，我们可以在代理类中添加一些动作\n\n![](代理模式\\3.jpg)\n\n将具体的实现通过构造器注入，然后代理类中调用我们对应的实现类的方法，\n\n新增的代理类如下：\n\n```java\npublic class StaticProxy implements UserDao{\n    private UserDao userDao;\n    public StaticProxy(UserDao userDao1)\n    {\n        this.userDao=userDao1;\n    }\n\n\n    @Override\n    public void updateUser() {\n        System.out.println(\"begin\");\n        userDao.updateUser();\n        System.out.println(\"end \");\n    }\n\n    @Override\n    public void delUser() {\n        System.out.println(\"begin\");\n        userDao.delUser();\n        System.out.println(\"end\");\n    }\n}\n```\n\n测试类\n\n```java\npublic class ProxyTest {\n    public static void main(String[] args) {\n        UserDao userDaoProxy=new StaticProxy(new UserDaoImpl());\n        userDaoProxy.delUser();\n        userDaoProxy.updateUser();\n    }\n}\n```\n\n结果如下\n\n![](代理模式\\4.jpg)\n\n## 2.2由静态代理类引出动态代理类\n\n- 可以看见，我们的静态代理类也实现了UserDao接口，当接口新增内容时，如新增一个query()方法，此时，我们的UserDaoImpl和StaticProxy类都要改变。-\n- 这是我们不想看见的，我们希望代理类可以不做修改，只需要修改我们的实现类的内容。由此引出了动态代理类(由此动态代理类的作用也显而易见) \n\n## 2.3动态代理类\n\n**定义动态代理工具类**\n\n返回指定的接口，将方法调用指定的调用处理程序的代理类的一个实例![](代理模式\\5.jpg)\n\n三个参数可以查阅JDK明细，主要需要实现`InvocationHandler`接口，实现`invoke`方法，通过反射实现对抽象接口方法的调用`method.invoke(target, args),`调其中target就是我们真正的实现类\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n```java\npublic class DynamicProxy {\n    public static void main(String[] args) {\n        UserDao userDao = (UserDao) Proxy.newProxyInstance(\n                UserDao.class.getClassLoader(),\n                new Class[]{UserDao.class},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        System.out.println(\"proxy begin\");\n                        Object result = method.invoke(new UserDaoImpl(), args);\n                        System.out.println(\"proxy end\");\n                        return result;\n                    }\n                }\n        );\n        userDao.delUser();\n    }，\n```\n\n\n\n# 3.总结\n\n- 核心在于ProxyGenerator.generateProxyClass，返回的byte[]为对象字节数组，生成代理对象。\n\n- 代理模式强调一些通用功能的扩展，在方法执行前，执行后添加点什么东西(LOG)，静态即单一的扩展，动态为多个类扩展，但是都引入新的代理类，从性能上讲，新的代理类会导致性能有所下降.","tags":["设计模式"]},{"title":"抽象工厂模式","url":"/2018/03/26/设计模式/抽象工厂模式/","content":"\n# 1.比较工厂方法模式\n\n## 工厂方法模式：\n\n-   一个抽象产品类，可以派生出多个具体产品类。\n-   一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。\n-   工厂方法模式只有一个抽象产品类(只能创建一个具体产品类的实例)\n\n## 抽象工厂模式：\n\n-   多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。\n-   一个抽象工厂类，可以派生出多个具体工厂类。\n-   抽象工厂模式有多个产品类(抽象工厂模式可以创建多个)\n\n# 2.抽象工厂模式举例\n\n比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。 这样A和B就是工厂，对应于抽象工厂；每个工厂生产的鼠标和键盘就是产品，对应于工厂方法；用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法） 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线\n\n# 3.总结\n\n1.  抽象工厂模式并不是指抽象类(不要混淆)，这里注意区分。\n2.  工厂方法模式更注重的是工厂方法的更改，更细微一点，如替换键盘由微软的生产方法替换到罗技的生产方法。而抽象工厂模式更注重的是工厂的替换，工厂方法的更改是工厂替换后考虑的点。\n3.  工厂方法模式可以看做是生产一个东西，抽象工厂模式看作生产一堆东西，只是对应的厂商不同(实现类)。如果工厂方法模式中Factory生产多个东西就是抽象工厂模式（个人理解）","tags":["设计模式"]},{"title":"工厂方法模式","url":"/2018/03/26/设计模式/工厂方法模式/","content":"\n# 1.普通简单工厂\n\n​        工厂类负责对实现同一接口的类进行实例创建,\n\n## 关系图如下\n\n![img](工厂方法模式\\1.png)\n\n## 代码如下：\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic Sender produce(String type) {\n\t\tif (\"mail\".equals(type)) {\n\t\t\treturn new MailSender();\n\t\t} else if (\"msg\".equals(type)) {\n\t\t\treturn new MsgSender();\n\t\t} else {\n\t\t\tSystem.out.println(\"请输入正确的类型\");\n\t\t\treturn null;\n\t\t}\n\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic interface Sender {\n\tpublic void send();\n\t\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class MailSender implements Sender{\n\n\t@Override\n\tpublic void send() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"this is a mailSender\");\n\t}\n\t\n\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class MsgSender implements Sender{\n\n\t@Override\n\tpublic void send() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"this is a msgSender\");\n\t}\n\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=new SendFactory().produce(\"msg\");\n\t\tsend.send();\n\t}\n}\n```\n\n运行结果：\n\n![img](工厂方法模式\\2.png)\n\n\n\n# 2.多方法简单工厂\n\n​        普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，多方法简单工厂为工厂提供创建每个实例的方法，避免这种问题。\n\n## 关系图如下\n\n![img](工厂方法模式\\3.png)\n\n## 代码如下：\n\n​        对比这里只有SenderFactory做了改变，这里仅贴出**SenderFactory**和**Test**的代码\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic Sender produceMail() {\n\t\treturn new MailSender();\n\t}\n\tpublic Sender produceMsg(){\n\t\treturn new MsgSender();\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=new SendFactory().produceMail();\n\t\tsend.send();\n\t}\n}\n```\n## 结果如下：\n\n![img](工厂方法模式\\4.png)\n\n\n\n# 3.静态方法简单工厂\n\n​        将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用\n\n​        即将SenderFactory中的produceMail()和produceMsg()改为静态方法。其他文件同样不变\n\n## 代码如下：\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic static Sender produceMail() {\n\t\treturn new MailSender();\n\t}\n\tpublic static Sender produceMsg(){\n\t\treturn new MsgSender();\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=SendFactory.produceMail();\n\t\tsend.send();\n\t}\n}\n```\n\n# 4.总结\n\n## 工厂模式的使用场景：\n\n​        当几个实现类都有相同的接口，可用工厂模式，易于扩展和修改。\n\n## 工厂模式选择：\n\n​        以上三种模式，第一种字符串有误会导致异常，第三种由于是静态方法，不需要重复创建对象，所以一般选择第三种——静态工厂方法\n\n\n\n# 5.工厂方法模式\n\n​        简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改。\n\n​        用工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码\n\n## 关系图如下：\n\n![img](工厂方法模式\\5.png)\n\n具体的实现这里就不再写出来了，只是给MailSenderFactory和MsgSenderFactory提供一格接口，让工厂类也易于扩展。\n\n\n\n## 这个模式的好处\n\n如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！","tags":["设计模式"]},{"title":"ssm项目搭建","url":"/2018/03/22/框架系列/ssm项目搭建/","content":"\n# 基于xml配置\n\n## 1.所需架包\n\n```xml\n<dependencies>\n     \n        <dependency>\n              <groupId>javax.websocket</groupId>\n              <artifactId>javax.websocket-api</artifactId>\n              <version>1.1</version>\n        </dependency>\n        <dependency>\n              <groupId>org.springframework</groupId>\n              <artifactId>spring-websocket</artifactId>\n              <version>4.0.5.RELEASE</version>\n         </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>3.8.1</version>\n            <scope>test</scope>\n        </dependency>\n \n        <dependency>\n            <groupId>jstl</groupId>\n            <artifactId>jstl</artifactId>\n            <version>1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.2.3</version>\n        </dependency>\n        <dependency>\n            <groupId>com.google.code.gson</groupId>\n            <artifactId>gson</artifactId>\n            <version>2.2.4</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/net.sf.ezmorph/ezmorph -->\n        <dependency>\n            <groupId>net.sf.ezmorph</groupId>\n            <artifactId>ezmorph</artifactId>\n            <version>1.0.4</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils -->\n        <dependency>\n            <groupId>commons-beanutils</groupId>\n            <artifactId>commons-beanutils</artifactId>\n            <version>1.7.0</version>\n        </dependency>\n \n        <dependency>\n            <groupId>commons-collections</groupId>\n            <artifactId>commons-collections</artifactId>\n            <version>3.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib-ext-spring</artifactId>\n            <version>1.0.2</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-lang</groupId>\n            <artifactId>commons-lang</artifactId>\n            <version>2.6</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.0.1</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>1.2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-dbcp</groupId>\n            <artifactId>commons-dbcp</artifactId>\n            <version>1.4</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-pool</groupId>\n            <artifactId>commons-pool</artifactId>\n            <version>1.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.6.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator</artifactId>\n            <version>1.3.5</version>\n            <type>pom</type>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator-core</artifactId>\n            <version>1.3.5</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-logging</groupId>\n            <artifactId>commons-logging</artifactId>\n            <version>1.1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet.jsp</groupId>\n            <artifactId>jsp-api</artifactId>\n            <version>2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>servlet-api</artifactId>\n            <version>2.5</version>\n        </dependency>\n        <!-- ============================================== -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aspects</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-expression</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <!-- ============================================== -->\n        <dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-core-asl</artifactId>\n            <version>1.9.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-mapper-asl</artifactId>\n            <version>1.9.11</version>\n        </dependency>\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib</artifactId>\n            <version>2.3</version>\n            <classifier>jdk15</classifier>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.25</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n \n        <dependency>\n            <groupId>javax.mail</groupId>\n            <artifactId>mail</artifactId>\n            <version>1.4.3</version>\n        </dependency>\n \n       \n \n    </dependencies>\n```\n\n## 2.框架搭建\n\n### 2.1.html--->springMVC\n\n        将html页面的请求转发到springMVC，即转换servlet到springMVC，在WebRoot下的WEB-INF配置web.xml\n\n```xml\n<!-- springmvc前端控制器 -->\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet\n        </servlet-class>\n        <!--\n            contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等）\n            如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml）\n        -->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring/springmvc.xml</param-value>\n        </init-param>\n    </servlet>\n \n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <!--\n            第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析\n            第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析\n            使用此种方式可以实现 RESTful风格的url 第三种：/*，这样配置不对，使用这种配置，最终要转发到一个jsp页面时，\n            仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。\n        -->\n        <url-pattern>*.action</url-pattern>\n    </servlet-mapping>\n```\n\n处理页面乱码，过滤乱码问题\n\n```xml\n<!-- post乱码过虑器 -->\n    <filter>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter\n        </filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n```\n\n在web.xml中加载spring容器\n\n```xml\n<!-- 加载spring容器 -->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/classes/spring/applicationContext-*.xml\n        </param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n```\n\n部分errorpage的配置\n\n```xml\n<!-- 404 页面不存在错误 -->\n    <error-page>\n        <error-code>404</error-code>\n        <location>/error404.jsp</location>\n    </error-page>\n \n    <!-- 500 系统错误 -->\n    <error-page>\n        <error-code>500</error-code>\n        <location>/error500.jsp</location>\n    </error-page>\n \n    <!-- 405 页面不存在错误 -->\n    <error-page>\n        <error-code>405</error-code>\n        <location>/error405.jsp</location>\n    </error-page>\n \n    <!-- 400 提交数据异常错误 -->\n    <error-page>\n        <error-code>400</error-code>\n        <location>/error400.jsp</location>\n    </error-page>\n```\n\n至此，web.xml的配置已经完成\n\n### springMVC的处理：\n\n此处转发的请求是到classpath:spring/springmvc.xml中\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n \n    <!-- 对于注解的Handler可以单个配置\n    实际开发中建议使用组件扫描\n     -->\n    <!-- <bean class=\"cn.itcast.ssm.controller.ItemsController3\" /> -->\n    <!-- 可以扫描controller、service、...\n    这里让扫描controller，指定controller的包\n     -->\n    <context:component-scan base-package=\"com.learn.controller\"></context:component-scan>\n     \n     \n    <!-- 处理器映射器 将bean的name作为url进行查找 ，需要在配置Handler时指定beanname（就是url） \n    所有的映射器都实现 HandlerMapping接口。\n    -->\n    <bean\n        class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" />\n         \n    <!--注解映射器 -->\n    <!--<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>-->\n    <!--注解适配器 -->\n    <!--<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>-->\n     \n    <!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置\n    mvc:annotation-driven默认加载很多的参数绑定方法，\n    比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\n    实际开发时使用mvc:annotation-driven\n     -->\n    <mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\n         \n    <!-- 自定义参数绑定 -->\n    <bean id=\"conversionService\"\n        class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n        <!-- 转换器 -->\n        <property name=\"converters\">\n            <list>\n                <!-- 日期类型绑定器 -->\n                <bean class=\"com.learn.conv.DateConverter\" />\n            </list>\n        </property>\n    </bean>\n \n    <!-- 视图解析器\n    解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包\n     -->\n    <bean\n        class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <!-- 配置jsp路径的前缀 -->\n        <property name=\"prefix\" value=\"WEB-INF/jsp/\"/>\n        <!-- 配置jsp路径的后缀 -->\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n    <!-- 自定义的全局异常处理器 \n只要实现HandlerExceptionResolver接口就是全局异常处理器-->\n    <bean class=\"com.learn.exception.CustomExceptionResolver\"></bean>\n     \n     <!-- SpringMVC上传文件时，需要配置MultipartResolver处理器 -->  \n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">  \n        <!-- 指定所上传文件的总大小不能超过200KB。注意maxUploadSize属性的限制不是针对单个文件，而是所有文件的容量之和 -->  \n      <!--    <property name=\"maxUploadSize\" value=\"5242880\"/>  -->\n    </bean> \n     \n    <!--拦截器 -->\n<mvc:interceptors>\n    <!-- 登陆认证拦截器 -->\n    <mvc:interceptor>\n        <mvc:mapping path=\"/**\"/>\n        <bean class=\"com.learn.interceptor.LoginInterceptor\"></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n</beans>\n```\n\n同时这里贴出三个类（日期邦定器、登陆拦截器、全部异常处理 ）\n\n```java\npackage com.learn.exception;\n \nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n \nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.ModelAndView;\n \npublic class CustomExceptionResolver implements HandlerExceptionResolver{\n \n    public ModelAndView resolveException(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex) {\n        // TODO Auto-generated method stub\n        CustomException customException = null;\n        if(ex instanceof CustomException){\n            customException = (CustomException)ex;\n        }else{\n            customException = new CustomException(\"未知错误\");\n        }\n         \n        //错误信息\n        String message = customException.getMessage();\n         \n         \n        ModelAndView modelAndView = new ModelAndView();\n         \n        //将错误信息传到页面\n        modelAndView.addObject(\"message\", message);\n         \n        //指向错误页面\n        modelAndView.setViewName(\"error\");\n \n         \n        return modelAndView;\n    }\n     \n}\n```\n\n```java\npackage com.learn.conv;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.springframework.core.convert.converter.Converter;\npublic class DateConverter implements Converter<String, Date>{\n    public Date convert(String souce) {\n        System.out.println(souce.length());\n        if(souce.length() == 19){\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            try {\n                return format.parse(souce);\n            } catch (ParseException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }          \n        }else if(souce.length() == 10){\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n            try {\n                return format.parse(souce);\n            } catch (ParseException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }  \n        }else{\n            return null;\n        }\n    }\n}\n```\n\n```java\npackage com.learn.interceptor;\n \nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n \nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n \n/** \n* @author  \n* @version 创建时间：2016年4月26日 下午4:42:38 \n*  \n*/\npublic class LoginInterceptor implements HandlerInterceptor{\n \n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object arg2, Exception arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n        System.out.println(\"HandlerInterceptor1...afterCompletion\");\n         \n    }\n \n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object arg2, ModelAndView arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n        System.out.println(\"HandlerInterceptor1...postHandle\");\n         \n    }\n \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception {\n        String url=request.getRequestURI();\n        //System.out.println(\"url---------\"+url+\"--\"+url.indexOf(\"getModule.action\"));\n    if(url.indexOf(\"index.action\")>=0 ||url.indexOf(\"toLogin.action\")>=0||url.indexOf(\"msgDetail.action\")>=0\n            ||url.indexOf(\"findMsg.action\")>=0||url.indexOf(\"getModule.action\")>=0||url.indexOf(\"getModule2.action\")>=0\n            ||url.indexOf(\"getModule3.action\")>=0||url.indexOf(\"findMsg.action\")>=0||url.indexOf(\"indexSkip.action\")>=0\n            ||url.indexOf(\"searchType.action\")>=0||url.indexOf(\"searchRSIndex.action\")>=0||url.indexOf(\"getModule.action\")>=0     \n//             \n            )\n        {\n \n            return true;\n        }      \n        //判断session\n                HttpSession session  = request.getSession();\n                //从session中取出用户身份信息\n                String usercode = (String) session.getAttribute(\"userName\");               \n                if(usercode != null){\n                    //身份存在，放行\n                    return true;\n                }\n                 \n        //执行这里表示用户身份需要认证，跳转登陆页面\n        request.setAttribute(\"loginFailed\", \"用户登陆过期!\"); \n        request.getRequestDispatcher(\"index.action\").forward(request,response); \n         \n        return true;\n        //return true;\n    }\n}\n```\n\n#### applicationContext-transaction.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n \n<!-- 事务管理器 \n    对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\n-->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <!-- 数据源\n    dataSource在applicationContext-dao.xml中配置了\n     -->\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n \n<!-- 通知 -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes>\n        <!-- 传播行为 -->\n        <tx:method name=\"save*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"insert*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n        <tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n        <tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n<!-- aop -->\n<aop:config>\n    <aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.learn.service.Impl.*.*(..))\"/>\n</aop:config>\n \n</beans>\n```\n\n#### applicationContext-service.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n         \n<context:component-scan base-package=\"com.learn.service.Impl\"></context:component-scan>\n<!-- service -->\n<bean id=\"msgService\" class=\"com.learn.service.Impl.MsgServiceImpl\"/>\n \n</beans>\n```\n\n#### applicationContext-dao.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd          \n      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \n      http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\">\n     \n    <!-- 加载db.properties文件的内容，db.properties文件中的key命名有一定的特殊规则 -->\n    <context:property-placeholder location=\"classpath:db.properties\"/>\n    <!--配置数据源,dbcp  -->\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n                <!-- 数据连接信息 -->\n                <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\n                <property name=\"url\" value=\"${jdbc.url}\" />\n                <property name=\"username\" value=\"${jdbc.username}\" />\n                <property name=\"password\" value=\"${jdbc.password}\" />\n                <property name=\"maxActive\" value=\"30\" />\n                <property name=\"maxIdle\" value=\"5\" />\n                 \n    </bean>\n    <!-- sqlsessionFactory -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> \n                 <property name=\"dataSource\" ref=\"dataSource\"></property>\n                 <property name=\"configLocation\" value=\"classpath:mybatis/sqlMapConfig.xml\"></property>\n    </bean>\n   <!--  <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\n        p:dataSource-ref=\"dataSource\" p:configLocation=\"classpath:mybatis/sqlMapConfig.xml\" />--> \n    <!-- mapper扫描器 -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n                 <property name=\"basePackage\" value=\"com.learn.mapper\"></property>\n                 <property name=\"SqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>\n    </bean>\n</beans>\n```\n\n#### sqlMapConfig.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n   <!-- 全局的setting配置，根据需要添加 -->\n   <typeAliases>\n     <!-- 批量扫描别名 -->\n     <package name=\"com.learn.po\"/>\n   </typeAliases>\n</configuration>\n```\n\n## 逆向生成文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n  PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n \n<generatorConfiguration>\n    <context id=\"testTables\" targetRuntime=\"MyBatis3\">\n        <commentGenerator>\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\" />\n        </commentGenerator>\n        <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->\n        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\n            connectionURL=\"jdbc:mysql://127.0.0.1:3306/mk_notes\" userId=\"root\"\n            password=\"root\">\n        </jdbcConnection>\n        <!-- <jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\"\n            connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:yycg\" \n            userId=\"yycg\"\n            password=\"yycg\">\n        </jdbcConnection> -->\n \n        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n            NUMERIC 类型解析为java.math.BigDecimal -->\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\" />\n        </javaTypeResolver>\n \n        <!-- targetProject:生成PO类的位置 -->\n        <javaModelGenerator targetPackage=\"com.learn.po\"\n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n            <!-- 从数据库返回的值被清理前后的空格 -->\n            <property name=\"trimStrings\" value=\"true\" />\n        </javaModelGenerator>\n        <!-- targetProject:mapper映射文件生成的位置 -->\n        <sqlMapGenerator targetPackage=\"com.learn.mapper\" \n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n        </sqlMapGenerator>\n        <!-- targetPackage：mapper接口生成的位置 -->\n        <javaClientGenerator type=\"XMLMAPPER\"\n            targetPackage=\"com.learn.mapper\" \n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n        </javaClientGenerator>\n        <!-- 指定数据库表 -->\n        <table tableName=\"op_member_t\"></table>\n     \n    </context>\n</generatorConfiguration>\n```\n\n### 对应的java代码\n\n```java\npackage Generator;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n \nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\npublic class GeneratorSqlmap {\n    public void generator() throws Exception{\n \n        List<String> warnings = new ArrayList<String>();\n        boolean overwrite = true;\n        //指定 逆向工程配置文件\n        File configFile = new File(\"config/generatorConfig.xml\"); \n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n                callback, warnings);\n        myBatisGenerator.generate(null);\n \n    } \n    public static void main(String[] args) throws Exception {\n        try {\n            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n            generatorSqlmap.generator();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n         \n    }\n}\n```\n\n## 整个项目的目录结构\n\n供参考\n\n![](https://static.oschina.net/uploads/space/2017/0616/161712_LaAq_3429289.png)\n\n\n# 基于javaconfig配置\n\n## 1    项目结构（SSM+MAVEN）\n\n### 1.1    目录结构\n\n![](https://static.oschina.net/uploads/space/2018/0322/155319_tg0n_3429289.png)\n\n### 1.2    POM文件\n\n        由于仓库是nexus私服，如遇见无法加载的包，请无视\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test</groupId>\n\t<artifactId>ssmTest</artifactId>\n\t<packaging>war</packaging>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>ssmTest Maven Webapp</name>\n\t<url>http://maven.apache.org</url>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>junit</groupId>\n\t\t\t<artifactId>junit</artifactId>\n\t\t\t<version>3.8.1</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.xmlbeans</groupId>\n\t\t\t<artifactId>xmlbeans</artifactId>\n\t\t\t<version>2.6.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi-ooxml-schemas</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi-ooxml</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-collections4</artifactId>\n\t\t\t<version>4.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.websocket</groupId>\n\t\t\t<artifactId>javax.websocket-api</artifactId>\n\t\t\t<version>1.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-websocket</artifactId>\n\t\t\t<version>4.0.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>jstl</groupId>\n\t\t\t<artifactId>jstl</artifactId>\n\t\t\t<version>1.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t\t<version>2.2.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.google.code.gson</groupId>\n\t\t\t<artifactId>gson</artifactId>\n\t\t\t<version>2.2.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.ezmorph</groupId>\n\t\t\t<artifactId>ezmorph</artifactId>\n\t\t\t<version>1.0.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>jcifs</groupId>\n\t\t\t<artifactId>jcifs</artifactId>\n\t\t\t<version>1.3.17</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-beanutils</groupId>\n\t\t\t<artifactId>commons-beanutils</artifactId>\n\t\t\t<version>1.7.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-collections</groupId>\n\t\t\t<artifactId>commons-collections</artifactId>\n\t\t\t<version>3.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.json-lib</groupId>\n\t\t\t<artifactId>json-lib-ext-spring</artifactId>\n\t\t\t<version>1.0.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>log4j</groupId>\n\t\t\t<artifactId>log4j</artifactId>\n\t\t\t<version>1.2.17</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-lang</groupId>\n\t\t\t<artifactId>commons-lang</artifactId>\n\t\t\t<version>2.6</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-io</groupId>\n\t\t\t<artifactId>commons-io</artifactId>\n\t\t\t<version>2.0.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-fileupload</groupId>\n\t\t\t<artifactId>commons-fileupload</artifactId>\n\t\t\t<version>1.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis</groupId>\n\t\t\t<artifactId>mybatis-spring</artifactId>\n\t\t\t<version>1.2.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-dbcp</groupId>\n\t\t\t<artifactId>commons-dbcp</artifactId>\n\t\t\t<version>1.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-pool</groupId>\n\t\t\t<artifactId>commons-pool</artifactId>\n\t\t\t<version>1.5.6</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.aspectj</groupId>\n\t\t\t<artifactId>aspectjweaver</artifactId>\n\t\t\t<version>1.6.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis</groupId>\n\t\t\t<artifactId>mybatis</artifactId>\n\t\t\t<version>3.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t<artifactId>mybatis-generator</artifactId>\n\t\t\t<version>1.3.5</version>\n\t\t\t<type>pom</type>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t<artifactId>mybatis-generator-core</artifactId>\n\t\t\t<version>1.3.5</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-logging</groupId>\n\t\t\t<artifactId>commons-logging</artifactId>\n\t\t\t<version>1.1.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet.jsp</groupId>\n\t\t\t<artifactId>jsp-api</artifactId>\n\t\t\t<version>2.2</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet</groupId>\n\t\t\t<artifactId>servlet-api</artifactId>\n\t\t\t<version>2.5</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>aopalliance</groupId>\n\t\t\t<artifactId>aopalliance</artifactId>\n\t\t\t<version>1.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-webmvc</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-aop</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-aspects</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-context</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-beans</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-context-support</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-core</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-expression</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-jdbc</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-tx</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-test</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-web</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-pool2</artifactId>\n\t\t\t<version>2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.codehaus.jackson</groupId>\n\t\t\t<artifactId>jackson-core-asl</artifactId>\n\t\t\t<version>1.9.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.codehaus.jackson</groupId>\n\t\t\t<artifactId>jackson-mapper-asl</artifactId>\n\t\t\t<version>1.9.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.json-lib</groupId>\n\t\t\t<artifactId>json-lib</artifactId>\n\t\t\t<version>2.3</version>\n\t\t\t<classifier>jdk15</classifier>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<version>5.1.20</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.mail</groupId>\n\t\t\t<artifactId>mail</artifactId>\n\t\t\t<version>1.4.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-net</groupId>\n\t\t\t<artifactId>commons-net</artifactId>\n\t\t\t<version>3.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-codec</groupId>\n\t\t\t<artifactId>commons-codec</artifactId>\n\t\t\t<version>1.10</version>\n\t\t</dependency>\n\t</dependencies>\n\t<build>\n\t\t<finalName>ssmTest</finalName>\n\t</build>\n</project>\n\n```\n\n## 2    配置SPRINGMVC\n\n### 2.1    初始化\n\n         首先创建一个初始化类，继承AbstractAnnotationConfigDispatcherServletInitializer类\n\n```java\npackage com.ssm.config;\n\nimport org.apache.log4j.Logger;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\n/**\n * \n * @author C\n *\n */\npublic class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\tprivate final static Logger LOG = Logger.getLogger(WebAppInitializer.class);\n\n\t@Override\n\tprotected Class<?>[] getRootConfigClasses() {\n\t\t// TODO Auto-generated method stub\n\t\tLOG.info(\"------root配置类初始化------\");\n\t\treturn new Class<?>[] { RootConfig.class };\n\t}\n\n\t@Override\n\tprotected Class<?>[] getServletConfigClasses() {\n\t\tLOG.info(\"------web配置类初始化------\");\n\t\t return new Class<?>[] { WebConfig.class };\n\t}\n\n\t@Override\n\tprotected String[] getServletMappings() {\n\t\t// TODO Auto-generated method stub\n\t\tLOG.info(\"------映射根路径初始化------\");\n\t\t//return null;\n\t\t return new String[] {\"/\"};// 请求路径映射，将路径映射到DispatcherServlet上\n\t}\n\n}\n\n```\n\n这里继承AbstractAnnotationConfigDispatcherServletInitializer 类，就会自动个地配置Dispatcher-Servlet和Spring上下文(传统的方法是在web.xml中配置 DispatcherServlet)\n\n### 2.2    AbstractAnnotationConfigDispatcherServletInitializer剖析\n\n         Servlet3.0环境中，容器会在类路径去查找实现javax.servlet.ServletContainerInitializer接口的类，如果发现，就用它做servlet的容器\n    \n        Spring对这个接口进行了实现，为SpringServletContainerInitializer。它( SpringServletContainerInitializer )会去查找实现了WebAppInitializer的类并将配置任务交给他们来完成。Spring3.2引入了便利的 WebAppInitializer 实现，就是AbstractAnnotationConfigDispatcherServletInitializer。所以当部署到Servlet3.0容器中时，容器会自动发现它，并配置servlet上下文\n    \n         重新的三个方法也有对应注解，这里不再多说\n\n### 2.3  WebConfig配置\n\n        当DispatcherServlet启动的时候，会创建Spring应用上下文并加载配置文件或配置文件中声明的bean。\n    \n        当它加载上下文时，使用定义在WebConfig中的bean(基于java配置)\n    \n        DispatcherServlet 加载包含web组件的bean，如控制器，视图解析器等。还有一个ContextLoaderListener加载其他bean，如中间层及数据层组件等\n\n```java\npackage com.ssm.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\n\n/****\n * 定义 DispatcherServlet 加载应用上下文的配置\n * \n * @author C\n *\n */\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.ssm.controller\") // 包扫描\npublic class WebConfig extends WebMvcConfigurerAdapter{\n\t@Bean\n\tpublic ViewResolver viewResolver() {\n\t\tInternalResourceViewResolver resolver = new InternalResourceViewResolver();\n\t\tresolver.setPrefix(\"/WEB-INF/jsp\");\n\t\tresolver.setSuffix(\".jsp\");\n\t\treturn resolver;\n\t}\n\n\t@Bean(name = \"multipartResolver\") // bean必须写name属性且必须为multipartResolver\n\tprotected CommonsMultipartResolver multipartResolver() {\n\t\tCommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();\n\t\tcommonsMultipartResolver.setMaxUploadSize(5 * 1024 * 1024);\n\t\tcommonsMultipartResolver.setMaxInMemorySize(0);\n\t\tcommonsMultipartResolver.setDefaultEncoding(\"UTF-8\");\n\t\treturn commonsMultipartResolver;\n\t}\n\n\t// 静态资源的处理\n\tpublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n\t\tconfigurer.enable();\n\t}\n}\n\n```\n\n@Configuration：配置类\n\n@EnableWebMvc：相当于基于xml配置的<mvc:annotation-driven>启用注解驱动\n\n@ComponentScan：包扫描\n\n## 3    RootConfig配置\n\n```java\npackage com.ssm.config;\n\nimport org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n\n/***\n * 主要配置持久层的一些东西，包括数据库、Mybatis框架，事务之类的\n * \n * @author C\n *\n */\n@Configuration\n@ComponentScan(basePackages = { \"com.ssm.config\", \"com.ssm.service.impl\" })\n@Import(DataSourceConfig.class)\npublic class RootConfig {\n\t@Bean\n\tpublic BeanNameAutoProxyCreator autoProxyCreator() {\n\t\tBeanNameAutoProxyCreator autoProxyCreator = new BeanNameAutoProxyCreator();\n\t\tautoProxyCreator.setProxyTargetClass(true);\n\t\t// 设置要创建代理的那些Bean的名字\n\t\tautoProxyCreator.setBeanNames(\"*Service\");\n\t\tautoProxyCreator.setInterceptorNames(\"transactionInterceptor\");\n\t\treturn autoProxyCreator;\n\t}\n\n}\n\n```\n\n这里数据库的事务配置方式有三种：\n\n-   第一种在 RootConfig加上 @EnableTransactionManagement 注解，配置数据库， 手动加上事务使用 [@Transactional](https://my.oschina.net/u/3770144) 注解，并且指定的传播属性，缺点麻烦\n-   第二种使用 BeanNameAutoProxyCreator拦截代理方式\n-   第三种是采用aop切面事务\n\n## 4    DataSourceConfig\n\n        这里由于我用的1.7的JDK，@PropertySources会报错，作为学习，就直接将properties文件写到类里面了\n\n```java\npackage com.ssm.config;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.apache.log4j.Logger;\nimport org.mybatis.spring.SqlSessionFactoryBean;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\nimport org.springframework.context.annotation.PropertySources;\nimport org.springframework.core.io.support.PathMatchingResourcePatternResolver;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.interceptor.TransactionInterceptor;\n\n@Configuration\n/*@PropertySources(value = { @PropertySource(\"classpath:db.properties\") }) */\n@MapperScan(\"com.ssm.mapper\")\npublic class DataSourceConfig {\n\tprivate final static Logger LOG = Logger.getLogger(DataSourceConfig.class);\n\n\tprivate String driver = \"com.mysql.jdbc.Driver\";;\n\n\tprivate String url = \"jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&transformedBitIsBoolean=true&autoReconnect=true\";\n\n\tprivate String username = \"root\";\n\n\tprivate String password = \"root\";\n\n\t@Bean\n\tpublic BasicDataSource dataSource() {\n\t\tLOG.info(\"Initialize the BasicDataSource...\");\n\t\tBasicDataSource dataSource = new BasicDataSource();\n\t\tdataSource.setDriverClassName(driver);\n\t\tdataSource.setUrl(url);\n\t\tdataSource.setUsername(username);\n\t\tdataSource.setPassword(password);\n\t\treturn dataSource;\n\t}\n\n\t// mybatis的配置\n\t@Bean\n\tpublic SqlSessionFactoryBean sqlSessionFactoryBean() throws IOException {\n\t\tResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\t\tSqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n\t\tsqlSessionFactoryBean.setDataSource(dataSource());\n\t\tsqlSessionFactoryBean.setMapperLocations(resourcePatternResolver.getResources(\"classpath*:mappers/*.xml\"));\n\t\tsqlSessionFactoryBean.setTypeAliasesPackage(\"com.ssm.mapper\");// 别名，让*Mpper.xml实体类映射可以不加上具体包名\n\t\treturn sqlSessionFactoryBean;\n\t}\n\n\t// 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\n\t@Bean(name = \"transactionManager\")\n\tpublic DataSourceTransactionManager dataSourceTransactionManager() {\n\t\tDataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();\n\t\tdataSourceTransactionManager.setDataSource(dataSource());\n\t\treturn dataSourceTransactionManager;\n\t}\n\n\t@Bean(name = \"transactionInterceptor\")\n\tpublic TransactionInterceptor interceptor() {\n\t\tTransactionInterceptor interceptor = new TransactionInterceptor();\n\t\tinterceptor.setTransactionManager(dataSourceTransactionManager());\n\t\tProperties transactionAttributes = new Properties();\n\t\ttransactionAttributes.setProperty(\"save*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"del*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"update*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"get*\", \"PROPAGATION_REQUIRED,readOnly\");\n\t\ttransactionAttributes.setProperty(\"find*\", \"PROPAGATION_REQUIRED,readOnly\");\n\t\ttransactionAttributes.setProperty(\"*\", \"PROPAGATION_REQUIRED\");\n\t\tinterceptor.setTransactionAttributes(transactionAttributes);\n\t\treturn interceptor;\n\t}\n}\n\n```\n\n## 5    测试\n\n```java\npackage com.ssm.controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.ssm.service.IndexService;\nimport com.sun.mail.handlers.image_gif;\n\n@RestController\npublic class IndexController {\n\t@Autowired\n\tprivate IndexService indexService;\n\n\t@RequestMapping(\"index\")\n\tpublic String index() {\n\t\treturn \"THIS IS A TEST.WELCOME\";\n\t}\n\n\t@RequestMapping(\"getData\")\n\tpublic String getData() {\n\t\treturn indexService.findUser();\n\t}\n\n}\n\n```\n\n### 5.1访问servlet\n\n![](https://static.oschina.net/uploads/space/2018/0322/165245_2jbO_3429289.png)\n\n### 5.2访问数据库\n\n![](https://static.oschina.net/uploads/space/2018/0322/165508_siNA_3429289.png)![](https://static.oschina.net/uploads/space/2018/0322/165413_GwmS_3429289.png)"},{"title":"dubbo+zookeeper 入门","url":"/2018/03/07/中间件/dubbo/DUBBO+ZOOKEEPER入门/","content":"\n采用spring3.2+dubbo2.5.3+zookeeper3.3.6\n\n所需架包如图所示   \n\n![](DUBBO+ZOOKEEPER入门\\1.png)\n\n# 1.安装zookeeper\n\n本文采用zookeeper-3.3.6，可自行查找下载。下载后进入conf目录下，修改zoo_sample.cfg为zoo.cfg。该文件为zookeeper的配置文件\n\n```bash\n# The number of milliseconds of each tick\ntickTime=2000\n# The number of ticks that the initial \n# synchronization phase can take\ninitLimit=10\n# The number of ticks that can pass between \n# sending a request and getting an acknowledgement\nsyncLimit=5\n# the directory where the snapshot is stored.\ndataDir=/tmp/zookeeper\n# the port at which the clients will connect\nclientPort=2181\n```\n\ntickTime：基本事件单元，以毫秒为单位。**它用来控制心跳和超时，默认情况下最小的会话超时时间为两倍的 tickTime。**\n\ndataDir：存放内存数据的地方\n\nclientPort：用户于zookeeper相连的端口\n\ninitLimit：Leader允许F在 **initLimit** 时间内完成这个工作，请求和响应时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 10*2000=20 秒\n\nsyncLimit：检测机器的存活状态，请求和响应时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒\n\n此处需注意这种文件\n\n```bash\ntickTime=2000\ndataDir=/usr/zdatadir\ndataLogDir=/usr/zlogdir\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=cloud:2888:3888\nserver.2=cloud02:2888:3888\nserver.3=cloud03:2888:3888\nserver.4=cloud04:2888:3888\nserver.5=cloud05:2888:3888\n```\n\n**server.A=B：C：D：**其中 A 是一个数字，表示这个是第几号服务器；**B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。**如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号\n\n除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，**Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。**\n\n![](DUBBO+ZOOKEEPER入门\\2.png)\n\n# 2.启动zookeeper\n\n此处我用的为第一个配置文件，并没有配置集群。直接打开zookeeper-3.3.6\\\\bin\\\\zkServer.cmd，这里我是window环境，linux环境运行.sh文件\n\n# 3.dubbo\n\n通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。\n    \ndubbo就是一个服务框架，可以实现调用远程接口像调用本地接口一样方便。\n    \n这里注册中心我们选择zookeeper\n\n## 3.1安装Dubbo-admin，实现监控\n\n这里我安装的是dubbo-admin-2.5.3.war，部署到tomcat的webapps下，修改webapps\\\\dubbo-admin-2.5.3\\\\WEB-INF\\\\dubbo.properties文件，内容如下\n\n```ini\ndubbo.registry.address=zookeeper://127.0.0.1:2181\ndubbo.admin.root.password=root\ndubbo.admin.guest.password=guest\n```\n\n其中root和guest都为密码。\n\n启动tomcat，效果如下(如提示输出账号信息，输入root，root)\n\n![](DUBBO+ZOOKEEPER入门\\3.png)\n\n## 3.2dubbo流程\n\nprovider注册----生产---->zookeeper<----消费--------consumer\n    \n生产者将接口信息注册到zookeper，消费者通过zookeeper进行消费\n\n## 3.3生产者注册\n\nProvider.java文件如下\n\n```java\npackage com.dubbotest.provider;\n \nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n \npublic class Provider {\n \n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-service.xml\");\n        context.start();\n        System.out.println(\"-----------\");\n        System.in.read(); // 为保证服务一直开着，利用输入流的阻塞来模拟,任意键退出\n    }\n}\n```\n\napplicationContext-service.xml如下\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n        http://code.alibabatech.com/schema/dubbo  \n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd  \n        \">\n \n    <bean id=\"user\" class=\"com.model.User\">\n        <property name=\"name\" value=\"person\" />\n    </bean>\n \n    <!-- 具体的实现bean -->\n    <bean id=\"demoService\" class=\"com.dubbotest.provider.DemoServiceImpl\" />\n \n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"xixi_provider\" />\n \n    <!-- 使用multicast广播注册中心暴露服务地址 <dubbo:registry address=\"multicast://224.5.6.7:1234\" \n        /> -->\n \n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n \n    <!-- 用dubbo协议在20880端口暴露服务 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n \n    <!-- 声明需要暴露的服务接口 -->\n    <!-- <dubbo:service interface=\"com.dubbotest.provider.DemoService\" ref=\"demoService\" \n        /> -->\n    <dubbo:service interface=\"com.dubbotest.provider.DemoService\"\n        ref=\"demoService\" />\n \n</beans>\n```\n\n运行了provider中的main函数后可以在dubbo-admin管理中看见接口信息。\n\n![](DUBBO+ZOOKEEPER入门\\4.png)\n\n## 3.4consumer消费\n\nConsumer.java如下\n\n```java\npackage com.dubbotest.consumer;\n \nimport java.util.List;\n \nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n \nimport com.dubbotest.provider.DemoService;\nimport com.model.User;\n \npublic class Consumer {\n \n    public static void main(String[] args) throws Exception {  \n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(  \n                new String[] { \"applicationContext-dubbo.xml\" });  \n        context.start();  \n        DemoService demoService = (DemoService) context.getBean(\"demoService\"); \n        String hello = demoService.sayHello(\"tom\"); \n        System.out.println(hello); \n        List<User> list = demoService.getUsers();  \n        if (list != null && list.size() > 0) {  \n            for (int i = 0; i < list.size(); i++) {  \n                System.out.println(list.get(i).toString());  \n            }  \n        }  \n        System.in.read();  \n    }  \n}\n```\n\napplicationContext-dubbo.xml如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"  \n        xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n            http://www.springframework.org/schema/beans/spring-beans.xsd  \n            http://code.alibabatech.com/schema/dubbo  \n            http://code.alibabatech.com/schema/dubbo/dubbo.xsd  \n            \">  \n        \n        <!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 -->  \n        <dubbo:application name=\"hehe_consumer\" />  \n       \n        <!-- 使用zookeeper注册中心暴露服务地址 -->  \n        <!-- <dubbo:registry address=\"multicast://224.5.6.7:1234\" /> -->  \n        <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />  \n       \n        <!-- 生成远程服务代理，可以像使用本地bean一样使用demoService -->  \n        <dubbo:reference id=\"demoService\"  \n            interface=\"com.dubbotest.provider.DemoService\" />  \n       \n</beans>\n```\n\n运行后结果如图 ：\n\n![](DUBBO+ZOOKEEPER入门\\5.png)\n\n## 3.5其他文件：\n\nDemoService.java\n\n```java\npackage com.dubbotest.provider;\n \nimport java.util.List;\n \npublic interface DemoService {\n    String sayHello(String name);  \n       \n    public List getUsers();  \n}\n```\n\nDemoServiceImpl.java\n\n```java\npackage com.dubbotest.provider;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \nimport org.springframework.stereotype.Component;\n \nimport com.alibaba.dubbo.config.annotation.Service;\nimport com.model.User;\n \n@Service(version=\"1.0\")//此处Component是Spring bean注解，Service是dubbo的注解\npublic class DemoServiceImpl implements DemoService{\n \n    @Override\n    public String sayHello(String name) {\n        // TODO Auto-generated method stub\n         return \"Hello \" + name;  \n    }\n \n    @Override\n    public List getUsers() {\n          List list = new ArrayList();  \n             User u1 = new User();  \n             u1.setName(\"jack\");  \n             u1.setAge(20);  \n             u1.setSex(\"男\");  \n                \n             User u2 = new User();  \n             u2.setName(\"tom\");  \n             u2.setAge(21);  \n             u2.setSex(\"女\");  \n                \n             User u3 = new User();  \n             u3.setName(\"rose\");  \n             u3.setAge(19);  \n             u3.setSex(\"女\");  \n                \n             list.add(u1);  \n             list.add(u2);  \n             list.add(u3);  \n             return list;  \n    }\n \n}\n```\n\nUser.java\n\n```java\npackage com.model;\n \nimport java.io.Serializable;\n \npublic class User implements Serializable{\n     \n    private String name;\n    private String sex;\n    private int age;\n \n    @Override\n    public String toString() {\n        return \"User [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\";\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public String getSex() {\n        return sex;\n    }\n \n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n    }\n \n}\n```","tags":["dubbo"]},{"title":"Spring源码学习——自定义标签","url":"/2017/11/28/框架系列/spring/spring-自定义标签/","content":"\n# 1.自定义标签步骤\n\n1.  创建一个需要扩展的组件\n2.  定义xsd文件描述组件内容\n3.  创建一个文件，实现BeanDefinitionParser接口，解析xsd文件中的定义和组件定义\n4.  创建handler文件，扩展NamespaceHandlerSupport，注册组件到spring容器\n5.  编写spring.handlers和spring.schemas文件\n\n# 2.代码如下\n\n## 1.编写pojo\n\n```java\npublic class User {\n\t\n\tprivate String name;\n\tprivate String sex;\n\tprivate int age;\n//省略getter、setter\n\n}\n```\n\n## 2.xsd文件描述组件内容\n\n```xml\n<?xml version=\"1.0\"?>\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://www.springtest.com/schema/user\"\n\txmlns:tns=\"http://www.springtest.com/schema/user\" elementFormDefault=\"qualified\">\n\t<!-- 表示数据类型等定义来自w3 -->\n\t<!--表示文档中要定义的元素来自什么命名空间 -->\n\t<!--表示此文档的默认命名空间是什么 -->\n\t<!--表示要求xml文档的每一个元素都要有命名空间指定 -->\n\n\t<!-- ……定义主体部分…… -->\n\t<element name=\"user\">\n\t\t<complexType>\n\t\t\t<attribute name=\"id\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"name\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"sex\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"age\" type=\"int\"></attribute>\n\t\t</complexType>\n\t</element>\n\n</schema>\n```\n\n描述了一个新的targetNamespace，并定义了一个name是user的element，有id，name，sex，age属性\n\n## 3.创建类，实现BeanDefinitionParser接口\n\n```java\npackage test.customtag;\n\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;\nimport org.springframework.util.StringUtils;\nimport org.w3c.dom.Element;\n\nimport com.model.User;\n\npublic class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\t// Element对应的类\n\tprotected Class getBeanClass(Element element) {\n\t\treturn User.class;\n\t}\n\n\t// 从element中解析并提取对应的元素\n\tprotected void doParse(Element element, BeanDefinitionBuilder bean) {\n\t\tString name = element.getAttribute(\"name\");\n\t\tString sex = element.getAttribute(\"sex\");\n\t\tString age = element.getAttribute(\"age\");\n\t\t// 将提取的数据放入到BeanDefinitionBuilder中，将所有beanbeanFactory中\n\t\tif (StringUtils.hasText(name)) {\n\t\t\tbean.addPropertyValue(\"name\", name);\n\t\t}\n\t\tif (StringUtils.hasText(sex)) {\n\t\t\tbean.addPropertyValue(\"sex\", sex);\n\t\t}\n\t\tif (StringUtils.hasText(age)) {\n\t\t\tbean.addPropertyValue(\"age\", Integer.parseInt(age));\n\t\t}\n\n\t}\n\n}\n```\n\n## 4.创建handler文件，注册spring容器\n\n```java\npackage test.customtag;\n\nimport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n\n/******创建handler文件，组件注册到spring容器***/\npublic class MyNamespaceHandler extends NamespaceHandlerSupport{\n\n\t@Override\n\tpublic void init() {\n\t\t// TODO Auto-generated method stub\n\t\tregisterBeanDefinitionParser(\"user\", new UserBeanDefinitionParser());\n\t}\n\n}\n```\n\n## 5.编写spring.handlers和spring.schemas文件，默认在工程的/META-INF/文件下\n\nspring.handlers\n\n```xml\nhttp\\://www.springtest.com/schema/user=test.customtag.MyNamespaceHandler\n```\n\nspring.schemas\n\n```xml\nhttp\\://www.springtest.com/schema/user.xsd=META-INF/Spring-test.xsd\n```\n\n此处注意：\n\n这里因为我创建的是java项目，直接在项目下建造META-INF会提示找不到对应的文件，所以这里是将文件打包成jar包导入到项目中。如下图所示\n\n![](https://static.oschina.net/uploads/space/2017/1128/113739_vNLU_3429289.png)![](https://static.oschina.net/uploads/space/2017/1128/113750_HHla_3429289.png)\n\n## 6.测试\n\n导入自定义标签\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\txmlns:myname=\"http://www.springtest.com/schema/user\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n        http://www.springtest.com/schema/user\n       \thttp://www.springtest.com/schema/user.xsd\n        \">\n\t<myname:user id=\"testBean\" name=\"aaaaaa\" sex=\"dsaf\" age=\"12\"></myname:user>\n</beans>\n```\n\n测试代码\n\n```java\n\npublic class Test {\n\t/****测试输出*/\n\t@org.junit.Test\n\tpublic void test1(){\n\t\tSystem.out.println(\"--------\");\n\t\tApplicationContext act=new ClassPathXmlApplicationContext(\"applicationContext-service.xml\");\n\t\tUser u=(User) act.getBean(\"testBean\");\n\t\tSystem.out.println(\"--------------\"+u.toString());\n\t}\n}\n```\n\n输出结果\n\n![](https://static.oschina.net/uploads/space/2017/1128/113515_sKwH_3429289.png)\n\n# 3.整个项目结构\n\n![](https://static.oschina.net/uploads/space/2017/1128/113903_VcT2_3429289.png)\n\n参考自：spring源码深度解析","tags":["spring"]},{"title":"springMVC使用websocket实现在线客服","url":"/2017/10/17/框架系列/websocket实现在线客服/","content":"\n# 1.环境\n\nspringMVC+spring+mybatis（spring4.0以上）\n\n注意需要导入spring-websocket和websocket-api包。其余架包正常ssm即可，可自行百度\n\n```xml\n<dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-websocket</artifactId>\n      <version>4.0.5.RELEASE</version> \n    </dependency>\n<dependency> \n    \t<groupId>javax.websocket</groupId>\n    \t<artifactId>javax.websocket-api</artifactId>\n    \t<version>1.1</version>\n    \t<scope>provided</scope>\n\t</dependency>\n```\n\n# 2.后台代码\n\n        用Map存放当前登录的账户及其对应的session\n\n提出几点解释：\n\n1.  @ServerEndpoint：把当前类变成websocket服务类\n2.  @OnOpen： 连接时执行\n3.  @OnClose：关闭时执行\n4.  @OnMessage：收到消息时执行\n5.  @OnError：连接错误时执行\n\n```java\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * @Description: 简单websocket demo *\n */\n@ServerEndpoint(value = \"/websocketTest/{userId}\")//@ServerEndpoint把当前类变成websocket服务类\npublic class WebsocketTest {\n\tprivate Logger logger = LoggerFactory.getLogger(WebsocketTest.class);\n\tprivate static String userId;\n\t// 连接的用户\n\tprivate static Map<String, Session> onlines = new HashMap<String, Session>();\n\n\t// 连接时执行\n\t@OnOpen\n\tpublic void onOpen(@PathParam(\"userId\") String userId, Session session) throws IOException {\n\t\tthis.userId = userId;\n\t\tonlines.put(userId, session);\n\t\tSystem.out.println(\"新连接：\" + userId);\n\n\t}\n\n\t// 关闭时执行\n\t@OnClose\n\tpublic void onClose(@PathParam(\"userId\") String userId) {\n\t\tif (onlines.containsKey(userId)) {\n\t\t\tonlines.remove(userId);\n\t\t}\n\t\tSystem.out.println(\"连接close：\" + this.userId + \" 关闭\");\n\t}\n\n\t// 收到消息时执行\n\t@OnMessage\n\tpublic void onMessage(String message, Session session, @PathParam(\"userId\") String userId) throws IOException {\n\t\tSystem.out.println(message);\n\t\tif (message.contains(\"&\")) {\n\t\t\tString[] params = message.split(\"&\");\n\t\t\tif (params[1].equals(\"all\")) {\n\t\t\t\tSystem.out.println(\"广播\");\n\t\t\t\tsendMessageToAll(userId + \"发送广播消息:\" + params[0]);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"toUser\");\n\t\t\t\tsendMessageToUser(userId, params[1], params[0]);\n\t\t\t\t;\n\t\t\t}\n\t\t}else\n\t\t\t session.getBasicRemote().sendText(userId+\"发送消息： \" + message); \n\t\tSystem.out.println(onlines.toString());\n\t}\n\n\t\n\n\n\t// 连接错误时执行\n\t@OnError\n\tpublic void onError(Session session, Throwable error) {\n\t\tSystem.out.println(\"用户id为：\" + this.userId + \"的连接发送错误\");\n\t\terror.printStackTrace();\n\t}\n\n\t/**\n\t * 广播消息给所有人\n\t * **/\n\t\tprivate void sendMessageToAll(String message) {\n\t\t\tSet<String> users = onlines.keySet();\n\t\t\tfor (String user : users) {\n\t\t\t\ttry {\n\t\t\t\t\tif (onlines.get(user).isOpen()) {\n\t\t\t\t\t\t((Session) onlines.get(user)).getBasicRemote().sendText(message);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t/******\n\t *  给某个用户发送消息 \n\t * @Param userName 发消息的name\n\t * **/\n\t\tprivate void sendMessageToUser(String userName, String receiveName, String message) {\n\t\t\tSet<String> users = onlines.keySet();\n\t\t\tfor (String user : users) {\n\t\t\t\tif (user.equals(receiveName)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (onlines.get(user).isOpen()) {\n\t\t\t\t\t\t\tSystem.out.println(\"user---\" + user);\n\t\t\t\t\t\t\t((Session) onlines.get(user)).getBasicRemote().sendText(userName + \"给你发了消息：\" + message);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\n```\n\n# 3.html\n\n## 一、操作类html\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\t广播消息---- admin\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<select id=\"toUser\" >\n\t<option id=\"toUser\" value=\"all\">ALL</option>\n\t<option id=\"toUser\" value=\"user001\">user001</option>\n\t<option id=\"toUser\" value=\"user002\">user002</option>\n\t</select>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/admin\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\tvar user = document.getElementById('toUser').value;\n\t\t\tmessage+='&'+user;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n## 二、接收类1\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\twebsocket Demo---- user001\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/user001\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n## 三、接收类2\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\twebsocket Demo---- user002\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/user002\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n4.具体效果\n\n截图如下，实现简单web聊天功能。\n\n","tags":["springmvc"]},{"title":"Shiro简介","url":"/2017/09/02/中间件/shiro/Apache-shiro学习/","content":"\n# 1.Shiro简介\n\nShiro 可以帮助我们完成：认证、授权、加密、会话管理、与Web 集成、缓存等\n\n![](https://static.oschina.net/uploads/space/2017/0902/160620_MqP6_3429289.png)\n\n其中工作原理主要如图，进入后创建一个Subject（即为当前用户），然后SecurityManager管理所有Subject，这里可以理解为于SpringMVC的DispatcherServlet，最后我们Realm相当于是一个数据源，管理用户身份是否合法。\n\n# 2.入门示例\n\n```java\n@Test\npublic void testHelloworld() {\n//1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager\nFactory<org.apache.shiro.mgt.SecurityManager> factory =\nnew IniSecurityManagerFactory(\"classpath:shiro.ini\");\n//2、得到SecurityManager实例并绑定给SecurityUtils\norg.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();\nSecurityUtils.setSecurityManager(securityManager);\n//3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）\nSubject subject = SecurityUtils.getSubject();\nUsernamePasswordToken token = new UsernamePasswordToken(\"zhang\", \"123\");\ntry {\n//4、登录，即身份验证\nsubject.login(token);\n} catch (AuthenticationException e) {\n//5、身份验证失败\n}\nAssert.assertEquals(true, subject.isAuthenticated()); //断言用户已经登录\n//6、退出\nsubject.logout();\n}\n```\n\n2.1、首先通过new IniSecurityManagerFactory 并指定一个ini 配置文件来创建一个SecurityManager工厂；\n\n2.2、接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可；  \n2.3、通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结  \n束时需要解除绑定；然后获取身份验证的Token，如用户名/密码；  \n2.4、调用subject.login 方法进行登录，其会自动委托给SecurityManager.login方法进行登录；  \n2.5、如果身份验证失败请捕获AuthenticationException 或其子类;\n\n2.6、最后可以调用subject.logout退出\n\n# 3.与web集成\n\n```xml\n<dependency>\n<groupId>org.apache.shiro</groupId>\n<artifactId>shiro-web</artifactId>\n<version>1.2.2</version>\n</dependency>\n<dependency>\n<groupId>junit</groupId>\n<artifactId>junit</artifactId>\n<version>4.9</version>\n</dependency>\n<dependency>\n<groupId>commons-logging</groupId>\n<artifactId>commons-logging</artifactId>\n<version>1.1.3</version>\n</dependency>\n<dependency>\n<groupId>org.apache.shiro</groupId>\n<artifactId>shiro-core</artifactId>\n<version>1.2.2</version>\n</dependency>\n```\n\n## 必要的架包。\n\n## web.xml如图所示\n\n```xml\n<filter>\n\t\t<filter-name>shiroFilter</filter-name>\n\t\t<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n\t</filter>\n\n\t<filter-mapping>\n\t\t<filter-name>shiroFilter</filter-name>\n\t\t<url-pattern>*.shtml</url-pattern>\n\t</filter-mapping>\n```\n\nDelegatingFilterProxy作用是自动到spring容器查找名字为shiroFilter（filter-name）的bean并把所有Filter的操作委托给它，然后将ShiroFilter 配置到spring容器即可\n\n```xml\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n\t\t<property name=\"securityManager\" ref=\"securityManager\" />\n</bean>\n```\n\n## ini配置部分说明\n\n```xml\n[main]\n#默认是/login.jsp\nauthc.loginUrl=/login\nroles.unauthorizedUrl=/unauthorized\nperms.unauthorizedUrl=/unauthorized\n[users]\nzhang=123,admin\nwang=123\n[roles]\nadmin=user:*,menu:*\n[urls]\n/login=anon\n/unauthorized=anon\n/static/**=anon\n/authenticated=authc\n/role=authc,roles[admin]\n/permission=authc,perms[\"user:create\"]\n```\n\n其中最重要的就是\\[urls\\]部分的配置，其格式是： “url=拦截器\\[参数\\]，拦截器\\[参数\\]”；  \n即如果当前请求的url匹配\\[urls\\]部分的某个url模式，将会执行其配置的拦截器。比如anon  \n拦截器表示匿名访问（即不需要登录即可访问）；authc拦截器表示需要身份认证通过后才  \n能访问；roles\\[admin\\]拦截器表示需要有admin 角色授权才能访问；而perms\\[\"user:create\"\\]  \n拦截器表示需要有“user:create”权限才能访问\n\n暂时就看到这里，作一个记录，下次继续更新","tags":["shiro"]},{"title":"微信公众号接入","url":"/2017/05/20/开发相关/微信公众号接入/","content":"\nPACKAGE\n\n![](https://static.oschina.net/uploads/space/2017/0522/172756_NC0S_3429289.png)\n\n1.MenuManage\n\n```java\n/**\n * 创建菜单\n * */\npublic class MenuManager {\n\tprivate static Logger log = LoggerFactory.getLogger(MenuManager.class);\n\n\tpublic static void main(String[] args) {\n\t\t// 第三方用户唯一凭证\n\t\tString appId = \"000000000000000000\";\n\t\t// 第三方用户唯一凭证密钥\n\t\tString appSecret = \"00000000000000000000000000000000\";\n\n\t\t// 调用接口获取access_token\n\t\tAccessToken at = WeixinUtil.getAccessToken(appId, appSecret);\n\t\t\n\t\tif (null != at) {\n\t\t\t// 调用接口创建菜单\n\t\t\tint result = WeixinUtil.createMenu(getMenu(), at.getToken());\n\n\t\t\t// 判断菜单创建结果\n\t\t\tif (0 == result)\n\t\t\t\tlog.info(\"菜单创建成功！\");\n\t\t\telse\n\t\t\t\tlog.info(\"菜单创建失败，错误码：\" + result);\n\t\t}\n\t}\n\n\tprivate static Menu getMenu() {\n\t\t// TODO Auto-generated method stub\n\t\tCommonButton btn11 = new CommonButton();\n\t\tbtn11.setName(\"测试1\");\n\t\tbtn11.setType(\"click\");\n\t\tbtn11.setKey(\"11\");\n\t\t\n\t\tCommonButton btn12 = new CommonButton();\n\t\tbtn12.setName(\"测试2\");\n\t\tbtn12.setType(\"click\");\n\t\tbtn12.setKey(\"12\");\n\n\t\tCommonButton btn13 = new CommonButton();\n\t\tbtn13.setName(\"测试3\");\n\t\tbtn13.setType(\"click\");\n\t\tbtn13.setKey(\"13\");\n\n\t\tCommonButton btn14 = new CommonButton();\n\t\tbtn14.setName(\"测试4\");\n\t\tbtn14.setType(\"click\");\n\t\tbtn14.setKey(\"14\");\n\n\t\tCommonButton btn21 = new CommonButton();\n\t\tbtn21.setName(\"快递查询\");\n\t\tbtn21.setType(\"click\");\n\t\tbtn21.setKey(\"21\");\n\n\t\tCommonButton btn22 = new CommonButton();\n\t\tbtn22.setName(\"经典游戏\");\n\t\tbtn22.setType(\"click\");\n\t\tbtn22.setKey(\"22\");\n\n\n\t\tCommonButton btn23 = new CommonButton();\n\t\tbtn23.setName(\"聊天唠嗑\");\n\t\tbtn23.setType(\"click\");\n\t\tbtn23.setKey(\"23\");\n\n\n\t\tCommonButton btn31 = new CommonButton();\n\t\tbtn31.setName(\"Q友圈\");\n\t\tbtn31.setType(\"click\");\n\t\tbtn31.setKey(\"31\");\n\n\t\tCommonButton btn32 = new CommonButton();\n\t\tbtn32.setName(\"电影排行榜\");\n\t\tbtn32.setType(\"click\");\n\t\tbtn32.setKey(\"32\");\n\n\t\tCommonButton btn33 = new CommonButton();\n\t\tbtn33.setName(\"更多帮助\");\n\t\tbtn33.setType(\"click\");\n\t\tbtn33.setKey(\"33\");\n\n\t\tComplexButton mainBtn1 = new ComplexButton();\n\t\tmainBtn1.setName(\"测试按钮\");\n\t\tmainBtn1.setSub_button(new CommonButton[] { btn11, btn12, btn13, btn14 });\n\n\t\tComplexButton mainBtn2 = new ComplexButton();\n\t\tmainBtn2.setName(\"休闲驿站\");\n\t\tmainBtn2.setSub_button(new CommonButton[] { btn21, btn22, btn23});\n\n\t\tComplexButton mainBtn3 = new ComplexButton();\n\t\tmainBtn3.setName(\"更多帮助\");\n\t\tmainBtn3.setSub_button(new CommonButton[] { btn31, btn32, btn33 });\n\n\t\t/**\n\t\t * 此菜单结构，每个一级菜单都有二级菜单项\n\t\t */\n\t\tMenu menu = new Menu();\n\t\tmenu.setButton(new Button[] { mainBtn1, mainBtn2, btn33 });\n\t\t\n\t\treturn menu;\n\t}\n\n}\n```\n\nBaseServlet\n\n```java\npublic class BaseServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * 认证微信服务器\n\t */\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t// 微信加密签名\n\t\tString signature = req.getParameter(\"signature\");\n\t\t// 时间\n\t\tString timestamp = req.getParameter(\"timestamp\");\n\t\t// 随机数\n\t\tString nonce = req.getParameter(\"nonce\");\n\t\t// 随机字符串\n\t\tString echostr = req.getParameter(\"echostr\");\n\t\tPrintWriter out = resp.getWriter();\n\t\t// 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败\n\t\tif (SignUtil.checkSignature(signature, timestamp, nonce)) {\n\t\t\tout.print(echostr);\n\t\t}\n\t\tout.close();\n\t\tout = null;\n\t}\n\n\t/**\n\t * 用户消息处理\n\t */\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\t// 将请求、响应的编码均设置为UTF-8（防止中文乱码）\n\t\treq.setCharacterEncoding(\"UTF-8\");\n\t\tresp.setCharacterEncoding(\"UTF-8\");\n\t\t// Service处理请求\n\t\tString result = null;\n\t\ttry {\n\t\t\t// 默认返回内容\n\t\t\tString respContent = \"测试微信公众号\";\n\t\t\tMap<String, String> requestMap = MessageUtil.parseXml(req);\n\t\t\tString fromUserName = requestMap.get(\"FromUserName\");\n\t\t\tString toUserName = requestMap.get(\"ToUserName\");\n\t\t\tString msgType = requestMap.get(\"MsgType\");\t\n\t\t\tBaseService baseService=new BaseService();\n\t\t\t// 回复文本消息\n\t\t\tif(MessageUtil.REQ_MESSAGE_TYPE_TEXT.equals(msgType)){\n\t\t\t\tString content=requestMap.get(\"Content\");\n\t\t\t\tTextMessageReq textMessageReq=new TextMessageReq(toUserName, fromUserName, msgType, content);\n\t\t\t\tresult=baseService.dealTextReq(textMessageReq);\t\n\t\t\t}else if(MessageUtil.REQ_MESSAGE_TYPE_EVENT.equals(msgType)){\n\t\t\t\t// 事件类型   \n\t\t\t\tString eventType = requestMap.get(\"Event\");\n\t\t\t\tif (eventType.equals(MessageUtil.EVENT_TYPE_SUBSCRIBE)){\n\t\t\t\t\tresult = \"谢谢您的关注！回复\\\"0\\\"查看帮助\";\n\t\t\t\t}else if(MessageUtil.EVENT_TYPE_CLICK.equals(eventType)){\n\t\t\t\t\t// 菜单点击key值\n\t\t\t\t\tString eventKey = requestMap.get(\"EventKey\");  \n\t\t\t\t\tresult=baseService.dealClickReq(toUserName,fromUserName,msgType,eventKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tPrintWriter out = resp.getWriter();\n\t\tout.write(result);\n\t\tout.close();\n\n\t}\n\n}\n```\n\nBaseService\n\n```java\n/**\n * 消息处理\n */\npublic class BaseService {\n\t/**\n\t * 文本消息处理\n\t */\n\tpublic String dealTextReq(TextMessageReq textMessageReq) {\n\t\tString result = null;\n\t\tif (\"0\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(MessageTemplate.getMainMenu());\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"1\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\n\t\t\t\t\t\"<a href=\\\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\\\">点击跳转网页welcome</a>\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"2\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\n\t\t\t\t\t\"<a href=\\\"http://rotornet.tunnel.qydev.com/WXTest/jsp/content.jsp\\\">点击跳转网页content</a>\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"3\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getSingleNews();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else if (\"4\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getSingleNewsNoImage();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else if (\"5\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getNews();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\"没有找到指令，请重新输入\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t}\n\t\treturn result;\n\n\t}\n\n\t/** 菜单点击事件 */\n\tpublic String dealClickReq(String toUserName, String fromUserName, String msgType, String eventKey) {\n\t\t// TODO Auto-generated method stub\n\t\tString result = null;\n\t\tTextMessageResp textMessageResp = getTextMessageResp(toUserName,fromUserName);\n\t\tif (eventKey.equals(\"11\")) {\n\t\t\ttextMessageResp.setContent(\"测试1被点击\");\n\t\t}else if (eventKey.equals(\"12\")) {\n\t\t\ttextMessageResp.setContent(\"测试2被点击\");\n\t\t}else if (eventKey.equals(\"13\")) {\n\t\t\ttextMessageResp.setContent(\"测试3被点击\");\n\t\t}else if (eventKey.equals(\"14\")) {\n\t\t\ttextMessageResp.setContent(\"测试4被点击\");\n\t\t}else if (eventKey.equals(\"21\")) {\n\t\t\ttextMessageResp.setContent(\"快递查询被点击\");\n\t\t}else if (eventKey.equals(\"22\")) {\n\t\t\ttextMessageResp.setContent(\"经典游戏被点击\");\n\t\t}else if (eventKey.equals(\"23\")) {\n\t\t\ttextMessageResp.setContent(\"聊天唠嗑被点击\");\n\t\t}else if (eventKey.equals(\"33\")) {\n\t\t\ttextMessageResp.setContent(MessageTemplate.getMainMenu());\n\t\t}else{\n\t\t\ttextMessageResp.setContent(\"未找到功能\");\n\t\t}\n\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\treturn result;\n\t}\n\t/**此处和接收到的发送者，接受者相反*/\n\tprivate NewsMessageResp getNewsMessageResp(String fromUserName, String toUserName) {\n\t\t// TODO Auto-generated method stub\n\t\tNewsMessageResp newsMessage = new NewsMessageResp();\n\t\tnewsMessage.setFromUserName(fromUserName);\n\t\tnewsMessage.setToUserName(toUserName);\n\t\tnewsMessage.setCreateTime(new Date().getTime());\n\t\tnewsMessage.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);\n\t\tnewsMessage.setFuncFlag(0);\n\t\treturn newsMessage;\n\t}\n\t/**此处和接收到的发送者，接受者相反*/\n\tprivate TextMessageResp getTextMessageResp(String fromUserName, String toUserName) {\n\t\tTextMessageResp textMessageResp = new TextMessageResp();\n\t\ttextMessageResp.setFromUserName(fromUserName);\n\t\ttextMessageResp.setToUserName(toUserName);\n\t\ttextMessageResp.setCreateTime(new Date().getTime());\n\t\ttextMessageResp.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);\n\t\ttextMessageResp.setFuncFlag(0);\n\t\treturn textMessageResp;\n\t}\n}\n```\n\nMessageTemplate\n\n```java\n/**\n * 消息模板\n */\npublic class MessageTemplate {\n\t/**\n\t * 主菜单消息\n\t */\n\tpublic static String getMainMenu() {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tbuffer.append(\"您好/::)，请回复数字选择服务：\").append(\"\\n\\n\");\n\t\tbuffer.append(\"1  网页welcome预览\").append(\"\\n\");\n\t\tbuffer.append(\"2  网页content预览\").append(\"\\n\");\n\t\tbuffer.append(\"3  单图文消息预览1\").append(\"\\n\");\n\t\tbuffer.append(\"4  单图文消息预览2\").append(\"\\n\");\n\t\tbuffer.append(\"5  多图文消息预览\").append(\"\\n\\n\");\n\t\tbuffer.append(\"回复“0”显示此帮助菜单\");\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * 超链接信息\n\t */\n\tpublic static String getUrlContent(String content, String url) {\n\t\treturn \"<a href=\\\"\" + url + \"\\\">\" + content + \"</a>\";\n\t}\n\n\t/**\n\t * 单图文消息\n\t */\n\tpublic static List<ArticleResp> getSingleNews() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article = new ArticleResp();\n\t\tarticle.setTitle(\"微信公众帐号开发教程Java版\");\n\t\tarticle.setDescription(\"测试微信公众号单图文消息-\"+String.valueOf(Character.toChars(0x1F334))+\"\");\n\t\tarticle.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower.jpg\");\n\t\tarticle.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article);\n\t\treturn articles;\n\t}\n\n\t/**\n\t * 单图文消息---不含图片\n\t */\n\tpublic static List<ArticleResp> getSingleNewsNoImage() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article = new ArticleResp();\n\t\tarticle.setTitle(\"微信公众帐号单图文消息测试\");\n\t\tarticle.setDescription(\"测试微信公众号单图文消息--无图片\"+String.valueOf(Character.toChars(0x2764))+\"心分两半，一半清醒，一半醉\");\n\t\t//图片设置为空\n\t\tarticle.setPicUrl(\"\");\n\t\tarticle.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article);\n\t\treturn articles;\n\t}\n\t/**多图文消息*/\n\tpublic static List<ArticleResp> getNews() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article1 = new ArticleResp();\n\t\tarticle1.setTitle(\"微信公众号多图文消息\");\n\t\t//description页面不会显示\n\t\tarticle1.setDescription(\"\");\n\t\tarticle1.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower3.jpg\");\n\t\tarticle1.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tArticleResp article2 = new ArticleResp();\n\t\tarticle2.setTitle(\"微信\"+String.valueOf(Character.toChars(0x1F334))+\"公众号图文消息二\");\n\t\t//description页面不会显示\n\t\tarticle2.setDescription(\"\");\n\t\tarticle2.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower2.jpg\");\n\t\tarticle2.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tArticleResp article3 = new ArticleResp();\n\t\tarticle3.setTitle(\"微信\"+String.valueOf(Character.toChars(0x1F339))+\"公众号图文消息三\");\n\t\tarticle3.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower1.jpg\");\n\t\tarticle3.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article1);\n\t\tarticles.add(article2);\n\t\tarticles.add(article3);\n\t\treturn articles;\n\t}\n\t\n}\n```\n\nimages\n\n![](微信公众号接入\\1.jpg)\n\n![](微信公众号接入\\2.jpg)\n\n![](微信公众号接入\\3.jpg)\n\n![](微信公众号接入\\4.jpg)\n\nwelcome.jsp\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.css\">\n<script src=\"https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js\"></script>\n<script src=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.js\"></script>\n</head>\n\n<body>\n\n<div data-role=\"page\">\n  <div data-role=\"header\">\n    <h1>欢迎来到我的微信测试公众号</h1>\n  </div>\n\n  <div data-role=\"main\" class=\"ui-content\">\n    <p>这是一个简单的测试公众号!!</p>\n  </div>\n\n  <div data-role=\"footer\">\n    <h1>有疑问欢迎致电客服</h1>\n  </div>\n</div> \n\n</body>\n</html>\n```\n\ncontent.jsp\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.css\">\n<script src=\"https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js\"></script>\n<script src=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.js\"></script>\n</head>\n<script>\n  function message(){\n\t  var chk_value =[]; \n\t  var name=$(\"#name\").val();\n\t  $(\"input[name='favcolor']:checked\").each(function(){\n\t\t  chk_value.push($(this).val()); \n\t  });\n\t  alert(\"您的全名是:\"+name+\" 您喜欢的颜色是：\"+chk_value);\n  }\n</script>\n<body>\n\n<div data-role=\"page\">\n  <div data-role=\"header\">\n  <h1>公众号主题页面</h1>\n  </div>\n  <div data-role=\"main\" class=\"ui-content\">\n    <form method=\"post\" >\n      <fieldset data-role=\"collapsible\" data-theme=\"b\" data-content-theme=\"b\">\n        <legend>点击可折叠</legend>\n          <label for=\"name\">全名:</label>\n          <input type=\"text\" name=\"text\" id=\"name\" data-theme=\"a\">\n          <p>喜爱的颜色:</p>\n        <div data-role=\"controlgroup\">\n          <label for=\"red\">红色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"red\" value=\"red\">\n          <label for=\"green\">绿色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"green\" value=\"green\">\n          <label for=\"blue\">蓝色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"blue\" value=\"blue\" >\n        </div>\t\n      <input type=\"button\" data-inline=\"true\" onclick=\"message()\"  value=\"提交\" data-theme=\"b\">\n      </fieldset>\n    </form>\n  </div>\n</div>\n\n</body>\n</html>\n```","tags":["公众号"]},{"title":"nginx+tomcat入门配置","url":"/2017/04/21/中间件/nginx/nginx+tomcat入门配置/","content":"\n    此文仅作入门学习，以及记录下配置中遇到的坑。首先nginx+tomcat主要为了实现负载均衡 (分发请求)。为了解释清楚负载均衡，这里假设www.test.com采用这种配置，当我们去访问www.test.com这个网址的时候，请求是传到了nginx服务器，然后由nginx分发到tomcat，假设我们启动了10个tomcat，nginx根据我们的配置分发请求给指定的tomcat，减轻服务器压力。\n\n# 1.工具\n\nnginx-1.8.0\n\napache-tomcat-6.0.20\n\napache-tomcat-8.0.30\n\n# 2.Nginx+tomcat配置\n\n解压后在nginx-1.8.0\\\\conf\\\\中找到Nginx配置文件nginx.conf进行配置。\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\t#location / {\n        #    proxy_pass http://backend_tomcat;\n        #}\n        }\n```\n\n先找到配置文件中server{}，这里listen 8080监听8080端口\n\n如果启动了nginx，输入http://localhost:8080会看见![](https://static.oschina.net/uploads/space/2017/0421/103109_IUKW_3429289.png)\n\n接下来取消注解location / {  \n            proxy\\_pass http://backend\\_tomcat;  \n        }这里标示将请求转发给backend_tomcat（名字随意），然后在http里配置backend_tomcat，与server同一级。\n\n```xml\nhttp{\n\tupstream backend_tomcat{\n\t\t\n\t\tserver 127.0.0.1:80 weight=1;\n\t\tserver 127.0.0.1:8888 weight=1;\n\t}\n\t\n    server {\n    }\n}\n```\n\n这里配置两个server对应两个tomcat，一个80端口的tomcat6，一个8888端口的tomcat8，weight表示访问的权重。\n\n配置好后，启动tomcat6和tomcat8，启动nginx，访问http://localhost:8080一直刷新，会看见在tomcat6和tomcat8界面切换。实现分发请求\n\n# 3.nginx实现静态分离\n\n这里主要说在使用nginx时，由于我们的请求是转发的，所以对于静态的文件无法直接加载，这里需要配置静态分离，即将js，css，image等静态资源放在nginx服务器，jsp，do，action等去分发请求。\n\n操作如下\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\n\t\tlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\t\n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   html;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\t\n\t\t\tproxy_pass http://backend_tomcat;\n\t\t}\n}\n```\n\n这里贴出代码注意，此时需要将第二点处的location /(如下图) 改为location ~ \\\\.(jsp|action)$(如上图)，第一个表示所有请求，第二个表示拦截以.jsp或者.action结尾的请求\n\nroot html表示拦截到的静态文件去html文件夹找，这里的html文件夹表示安装目录\\\\nginx-1.8.0\\\\html文件夹，可以在html里放一个test文件夹，放一个图片test.png，启动nginx，输入http://localhost:8080/test/test.png，此时可以访问\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\tlocation / {\n            proxy_pass http://backend_tomcat;\n        }\n        }\n```\n\n# 4.nignx配置导向项目\n\n        如果按上述配置将请求转发到项目位置，并将项目静态文件放到html文件夹下，此时发现报错，查看文件时发现在服务器的jsp页面中的basePath会被解析为backend_tomcat加上端口+项目名，系统找不到backend\\_tomcat，此时需要在添加proxy\\_set\\_header Host， proxy\\_set_header，这里作用及时重写请求头，防止后端服务器处理时认为所有请求都来自反向代理服务器。\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\t#location / {\n        #    proxy_pass http://backend_tomcat;\n        #}\n\t\tlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   filetest;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n\t\t\tproxy_pass http://backend_tomcat;\n\t\t}\n```\n\n如图，配置后，重跑ngnix，发现请求地址对了，但是对于nginx中的静态文件未显示端口，加载不出静态文件。此时再加上host中的端口，如下图\n\n```xml\nlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\tproxy_set_header Host  $host:8080; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   filetest;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n\t\t\tproxy_pass http://backend_tomcat;\n```\n\n重新启动nginx，配置完成，正常访问","tags":["nginx"]}]