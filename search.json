[{"title":"链表","url":"/2020/11/15/算法/链表/","content":"## 单链表\n\n单链表即一个节点单向的指向下一个节点。\n\n数据结构\n\n```JAVA\nclass Node {\n    public String value;\n    public HeroNode next;\n}\n```\n\n单链表的遍历主要是用到while循环\n\n### 案例演示\n\nhttps://github.com/mk-passby/mk_learn/blob/master/algs/src/main/java/com/learn/mk/guigu/linklist/SignalLinkListDemo.java\n\n### 单链表面试题\n\n- 求单链表中有效节点的个数\n\n```java\npublic int getCount() {\n        if (heroNode.next == null) {\n            System.out.println(\"链表为空\");\n            return 0;\n        }\n        int result = 0;\n        HeroNode temp = heroNode;\n        while (temp.next != null) {\n            result++;\n            temp = temp.next;\n        }\n        return result;\n    }\n```\n\n\n\n- 查找单链表中的倒数第 k 个结点\n\n```java\n/**\n     * 查找倒数第K个元素\n     */\n    public HeroNode findByIndex(int index) {\n        if (index <= 0 || heroNode.next == null) {\n            return null;\n        }\n        int size = getCount();\n        if (index > size) {\n            return null;\n        }\n        HeroNode current = heroNode.next;\n        for (int i = 0; i < size - index; i++) {\n            current = current.next;\n        }\n        return current;\n    }\n```\n\n- 单链表的反转【腾讯面试题，有点难度】\n  - 讲解下while中的思路，从原始的单链表中取一个元素出来，然后放到reverseHead的第一个位置，\n  - 假设heroNode中是1，2，3，4，reverseHead为null\n  - 第一次取出来后，heroNode应该为2，3，4，reverseHead为1\n  - 第二次取出来后，heroNode应该为3，4，reverseHead为2，1\n  - 第三次取出来后，heroNode应该为4，reverseHead为3，2，1\n  - 第四次取出来后，heroNode应该为null，reverseHead为4，3，2，1\n  - 最后，将heroNode.next指向reverseHead.next，完成反转\n\n```java\n\n\n /**\n     * 反转单链表\n     */\n    public void reverseNode() {\n        if (heroNode.next == null || heroNode.next.next == null) {\n            return;\n        }\n        HeroNode current = heroNode.next;\n        HeroNode next = null;\n        HeroNode reverseHead = new HeroNode(0, null, null);\n        while (current != null) {\n            //缓存next,方便下一次遍历\n            next = current.next;\n            current.next = reverseHead.next;\n            reverseHead.next = current;\n            current = next;\n        }\n        heroNode.next = reverseHead.next;\n    }\n```\n\n\n\n- 从尾到头打印单链表 【百度，要求方式 1：反向遍历 。 方式 2：Stack 栈】\n  - 直接说一下解题思路吧\n    - 先反转，再遍历，该方式破坏了原单链表的结构，不建议\n    - 使用stack，\n\n- 合并两个有序的单链表，要求合并后也任然有序\n  - 待补充\n\n\n\n\n\n## 双向链表","tags":["数据结构和算法"]},{"title":"稀疏数组","url":"/2020/11/15/算法/稀疏数组/","content":"\n\n\n## 应用场景\n\n当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。\n\n\n\n稀疏数组的处理方法是:\n\n1)记录数组一共有几行几列，有多少个不同的值\n\n2)把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模\n\n如原始数组\n\n```\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n```\n\n\n\n转换稀疏数组后\n\n```\n11\t11\t2\t\n1\t2\t1\t\n2\t3\t2\n```\n\n### 解释\n\n如上面所示，转换后的数组\n\n- 第一行`11 11 2`表示原始数组有多少行，多少列，总共多少元素。即11行，11列，共2个元素\n- 第二行`1 2 1`表示，第一个元素在2行(a[1])，3列(b[2])，值为1\n- 第三行`2 3 2`表示，第二个元素在3行4列，值为2\n\n\n\n### 优点\n\n可以看到我们最初的数组`11*11`的二维数据，经过转换后得到`3*3`的二维数组，节约了内存\n\n\n\n\n\n## 代码实现\n\n\n\n```java\npackage com.learn.mk.guigu.sparsearray;\n\n/**\n * @program: learning-demo\n * @description: 稀疏数组\n * @author: mk_passby\n * @create: 2020-11-10 22:32\n **/\npublic class SparseArray {\n\n    public static void main(String[] args) {\n        int[][] chessArray = new int[11][11];\n        chessArray[1][2] = 1;\n        chessArray[2][3] = 2;\n        System.out.println(\"输出原始数组:\");\n        for (int[] row : chessArray) {\n            for (int i : row) {\n                System.out.printf(\"%d\\t\", i);\n            }\n            System.out.println();\n        }\n\n        System.out.println(\"组装稀疏数组中\");\n        int sum = 0;\n        //遍历，得到非0个数\n        for (int[] row : chessArray) {\n            for (int i : row) {\n                if (i != 0) {\n                    sum++;\n                }\n            }\n        }\n        //构建结果数组\n        int[][] sparseArr = new int[sum + 1][3];\n        //组装结果数组\n        sparseArr[0][0] = 11;\n        sparseArr[0][1] = 11;\n        sparseArr[0][2] = sum;\n        int temp = 0;\n        for (int i = 0; i < chessArray.length; i++) {\n            for (int j = 0; j < chessArray[i].length; j++) {\n                if (chessArray[i][j] != 0) {\n                    temp++;\n                    sparseArr[temp][0] = i;\n                    sparseArr[temp][1] = j;\n                    sparseArr[temp][2] = chessArray[i][j];\n                }\n            }\n        }\n        System.out.println(\"输出稀疏数组\");\n        //遍历输出结果数组\n        for (int[] row : sparseArr) {\n            for (int i : row) {\n                System.out.printf(\"%d\\t\", i);\n            }\n            System.out.println();\n        }\n        System.out.println(\"还原稀疏数组\");\n        //确保原始数组有值\n        if (sparseArr != null && sparseArr.length == 3) {\n            int[][] chessArrResult = new int[sparseArr[0][0]][sparseArr[0][1]];\n            int chessArrResultSum = sparseArr[0][2];\n            for (int i = 1; i <= chessArrResultSum; i++) {\n                chessArrResult[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];\n            }\n\n            System.out.println(\"输出从稀疏数组还原的数据:\");\n            for (int[] row : chessArrResult) {\n                for (int i : row) {\n                    System.out.printf(\"%d\\t\", i);\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n#### 控制台结果\n\n```shell\n\n输出原始数组:\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n组装稀疏数组中\n输出稀疏数组\n11\t11\t2\t\n1\t2\t1\t\n2\t3\t2\t\n还原稀疏数组\n输出从稀疏数组还原的数据:\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t1\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t2\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t\n\nProcess finished with exit code 0\n\n\n```\n\n","tags":["数据结构和算法"]},{"title":"队列","url":"/2020/11/15/算法/队列/","content":"## 数组实现环形队列\n\n\n\n思路：\n\n- 需求保存数组大小，所以需要maxSize存储\n- 需要确定当前数组中元素的位置，所有需要一个队列头和队列尾的索引\n- 数据需要维护，所以需要一个arr数组\n\n```java\npublic class CircleQueue {\n    private int maxSize;\n    private int front;//指向队列头\n    private int rear;//指向队列尾\n    private int[] arr;\n}\n```\n\n代码实现：\n\n- 核心思路就是取余满足环形\n\nhttps://github.com/mk-passby/mk_learn/blob/master/algs/src/main/java/com/learn/mk/guigu/queue/CircleQueue.java\n\n\n\n","tags":["数据结构和算法"]},{"title":"常见算法排序","url":"/2020/11/09/算法/二叉树的遍历/","content":"\n## 遍历方式\n\n 二叉树的遍历\n       1\n      / \\\n     2   3\n    /\\    \\\n   4  5    6\n       /\\\n     7  8\n  前序:根结点 ---> 左子树 ---> 右子树   12457836\n  中序:左子树---> 根结点 ---> 右子树    42758136\n  后序:左子树 ---> 右子树 ---> 根结点   47852631\n  层次遍历：1  2  3  4  5  6  7 8\n\n## 代码实现\n\n定义一个简单的二叉树结构\n\n```java\nclass TreeNode {\n    TreeNode left;\n    TreeNode right;\n    Integer value;\n\n    public TreeNode(TreeNode left, TreeNode right, Integer value) {\n        this.left = left;\n        this.right = right;\n        this.value = value;\n    }\n}\n```\n\n\n\n### 递归实现前序遍历\n\n\n\n```java\npublic static void preOrderTraverse1(TreeNode treeNode) {\n        if (treeNode != null) { \n            System.out.println(treeNode.value);\n            preOrderTraverse1(treeNode.left);\n            preOrderTraverse1(treeNode.right);\n        }\n    }\n```\n\n### 递归实现中序遍历\n\n```java\npublic static void middleOrderTraverse1(TreeNode treeNode) {\n        if (treeNode != null) {\n            middleOrderTraverse1(treeNode.left);\n            System.out.println(treeNode.value);\n            middleOrderTraverse1(treeNode.right);\n        }\n    }\n```\n\n### 递归实现后序遍历\n\n```java\npublic static void afterOrderTraverse1(TreeNode treeNode) {\n        if (treeNode != null) {\n            afterOrderTraverse1(treeNode.left);\n            afterOrderTraverse1(treeNode.right);\n            System.out.println(treeNode.value);\n        }\n    }\n```\n\n\n\n\n\n### 非递归实现\n\n非递归则需要我们保存部分数据，这里需要使用到栈这种数据结构\n\n#### 前序遍历\n\n将右节点存储到栈中，依次取出就行。\n\n```java\n public static void preOrderTraverse2(TreeNode treeNode) {\n        Stack<TreeNode> stack = new Stack();\n        TreeNode pNode = treeNode;\n        while (pNode != null || !stack.isEmpty()) {\n            if (pNode != null) {\n                System.out.print(pNode.value + \"  \");\n                stack.push(pNode);\n                pNode = pNode.left;\n            }\n            else { //pNode == null && !stack.isEmpty()\n                TreeNode node = stack.pop();\n                pNode = node.right;\n            }\n        }\n    }\n```\n\n#### 中序遍历\n\n同前序遍历\n\n```java\npublic static void middleOrderTraverse2(TreeNode treeNode) {\n        Stack<TreeNode> stack = new Stack();\n        TreeNode pNode = treeNode;\n        while (pNode != null || !stack.isEmpty()) {\n            if (pNode != null) {\n                stack.push(pNode);\n                pNode = pNode.left;\n            }\n            else { //pNode == null && !stack.isEmpty()\n                TreeNode node = stack.pop();\n                System.out.print(node.value + \"  \");\n                pNode = node.right;\n            }\n        }\n    }\n```\n\n#### 后续遍历\n\n利用反转，为了得到\"左->右->根\"，先得到\"根->右->左\"\n\n```java\npublic static void afterOrderTraverse2(TreeNode treeNode) {\n        List<Integer> list = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack();\n        stack.push(treeNode);\n        while (!stack.isEmpty()) {\n            TreeNode treeNodeStack = stack.pop();\n            if (treeNodeStack != null) {\n                System.out.println(treeNodeStack.value);\n                list.add(treeNodeStack.value);\n            }\n            if (treeNodeStack.left != null) {\n                stack.push(treeNodeStack.left);\n            }\n            if (treeNodeStack.right != null) {\n                stack.push(treeNodeStack.right);\n            }\n        }\n        Collections.reverse(list);\n        System.out.println(Arrays.toString(list.toArray()));\n    }\n```\n\n\n\n代码位置","tags":["数据结构和算法"]},{"title":"分布式消息队列kafka","url":"/2020/11/04/分布式/消息队列kafka/","content":"\n## 为什么用消息队列？\n\n什么业务场景？有什么难点？用了消息队列解决了什么问题，带来了什么好处？\n\n- 消息队列的优点\n  - 解耦\n  - 异步\n  - 削峰\n\n- 消息队列的缺点\n  - 系统整体更复杂了，多引入了一个服务\n  - 系统的可用性更差了，因为需要关注MQ的服务健康情况\n  - 一致性问题，数据各个调用的一致性问题。类似事务的一致性问题\n\n## 主流MQ比较\n\n| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                 | kafka                                                        |\n| :--------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |\n| 开发语言   | java                                                         | erlang                                                       | java                     | scala                                                        |\n| 单机吞吐量 | 万级                                                         | 万级                                                         | 10万级                   | 10万级                                                       |\n| 时效性     | ms级                                                         | us级                                                         | ms级                     | ms级以内                                                     |\n| 可用性     | 高(主从架构)                                                 | 高(主从架构)                                                 | 非常高(分布式架构)       | 非常高(分布式架构)                                           |\n| 功能特性   | 成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好 | 基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富 | MQ功能比较完备，扩展性佳 | 只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。 |\n\n\n\n\n\n## kafka架构\n\n### 术语解释\n\n-  broker：缓存代理，Kafka集群中的一台或多台服务器统称broker。\n-  topic：kafka给消息提供的分类方式。broker用来存储不同topic的消息数据。\n-  producer：往broker中某个topic里面生产数据。\n-  consumer：从broker中某个topic获取数据。\n- Partition: Topic物理上的分组，一个topic可以分为多个partion,每个partion是一个有序的队列。partion中每条消息都会被分配一个有序的Id(offset)\n\n### Topics和日志\n\n\n\n对于每一个topic， Kafka集群都会维持一个分区日志，如下所示：\n\n\n\n\n\n![](消息队列kafka/topic.png)\n\n每个分区都是有序且顺序不可变的记录集，并且不断地追加到结构化的commit log文件。分区中的每一个记录都会分配一个id号来表示顺序，我们称之为offset，*offset*用来唯一的标识分区中每一条记录。注意，这里的offset同时也记录了消息的位置，我们每次读取的时候就从offset的位置读取就行，所以效率高\n\n\n\n## kafka的高可用\n\n![](消息队列kafka/kafka集群.png)\n\n\n\n- 该图(注意最下面的一行应该为topic1_part2，由于网上找的图，没做修改)展示了，一个topic，可能被拆分成了多个partition，存放在不同的broker上。如topic1，被拆分成了topic1-part0，topic1-part1，topic1-part2。\n\n- 传统的设计：如果我们要实现分区，可能会将三台机器每台存放1/3的数据，但是如果机器宕机了，就等于我们丢失了1/3的，有1/3的数据无法访问\n- Kafka 0.8 以后，提供了 HA 机制，就是 replicas（复制品） 副本机制。所有 replicas会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道。其他的replicas多个broker持有相同的partition，如图Broker1,Broker2,Broker3都持有topic1-part0\n  - 写的时候，生产者写数据到leader(红色背景)，leader将数据落盘，follower主动从leader这里pull数据，数据同步完成后，发送ack给leader，所有follower处理完成后，leader返回成功消息给生产者\n  - 读的时候直接读取leader的数据就可以，但是需要当前的消息被所有follower同步成功后才能读到。\n  - 如果broker宕机了，数据在其他broker还有复制，会重新选举leader，继续服务。\n  - **读写都能在在leader上操作吗？**\n    - 是的，要是可以在多个 follower操作，就又要考虑数据一致性的问题，更麻烦\n\n\n\n## 如何保证消息不被重复消费的幂等性？？\n\n- 首先得明白什么是幂等\n\n  - 一个请求，重复多次执行，产生的结果不变。\n\n- kafka怎么产生幂等性问题的\n\n  - kafka有offset的记录，每次写入消息，都有记录offset，可以理解为代表位置的偏移量。consumer消费消息后，会定时把自己消费的消息offset提交，代表已经消费，下次如果重启，就从上次消费的offset继续消费。\n  - 但是如果我某个消息，在消费后，offset还没提交，服务器宕机了，即kafka没有更新offset的记录，那么下次服务恢复后该消息还是会被消费一次。这样我们就需要保证消息幂等\n\n- 解决方案\n\n  - 1.通过数据库的主键比对，如我执行的操作，是否数据库已经有了，有了我就update一下，或者不做操作\n  - 2.比如redis，操作每次都是set，自身支持幂等的，不用特殊处理\n  - 3.让生产者发送消息的时候绑定一个全局唯一id，根据这个id判定是否已消息过(判定方法，可以使用数据库或者redis缓存起来这个id)\n\n  \n\n## 如何处理消息丢失？\n\n- consumer丢失消息\n- kafka丢失消息\n- 生产者丢失消息\n\n\n\n\n\n## 如何保证消息的顺序性\n\n\n\n\n\n\n\n## 写一个消息队列，该如何进行架构设计","tags":["消息队列"]},{"title":"分布式事务","url":"/2020/11/01/分布式/分布式事务/","content":"\n\n\n两阶段提交2PC\n\n\n\n三阶段提交 3PC\n\n\n\n\n\nXA规范\n\n\n\nTCC事务模型\n\n\n\n可靠消息最终一致性\n\n\n\n最大努力通知\n\n","tags":["分布式"]},{"title":"分布式基础","url":"/2020/10/20/分布式/分布式基础/","content":"\n\n\n## 分布式系统\n\n- 分布式系统技术就是用来解决集中式架构的性能瓶颈问题，来适应快速发展的业务规模。\n\n- 为了应对高并发访问，和大量数据处理的任务，我们需要系统做到\n  - 可扩展\n  - 不出现单点故障\n\n\n\n## CAP理论\n\nCAP 理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）这三项中的两项。\n\n| CAP                               | 解释                                                         |\n| --------------------------------- | ------------------------------------------------------------ |\n| 一致性（Consistency）             | 所有节点在同一时间的数据完全一致                             |\n| 可用性（Availability）            | 服务一直可用，而且是正常响应时间                             |\n| 分区容忍性（Partition Tolerance） | 当部分节点出现消息丢失或者分区故障的时候，分布式系统仍然能够继续运行 |\n\n\n\n### CAP 的取舍\n\nCAP 理论说明，在架构设计中，不要考虑设计能满足三者的完美分布式系统上，而要合理进行取舍，CAP 理论只能三者选其二，不能全部获得\n\n#### CP架构\n\n- 放弃可用性，追求一致性和分区容错性。最典型的就是zookeeper。核心算法Zab，所有设计都是为了一致性\n\n\n\n#### AP架构\n\n- 对于 AP 来说，放弃强一致性，追求分区容错性和可用性。典型例子，为eureka注册中心。\n\n#### 思考\n\n1.为什么CAP理论中，最多只能只能满足其中两项？\n\n2.Nacos为什么即可以支持AP和CP的切换(不是同时满足)呢?\n\n\n\n## Base 理论\n\nBase 是三个短语的简写，即基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）。\n\n即无法做到强一致性，那么采用某种方式达到最终一致性。\n\nBase 理论的核心思想是**最终一致性**，\n\n### 基本可用（Basically Available）\n\n- 系统能够基本运行，能一直提供服务。允许损失部分可用性，相比正常的系统，可能是响应时间延长，或者是服务被降级\n\n### 软状态（Soft State）\n\n- 软状态则是允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时\n\n### 最终一致性（Eventually Consistent）\n\n- 数据不可能一直是软状态，必须在某一个时刻，达到各个节点的一致性。即达到了最终一致性\n\n## Paxos 算法\n\n- 在学习 Paxos 算法之前，我们先来看分布式系统中的 Quorum 选举算法\n\n### Quorum 选举算法\n\n- 在 N 个副本中，一次更新成功的如果有 W 个，那么我在读取数据时是要从大于 N－W 个副本中读取，这样就能至少读到一个更新的数据了\n\n- Quorum 的定义如下：假设有 N 个副本，更新操作 wi 在 W 个副本中更新成功之后，才认为此次更新操作 wi 成功，把这次成功提交的更新操作对应的数据叫做：“成功提交的数据”。对于读操作而言，至少需要读 R 个副本才能读到此次更新的数据，其中，W+R>N ，即 W 和 R 有重叠，一般，W+R=N+1。\n  - N = 存储数据副本的数量\n  - W = 更新成功所需的副本\n  - R = 一次数据对象读取要访问的副本的数量\n\nQuorum就是限定了一次需要读取至少N+1-w的副本数据,听起来有些抽象，举个例子，我们维护了10个副本，一次成功更新了三个，那么至少需要读取八个副本的数据，可以保证我们读到了最新的数据。\n\n### Quorum 的应用\n\n- Quorum 机制**无法保证强一致性**，也就是无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。\n\n- Quorum 机制的使用需要配合一个获取最新成功提交的版本号的 metadata 服务，这样可以确定最新已经成功提交的版本号，然后从已经读到的数据中就可以确认最新写入的数据。\n\n- Quorum 是分布式系统中常用的一种机制，用来保证数据冗余和最终一致性的投票算法，在 Paxos、Raft 和 ZooKeeper 的 Zab 等算法中，都可以看到 Quorum 机制的应用。\n\n### Paxos 的节点角色\n\n#### Proposer提案者\n\n- Proposer 可以有多个，在流程开始时，Proposer 提出议案，也就是value，所谓 value，在工程中可以是任何操作，比如“修改某个变量的值为某个新值”，Paxos 协议中统一将这些操作抽象为 value。\n\n- 不同的 Proposer 可以提出不同的甚至矛盾的 value，比如某个 Proposer 提议“将变量 X 设置为 1”，另一个 Proposer 提议“将变量 X 设置为 2”，但对同一轮 Paxos 过程，最多只有一个 value 被批准。\n\n#### Acceptor \n\n- 在集群中，Acceptor 有 N 个，Acceptor 之间完全对等独立，Proposer 提出的 value 必须获得超过半数（N/2+1）的 Acceptor 批准后才能通过\n\n#### Learner\n\n- Learner 不参与选举，而是学习被批准的 value，在Paxos中，Learner主要参与相关的状态机同步流程。\n\n  这里Leaner的流程就参考了Quorum 议会机制，某个 value 需要获得 W=N/2 + 1 的 Acceptor 批准，Learner 需要至少读取 N/2+1 个 Accpetor，最多读取 N 个 Acceptor 的结果后，才能学习到一个通过的 value。\n\n### Paxos 选举过程\n\n![](分布式基础/proxy选举过程.png)\n\n#### Phase 1 准备阶段\n\n- Proposer 生成全局唯一且递增的 ProposalID，向 Paxos 集群的所有机器发送 Prepare 请求\n\n- Acceptor 收到 Prepare 请求后，判断收到的 ProposalID 是否比之前已响应的所有提案的 N 大，如果是，则：\n  - 在本地持久化 ProposalID，可记为 Max_ProposalID；\n  - 回复请求，并带上已经 Accept 的提案中 ProposalID 最大的 value，如果此时还没有已经 Accept 的提案，则返回 value 为空；\n  - 做出承诺，不会 Accept 任何小于 Max_N 的提案。\n\n\n\n​\t\t如果否，则不回复或者回复 Error。\n\n#### Phase 2 选举阶段\n\n##### Proposer 发送 Accept\n\n- 经过一段时间后，Proposer 收集到一些 Acceptor回复，有下列几种情况：\n  - 若回复数量 > 一半的 Acceptor 数量，且所有回复的 value 都为空时，则 Porposer 发出 accept 请求，并带上自己指定的 value。\n  - 若回复数量 > 一半的 Acceptor 数量，且有的回复 value 不为空时，则 Porposer 发出 accept 请求，并带上回复中 ProposalID 最大的 value，作为自己的提案内容。\n  - 若回复数量 <= 一半的 Acceptor 数量时，则尝试更新生成更大的 ProposalID，再转到准备阶段执行。\n\n##### Acceptor 应答 Accept\n\n- Accpetor 收到 Accpet 请求 后，判断：\n  - 若收到的 ProposalID >= Max_ProposalID（一般情况下是等于），则回复提交成功，并持久化ProposalID 和 value；\n  - 若收到的 N < Max_N，则不回复或者回复提交失败。\n\n##### Proposer 统计投票\n\n- 经过一段时间后，Proposer 会收集到一些 Accept 回复提交成功的情况，比如：\n  - 当回复数量 > 一半的 Acceptor 数量时，则表示提交 value 成功，此时可以发一个广播给所有的 Proposer、Learner，通知它们已 commit 的 value；\n  - 当回复数量 <= 一半的 Acceptor 数量时，则尝试更新生成更大的 ProposalID，转到准备阶段执行。\n  - 当收到一条提交失败的回复时，则尝试更新生成更大的 ProposalID，也会转到准备阶段执行。\n\n### ZooKeeper 是如何实现数据一致性","tags":["分布式"]},{"title":"Spring-BeanPostProcessor接口不生效","url":"/2020/10/18/框架系列/spring/Spring-BeanPostProcessor接口不生效/","content":"## 现象描述\n\n在研究spring的bean的生命周期过程中发现BeanPostProcessor接口不生效，即实现了BeanPostProcessor接口，但是调用过程中不执行，代码如下\n\n<font color='ff0000'>注意：为避免版本差异，以下分析均基于spring-beans-5.1.4.RELEASE</font>\n\n- User1.java对象\n\n```java\npublic class User1 implements BeanPostProcessor {\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"User1:postProcessBeforeInitialization\");\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"User1:postProcessAfterInitialization\");\n        return bean;\n    }\n}\n\n```\n\n- springBeanLife.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user1\" class=\"com.mk.learn.spring.ioc.spring.beanlife.User1\"></bean>\n</beans>\n```\n\n- 测试类\n\n```java\npublic class SpringBeanTest {\n\n     public static void main(String[] args) {\n        ApplicationContext applicationContext =\n            new ClassPathXmlApplicationContext(\"springBeanLife.xml\");\n        User1 user1 = (User1) applicationContext.getBean(\"user1\");\n    }\n}\n```\n\n- 结果：\n\n<font color='FF0000'>未打印任何信息，debug且无法进入实现的接口内</font>\n\n## 原因分析\n\n- spring通过bean工厂创建bean对象，所以我们的调用也在bean创建的过程AbstractAutowireCapableBeanFactorydoCreateBean方法中寻找。\n\n在AbstractAutowireCapableBeanFactory.java中的applyBeanPostProcessorsBeforeInitialization方法我们可以看到是。这里的`processor.postProcessBeforeInitialization(result, beanName);`即是我们的方法回调入口\n\n```java\n@Override\n\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessBeforeInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}\n```\n\n\n\n- 那么BeanPostProcessor是存放在哪里的呢? 核心类在`AbstractBeanFactory`类中的，持有了所有的BeanPostProcessor。\n\n  \n\n```java\npublic abstract class AbstractBeanFactory extends FactoryBeanRegistrySupport implements ConfigurableBeanFactory {\n\t/** BeanPostProcessors to apply in createBean. */\n\tprivate final List<BeanPostProcessor> beanPostProcessors = new CopyOnWriteArrayList<>();\n\t....\n\t}\n```\n\n\n\n- 这里既然是一个list，那么就应该提供add方法将对象放入list，`AbstractBeanFactory`类中搜索add方法的使用。发现`AbstractBeanFactory`类的addBeanPostProcessor方法，既然这里是唯一add入口，那么我们断点这个地方，自然可以找到为啥BeanPostProcessor没有被add进去\n\n```java\n@Override\n\tpublic void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {\n\t\tAssert.notNull(beanPostProcessor, \"BeanPostProcessor must not be null\");\n\t\t// Remove from old position, if any\n\t\tthis.beanPostProcessors.remove(beanPostProcessor);\n\t\t// Track whether it is instantiation/destruction aware\n\t\tif (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {\n\t\t\tthis.hasInstantiationAwareBeanPostProcessors = true;\n\t\t}\n\t\tif (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {\n\t\t\tthis.hasDestructionAwareBeanPostProcessors = true;\n\t\t}\n\t\t// Add to end of list\n\t\tthis.beanPostProcessors.add(beanPostProcessor);\n\t}\n```\n\n\n\n找到了方法入口，接下来就可以断点跟踪了。\n\n### 断点分析\n\n#### 1.AbstractApplicationContext的refresh()\n\n该方法为spring初始化的一个入口\n\n```java\n@Override\n\tpublic void refresh() throws BeansException, IllegalStateException {\n\t\tsynchronized (this.startupShutdownMonitor) {\n\t\t\t// Prepare this context for refreshing.\n\t\t\tprepareRefresh();\n\n\t\t\t// Tell the subclass to refresh the internal bean factory.\n\t\t\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t\t\t// Prepare the bean factory for use in this context.\n            //添加BeanPostProcessor\n\t\t\tprepareBeanFactory(beanFactory);\n\n\t\t\ttry {\n\t\t\t\t// Allows post-processing of the bean factory in context subclasses.\n\t\t\t\tpostProcessBeanFactory(beanFactory);\n\n\t\t\t\t// Invoke factory processors registered as beans in the context.\n\t\t\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t\t\t// Register bean processors that intercept bean creation.\n\t\t\t\tregisterBeanPostProcessors(beanFactory);\n\n\t\t\t\t// Initialize message source for this context.\n\t\t\t\tinitMessageSource();\n\n\t\t\t\t// Initialize event multicaster for this context.\n\t\t\t\tinitApplicationEventMulticaster();\n\n\t\t\t\t// Initialize other special beans in specific context subclasses.\n\t\t\t\tonRefresh();\n\n\t\t\t\t// Check for listener beans and register them.\n\t\t\t\tregisterListeners();\n\n\t\t\t\t// Instantiate all remaining (non-lazy-init) singletons.\n\t\t\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t\t\t// Last step: publish corresponding event.\n\t\t\t\tfinishRefresh();\n\t\t\t}\n\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n\t\t\t\t\t\t\t\"cancelling refresh attempt: \" + ex);\n\t\t\t\t}\n\n\t\t\t\t// Destroy already created singletons to avoid dangling resources.\n\t\t\t\tdestroyBeans();\n\n\t\t\t\t// Reset 'active' flag.\n\t\t\t\tcancelRefresh(ex);\n\n\t\t\t\t// Propagate exception to caller.\n\t\t\t\tthrow ex;\n\t\t\t}\n\n\t\t\tfinally {\n\t\t\t\t// Reset common introspection caches in Spring's core, since we\n\t\t\t\t// might not ever need metadata for singleton beans anymore...\n\t\t\t\tresetCommonCaches();\n\t\t\t}\n\t\t}\n\t}\n```\n\n这里就说一下结论:\n\n#### 2.AbstractApplicationContext的prepareBeanFactory(beanFactory)\n\n- `prepareBeanFactory(beanFactory);`中添加了两个元素到BeanPostProcessors的List中\n\n```java\n// Configure the bean factory with context callbacks.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\n// Register early post-processor for detecting inner beans as ApplicationListeners.\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n```\n\n- 当断点到`registerBeanPostProcessors(beanFactory);`时发现，BeanPostProcessors中只有两个元素`ApplicationContextAwareProcessor`和`ApplicationListenerDetector`\n\n截图如下，可以看到\n\n![](Spring-BeanPostProcessor接口不生效/beanPostProcessor-1.png)\n\n\n\n#### 3.PostProcessorRegistrationDelegate#registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)\n\n\n\n进入到registerBeanPostProcessors方法内，我们可以看到\n\n```JAVA\npublic static void registerBeanPostProcessors(\n\t\t\tConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {\n\t\t//获取实现了BeanPostProcessor的nanmes\n\t\tString[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);\n\n\t\t// Register BeanPostProcessorChecker that logs an info message when\n\t\t// a bean is created during BeanPostProcessor instantiation, i.e. when\n\t\t// a bean is not eligible for getting processed by all BeanPostProcessors.\n\t\tint beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;\n\t\tbeanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));\n\n\t\t//处理实现了PriorityOrdered的BeanPostProcessor\n\t\tList<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();\n\t\tList<BeanPostProcessor> internalPostProcessors = new ArrayList<>();\n\t\tList<String> orderedPostProcessorNames = new ArrayList<>();\n\t\tList<String> nonOrderedPostProcessorNames = new ArrayList<>();\n\t\tfor (String ppName : postProcessorNames) {\n\t\t\tif (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {\n\t\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\tpriorityOrderedPostProcessors.add(pp);\n\t\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (beanFactory.isTypeMatch(ppName, Ordered.class)) {\n\t\t\t\torderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnonOrderedPostProcessorNames.add(ppName);\n\t\t\t}\n\t\t}\n\n\t\t//首先，注册实现了PriorityOrdered的BeanPostProcessors\n\t\tsortPostProcessors(priorityOrderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);\n\n\t\t//接着，注册实现了Ordered的BeanPostProcessors\n\t\tList<BeanPostProcessor> orderedPostProcessors = new ArrayList<>();\n\t\tfor (String ppName : orderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\torderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tsortPostProcessors(orderedPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, orderedPostProcessors);\n\n\t\t// 注册常规的BeanPostProcessors.\n\t\tList<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>();\n\t\tfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\n\t\tregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n\n\t\t// 最后，重新注册所有的全局BeanPostProcessors.\n\t\tsortPostProcessors(internalPostProcessors, beanFactory);\n\t\tregisterBeanPostProcessors(beanFactory, internalPostProcessors);\n\n\t\t// Re-register post-processor for detecting inner beans as ApplicationListeners,\n\t\t// moving it to the end of the processor chain (for picking up proxies etc).\n\t\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));\n\t}\n```\n\n- `BeanPostProcessorChecker`方法中又加入了一个BeanPostProcessorChecker到BeanPostProcessors中(**上面代码第10行**)，此时list中有三个元素\n\n\n\n#### 4.nonOrderedPostProcessorNames.add(ppName);\n\n- 通过断点发现 beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false)；获取实现了BeanPostProcessor的nanmes\n- 我们的user1，被放到了nonOrderedPostProcessorNames中\n- 可以看到nonOrderedPostProcessors.add(pp)(**上面代码29行**);即将BeanPostProcessor放到了nonOrderedPostProcessors中，然后通过registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors)(**上面代码58行**);放到了我们追踪的BeanPostProcessors的list中。\n\n```java\nfor (String ppName : nonOrderedPostProcessorNames) {\n\t\t\tBeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\tnonOrderedPostProcessors.add(pp);\n\t\t\tif (pp instanceof MergedBeanDefinitionPostProcessor) {\n\t\t\t\tinternalPostProcessors.add(pp);\n\t\t\t}\n\t\t}\nregisterBeanPostProcessors(beanFactory, nonOrderedPostProcessors);\n```\n\n\n\n但是为什么我们没有调用进来呢？请注意BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);上面代码52行\n\n\n\n#### 5.beanFactory.getBean(ppName, BeanPostProcessor.class)\n\n断点进入发现，该方法内容比较长\n\n```java\nprotected <T> T doGetBean(final String name, @Nullable final Class<T> requiredType,\n\t\t\t@Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {\n\n\t\tfinal String beanName = transformedBeanName(name);\n\t\tObject bean;\n\n\t\t// Eagerly check singleton cache for manually registered singletons.\n\t\tObject sharedInstance = getSingleton(beanName);\n\t\tif (sharedInstance != null && args == null) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tif (isSingletonCurrentlyInCreation(beanName)) {\n\t\t\t\t\tlogger.trace(\"Returning eagerly cached instance of singleton bean '\" + beanName +\n\t\t\t\t\t\t\t\"' that is not fully initialized yet - a consequence of a circular reference\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlogger.trace(\"Returning cached instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, null);\n\t\t}\n\n\t\telse {\n\t\t\t// Fail if we're already creating this bean instance:\n\t\t\t// We're assumably within a circular reference.\n\t\t\tif (isPrototypeCurrentlyInCreation(beanName)) {\n\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName);\n\t\t\t}\n\n\t\t\t// Check if bean definition exists in this factory.\n\t\t\tBeanFactory parentBeanFactory = getParentBeanFactory();\n\t\t\tif (parentBeanFactory != null && !containsBeanDefinition(beanName)) {\n\t\t\t\t// Not found -> check parent.\n\t\t\t\tString nameToLookup = originalBeanName(name);\n\t\t\t\tif (parentBeanFactory instanceof AbstractBeanFactory) {\n\t\t\t\t\treturn ((AbstractBeanFactory) parentBeanFactory).doGetBean(\n\t\t\t\t\t\t\tnameToLookup, requiredType, args, typeCheckOnly);\n\t\t\t\t}\n\t\t\t\telse if (args != null) {\n\t\t\t\t\t// Delegation to parent with explicit args.\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup, args);\n\t\t\t\t}\n\t\t\t\telse if (requiredType != null) {\n\t\t\t\t\t// No args -> delegate to standard getBean method.\n\t\t\t\t\treturn parentBeanFactory.getBean(nameToLookup, requiredType);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn (T) parentBeanFactory.getBean(nameToLookup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!typeCheckOnly) {\n\t\t\t\tmarkBeanAsCreated(beanName);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfinal RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);\n\t\t\t\tcheckMergedBeanDefinition(mbd, beanName, args);\n\n\t\t\t\t// Guarantee initialization of beans that the current bean depends on.\n\t\t\t\tString[] dependsOn = mbd.getDependsOn();\n\t\t\t\tif (dependsOn != null) {\n\t\t\t\t\tfor (String dep : dependsOn) {\n\t\t\t\t\t\tif (isDependent(beanName, dep)) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tregisterDependentBean(dep, beanName);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tgetBean(dep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\t\t\"'\" + beanName + \"' depends on missing bean '\" + dep + \"'\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 创建一个单例\n\t\t\t\tif (mbd.isSingleton()) {\n\t\t\t\t\tsharedInstance = getSingleton(beanName, () -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse if (mbd.isPrototype()) {\n\t\t\t\t\t// It's a prototype -> create a new instance.\n\t\t\t\t\tObject prototypeInstance = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\tprototypeInstance = createBean(beanName, mbd, args);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t}\n\t\t\t\t\tbean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tString scopeName = mbd.getScope();\n\t\t\t\t\tfinal Scope scope = this.scopes.get(scopeName);\n\t\t\t\t\tif (scope == null) {\n\t\t\t\t\t\tthrow new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\");\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tObject scopedInstance = scope.get(beanName, () -> {\n\t\t\t\t\t\t\tbeforePrototypeCreation(beanName);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\t\tafterPrototypeCreation(beanName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\t\tthrow new BeanCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Scope '\" + scopeName + \"' is not active for the current thread; consider \" +\n\t\t\t\t\t\t\t\t\"defining a scoped proxy for this bean if you intend to refer to it from a singleton\",\n\t\t\t\t\t\t\t\tex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (BeansException ex) {\n\t\t\t\tcleanupAfterBeanCreationFailure(beanName);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\n\t\t// Check if required type matches the type of the actual bean instance.\n\t\tif (requiredType != null && !requiredType.isInstance(bean)) {\n\t\t\ttry {\n\t\t\t\tT convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);\n\t\t\t\tif (convertedBean == null) {\n\t\t\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t\t\t}\n\t\t\t\treturn convertedBean;\n\t\t\t}\n\t\t\tcatch (TypeMismatchException ex) {\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Failed to convert bean '\" + name + \"' to required type '\" +\n\t\t\t\t\t\t\tClassUtils.getQualifiedName(requiredType) + \"'\", ex);\n\t\t\t\t}\n\t\t\t\tthrow new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());\n\t\t\t}\n\t\t}\n\t\treturn (T) bean;\n\t}\n```\n\n\n\n这里我们的xml中对象没有配置scope值，默认单例模式。即我们的代码会进入\n\n```java\nif (mbd.isSingleton()) {\n\t\t\t\t\tsharedInstance = getSingleton(beanName, () -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn createBean(beanName, mbd, args);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (BeansException ex) {\n\t\t\t\t\t\t\t// Explicitly remove instance from singleton cache: It might have been put there\n\t\t\t\t\t\t\t// eagerly by the creation process, to allow for circular reference resolution.\n\t\t\t\t\t\t\t// Also remove any beans that received a temporary reference to the bean.\n\t\t\t\t\t\t\tdestroySingleton(beanName);\n\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);\n\t\t\t\t}\n\n```\n\n- 继续进去getSingleton方法(第2行代码)。\n\n#### 6.DefaultSingletonBeanRegistry#getSingleton(String beanName, ObjectFactory<?> singletonFactory)\n\n方法代码如下\n\n```java\npublic Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n\t\tAssert.notNull(beanName, \"Bean name must not be null\");\n\t\tsynchronized (this.singletonObjects) {\n\t\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\t\tif (singletonObject == null) {\n\t\t\t\tif (this.singletonsCurrentlyInDestruction) {\n\t\t\t\t\tthrow new BeanCreationNotAllowedException(beanName,\n\t\t\t\t\t\t\t\"Singleton bean creation not allowed while singletons of this factory are in destruction \" +\n\t\t\t\t\t\t\t\"(Do not request a bean from a BeanFactory in a destroy method implementation!)\");\n\t\t\t\t}\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Creating shared instance of singleton bean '\" + beanName + \"'\");\n\t\t\t\t}\n\t\t\t\tbeforeSingletonCreation(beanName);\n\t\t\t\tboolean newSingleton = false;\n\t\t\t\tboolean recordSuppressedExceptions = (this.suppressedExceptions == null);\n\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\tthis.suppressedExceptions = new LinkedHashSet<>();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\t\t\tnewSingleton = true;\n\t\t\t\t}\n\t\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\t\t// Has the singleton object implicitly appeared in the meantime ->\n\t\t\t\t\t// if yes, proceed with it since the exception indicates that state.\n\t\t\t\t\tsingletonObject = this.singletonObjects.get(beanName);\n\t\t\t\t\tif (singletonObject == null) {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (BeanCreationException ex) {\n\t\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\t\tfor (Exception suppressedException : this.suppressedExceptions) {\n\t\t\t\t\t\t\tex.addRelatedCause(suppressedException);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (recordSuppressedExceptions) {\n\t\t\t\t\t\tthis.suppressedExceptions = null;\n\t\t\t\t\t}\n\t\t\t\t\tafterSingletonCreation(beanName);\n\t\t\t\t}\n\t\t\t\tif (newSingleton) {\n\t\t\t\t\taddSingleton(beanName, singletonObject);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn singletonObject;\n\t\t}\n\t}\n```\n\n- 会执行到singletonObject = singletonFactory.getObject();**（21行代码）**，这里我们可以看到singletonFactory其实就是一个函数式接口，这里执行一个回调，回调到第5点的beanFactory.getBean(ppName, BeanPostProcessor.class)中的createBean方法(**标题5中82行**)\n\n#### 7.AbstractAutowireCapableBeanFactory#createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\n```java\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Creating instance of bean '\" + beanName + \"'\");\n\t\t}\n\t\tRootBeanDefinition mbdToUse = mbd;\n\n\t\t// Make sure bean class is actually resolved at this point, and\n\t\t// clone the bean definition in case of a dynamically resolved Class\n\t\t// which cannot be stored in the shared merged bean definition.\n\t\tClass<?> resolvedClass = resolveBeanClass(mbd, beanName);\n\t\tif (resolvedClass != null && !mbd.hasBeanClass() && mbd.getBeanClassName() != null) {\n\t\t\tmbdToUse = new RootBeanDefinition(mbd);\n\t\t\tmbdToUse.setBeanClass(resolvedClass);\n\t\t}\n\n\t\t// Prepare method overrides.\n\t\ttry {\n\t\t\tmbdToUse.prepareMethodOverrides();\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),\n\t\t\t\t\tbeanName, \"Validation of method overrides failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\t// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.\n\t\t\tObject bean = resolveBeforeInstantiation(beanName, mbdToUse);\n\t\t\tif (bean != null) {\n\t\t\t\treturn bean;\n\t\t\t}\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(mbdToUse.getResourceDescription(), beanName,\n\t\t\t\t\t\"BeanPostProcessor before instantiation of bean failed\", ex);\n\t\t}\n\n\t\ttry {\n\t\t\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n\t\tcatch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {\n\t\t\t// A previously detected exception with proper bean creation context already,\n\t\t\t// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.\n\t\t\tthrow ex;\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbdToUse.getResourceDescription(), beanName, \"Unexpected exception during bean creation\", ex);\n\t\t}\n\t}\n```\n\n这里我们主要看下面这段话，上面代码40行\n\n```java\n\ttry {\n\t\t\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Finished creating instance of bean '\" + beanName + \"'\");\n\t\t\t}\n\t\t\treturn beanInstance;\n\t\t}\n```\n\n\n\n继续看这个方法\n\n#### 8.AbstractAutowireCapableBeanFactory#doCreateBean\n\n```java\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n\t\t\tthrows BeanCreationException {\n\n\t\t// Instantiate the bean.\n\t\tBeanWrapper instanceWrapper = null;\n\t\tif (mbd.isSingleton()) {\n\t\t\tinstanceWrapper = this.factoryBeanInstanceCache.remove(beanName);\n\t\t}\n\t\tif (instanceWrapper == null) {\n\t\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t\t}\n\t\tfinal Object bean = instanceWrapper.getWrappedInstance();\n\t\tClass<?> beanType = instanceWrapper.getWrappedClass();\n\t\tif (beanType != NullBean.class) {\n\t\t\tmbd.resolvedTargetType = beanType;\n\t\t}\n\n\t\t// Allow post-processors to modify the merged bean definition.\n\t\tsynchronized (mbd.postProcessingLock) {\n\t\t\tif (!mbd.postProcessed) {\n\t\t\t\ttry {\n\t\t\t\t\tapplyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new BeanCreationException(mbd.getResourceDescription(), beanName,\n\t\t\t\t\t\t\t\"Post-processing of merged bean definition failed\", ex);\n\t\t\t\t}\n\t\t\t\tmbd.postProcessed = true;\n\t\t\t}\n\t\t}\n\n\t\t// Eagerly cache singletons to be able to resolve circular references\n\t\t// even when triggered by lifecycle interfaces like BeanFactoryAware.\n\t\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\t\tisSingletonCurrentlyInCreation(beanName));\n\t\tif (earlySingletonExposure) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Eagerly caching bean '\" + beanName +\n\t\t\t\t\t\t\"' to allow for resolving potential circular references\");\n\t\t\t}\n\t\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t\t}\n\n\t\t// Initialize the bean instance.\n\t\tObject exposedObject = bean;\n\t\ttry {\n\t\t\tpopulateBean(beanName, mbd, instanceWrapper);\n\t\t\texposedObject = initializeBean(beanName, exposedObject, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tif (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {\n\t\t\t\tthrow (BeanCreationException) ex;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex);\n\t\t\t}\n\t\t}\n\n\t\tif (earlySingletonExposure) {\n\t\t\tObject earlySingletonReference = getSingleton(beanName, false);\n\t\t\tif (earlySingletonReference != null) {\n\t\t\t\tif (exposedObject == bean) {\n\t\t\t\t\texposedObject = earlySingletonReference;\n\t\t\t\t}\n\t\t\t\telse if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {\n\t\t\t\t\tString[] dependentBeans = getDependentBeans(beanName);\n\t\t\t\t\tSet<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);\n\t\t\t\t\tfor (String dependentBean : dependentBeans) {\n\t\t\t\t\t\tif (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {\n\t\t\t\t\t\t\tactualDependentBeans.add(dependentBean);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!actualDependentBeans.isEmpty()) {\n\t\t\t\t\t\tthrow new BeanCurrentlyInCreationException(beanName,\n\t\t\t\t\t\t\t\t\"Bean with name '\" + beanName + \"' has been injected into other beans [\" +\n\t\t\t\t\t\t\t\tStringUtils.collectionToCommaDelimitedString(actualDependentBeans) +\n\t\t\t\t\t\t\t\t\"] in its raw version as part of a circular reference, but has eventually been \" +\n\t\t\t\t\t\t\t\t\"wrapped. This means that said other beans do not use the final version of the \" +\n\t\t\t\t\t\t\t\t\"bean. This is often the result of over-eager type matching - consider using \" +\n\t\t\t\t\t\t\t\t\"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Register bean as disposable.\n\t\ttry {\n\t\t\tregisterDisposableBeanIfNecessary(beanName, bean, mbd);\n\t\t}\n\t\tcatch (BeanDefinitionValidationException ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\tmbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex);\n\t\t}\n\n\t\treturn exposedObject;\n\t}\n```\n\n这里我们就可以看到bean对象初始化的过程了，此处不再做更多扩展。继续定位beanPostProcessor的问题。\n\n大多数文章提到的属性填充既然上面47行代码的polulationBean，我们继续看48行的\n\n```java\nexposedObject = initializeBean(beanName, exposedObject, mbd);\n```\n\n<span id=\"jump\">AAA</span>\n\n#### 9.AbstractAutowireCapableBeanFactory#initializeBean\n\n- 进入该方法方法中，可以看到如下，\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n\t\tif (System.getSecurityManager() != null) {\n\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\tinvokeAwareMethods(beanName, bean);\n\t\t\t\treturn null;\n\t\t\t}, getAccessControlContext());\n\t\t}\n\t\telse {\n\t\t\tinvokeAwareMethods(beanName, bean);\n\t\t}\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null),\n\t\t\t\t\tbeanName, \"Invocation of init method failed\", ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}\n```\n\n关于bean生命周期的扩展，这里不再赘述了，看到14行代码\n\n`wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);`\n\n进入方法内部\n\n#### 10.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization\n\n这里看到了我们一直在断点跟的`postProcessBeforeInitialization`方法(下面第7行)。\n\n```java\n@Override\n\tpublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException {\n\n\t\tObject result = existingBean;\n\t\tfor (BeanPostProcessor processor : getBeanPostProcessors()) {\n\t\t\tObject current = processor.postProcessBeforeInitialization(result, beanName);\n\t\t\tif (current == null) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult = current;\n\t\t}\n\t\treturn result;\n\t}\n```\n\n\n\n### 结论\n\n- 刚才标题3[点我跳转](#1.AbstractApplicationContext的refresh())下我们分析过，beanPostProcessors中只有三个元素，没有我们自己的User对象。所以这里创建bean的时候没有调用我们自己实现的BeanPostProcessor对象。\n\n<font color='ff0000'>那么问题又来了，我们User对象呢？不是也实现了BeanPostProcessor接口了吗</font>\n\n- 标题4其实已经给了答案，我们是在对象创建完成后，才将BeanPostProcessor的实现类(user对象)放入到beanPostProcessors。实际是放进去了，但是没有执行而已\n\n  \n\n<font color='ff0000'>网上有人，说将scope改成多例就可以了或者创建两个bean对象，是这样吗？</font>\n\n- scope改多例，可以测试一把，确实改成多例就可以了，思考一下为什么呢？\n  - 我们spring实例化对象的时候已经创建了一次对象，在对象创建完成后beanPostProcessors中会持有User对象，在使用的时候通过getBean获取对象的时候会重新生成bean，即会再一次轮询beanPostProcessors，但是这个解放方法正确吗？个人认为是歪打正着而已\n- 创建两个bean对象，即在user对象前，再定义一个bean对象。\n  - 该方式首先成功与否可以自行思考，创建两个bean的方式比改成scope感觉更不合理\n\n#### 既然无法调用，那么是否我们的使用方式错误了吗？\n\n- 还是根据前面的结论，该<font color=\"ff0000\">beanPostProcessors每个对象创建的时候都会去遍历,所以这里应该是一个切面的作用，对所有的对象的创建做一个功能扩展</font>\n\n- 我们有很多aware接口可做扩展，BeanFactoryAware可以拿到BeanFactory，通过BeanFactory可以拿到beanPostProcessors，自己添加进去不就解决了所有问题了嘛。\n\n  ","tags":["spring"]},{"title":"Spring bean的生命周期","url":"/2020/10/18/框架系列/spring/Spring-bean的生命周期/","content":"\n## 对象的生命周期\n\n- Spring的bean的生命周期是指，spring的bean对象的创建-使用-销毁的全过程\n- 理解spring对象的生命周期有利于使用好spring\n- <font color='ff0000'>为避免版本差异，以下分析均基于spring-beans-5.1.4.RELEASE</font>\n\n### 流程图\n\n- 网上找了个流程图，我们可以看到该流程图，展示了bean的生命周期\n\n\n\n![？](Spring-bean的生命周期/beanlife.png)\n\n\n\n### 验证\n\n- 那么这个流程图是否正确呢？我们通过验证该生命周期的正确性，是否就可以确认到我们spring的生命周期了呢？\n\n#### 验证方法\n\n验证方法很简单，既然说了有这么多的扩展接口，那么我们挨个实现就可以了啊\n\n于是有了如下的示例\n\n##### springBeanLife.xml文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user\" class=\"com.mk.learn.spring.ioc.spring.beanlife.User\" init-method=\"init\"\n    destroy-method=\"destroyUser\">\n    <property name=\"userName\" value=\"AAAA\"></property>\n  </bean>\n</beans>\n```\n\n##### User对象\n\n```java\npackage com.mk.learn.spring.ioc.spring.beanlife;\n\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanNameAware;\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-10-18 17:30\n **/\npublic class User implements BeanNameAware, BeanFactoryAware, ApplicationContextAware,\n    BeanPostProcessor, InitializingBean, DisposableBean {\n\n    private String userName;\n    private int age;\n\n    public String getUserName() {\n        System.out.println(\"User:getUserName\");\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        System.out.println(\"User:setUserName\");\n        this.userName = userName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n    private void init(){\n        System.out.println(\"User:init\");\n    }\n\n    @Override\n    public void setBeanName(String name) {\n        System.out.println(\"BeanNameAware:setBeanName\");\n    }\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        System.out.println(\"BeanFactoryAware:setBeanFactory\");\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        System.out.println(\"ApplicationContextAware:setApplicationContext\");\n    }\n\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"BeanPostProcessor:postProcessBeforeInitialization\");\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName)\n        throws BeansException {\n        System.out.println(\"BeanPostProcessor:postProcessAfterInitialization\");\n        return bean;\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"InitializingBean:afterPropertiesSet\");\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        System.out.println(\"DisposableBean:destroy\");\n    }\n\n    public void destroyUser() throws Exception {\n        System.out.println(\"User:destroyUser\");\n    }\n}\n\n```\n\n##### 启动类\n\n```java\npackage com.mk.learn.spring.ioc.spring.beanlife;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-10-18 17:28\n **/\npublic class BeanLifeTest {\n\n    public static void main(String[] args) {\n        ApplicationContext applicationContext =\n            new ClassPathXmlApplicationContext(\"springBeanLife.xml\");\n       User user = (User) applicationContext.getBean(\"user\");\n       ((ClassPathXmlApplicationContext) applicationContext).close();\n    }\n}\n\n```\n\n\n\n#### 具体操作\n\n既然实现了所有接口，那么我们重写所有方法，看下结果输出顺序不就知道了吗\n\n\n\n## 核心代码位置\n\n### 1.AbstractAutowireCapableBeanFactory#doCreateBean\n\n\n\n```java\nprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {\n\t\tif (System.getSecurityManager() != null) {\n\t\t\tAccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n\t\t\t\tinvokeAwareMethods(beanName, bean);\n\t\t\t\treturn null;\n\t\t\t}, getAccessControlContext());\n\t\t}\n\t\telse {\n\t\t\tinvokeAwareMethods(beanName, bean);\n\t\t}\n\n\t\tObject wrappedBean = bean;\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\ttry {\n\t\t\tinvokeInitMethods(beanName, wrappedBean, mbd);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tthrow new BeanCreationException(\n\t\t\t\t\t(mbd != null ? mbd.getResourceDescription() : null),\n\t\t\t\t\tbeanName, \"Invocation of init method failed\", ex);\n\t\t}\n\t\tif (mbd == null || !mbd.isSynthetic()) {\n\t\t\twrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);\n\t\t}\n\n\t\treturn wrappedBean;\n\t}\n```\n\n#### 三个Aware接口\n\n此时我们可以看到上面第9行代码的`invokeAwareMethods(beanName, bean);`。很清晰的描述了生命周期图的三个aware接口\n\n```java\nprivate void invokeAwareMethods(final String beanName, final Object bean) {\n\t\tif (bean instanceof Aware) {\n\t\t\tif (bean instanceof BeanNameAware) {\n\t\t\t\t((BeanNameAware) bean).setBeanName(beanName);\n\t\t\t}\n\t\t\tif (bean instanceof BeanClassLoaderAware) {\n\t\t\t\tClassLoader bcl = getBeanClassLoader();\n\t\t\t\tif (bcl != null) {\n\t\t\t\t\t((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bean instanceof BeanFactoryAware) {\n\t\t\t\t((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);\n\t\t\t}\n\t\t}\n\t}\n```\n\n我们继续看标题下的14行的`invokeInitMethods(beanName, wrappedBean, mbd);`\n\n\n\n\n\n\n\n我们继续看标题下的18行的`invokeInitMethods(beanName, wrappedBean, mbd);`\n\n\n\n\n\n## 结论\n\n具体的分析过程，可参考文章\n\n`Spring-BeanPostProcessor接口不生效`\n\n该文较为详细的分析了整个bean的生命周期过程","tags":["spring"]},{"title":"netty","url":"/2020/10/06/中间件/netty/netty/","content":"\n \n\n## netty说明\n\n官网：[https://netty.io](https://netty.io/)[/](https://netty.io/)  \n\nNetty 对 JDK 自带的 NIO 的 API 进行了封装。\n\n1) 设计优雅：适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池.\n\n2) 使用方便：详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。\n\n3) 高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。\n\n4)安全：完整的 SSL/TLS 和 StartTLS 支持。\n\n5) 社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入\n\n- netty 下载地址： [https://bintray.com/netty/downloads/netty](https://bintray.com/netty/downloads/netty/)[/](https://bintray.com/netty/downloads/netty/)  \n\n## Reactor线程模型\n\n### 单Reactor单线程\n\n1) Select 是 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求\n\n2) Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发\n\n3) 如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理\n\n4) 如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应\n\n5) Handler 会完成 Read→业务处理→Send 的完整业务流程\n\n\n\n![](netty/单Reactor单线程.png)\n\n### 单Reactor多线程\n\n1) Reactor 对象通过select 监控客户端请求事件, 收到事件后，通过dispatch进行分发\n\n2) 如果建立连接请求, 则右Acceptor 通过accept 处理连接请求, 然后创建一个Handler对象处理完成连接后的各种事件\n\n3) 如果不是连接请求，则由reactor分发调用连接对应的handler 来处理\n\n4) handler 只负责响应事件，不做具体的业务处理, 通过read 读取数据后，会分发给后面的worker线程池的某个线程处理业务\n\n5) worker 线程池会分配独立线程完成真正的业务，并将结果返回给handler\n\n6) handler收到响应后，通过send 将结果返回给client\n\n![](netty/单Reactor多线程.png)\n\n### 主从 Reactor 多线程\n\n1) Reactor主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件\n\n2) 当 Acceptor  处理连接事件后，MainReactor 将连接分配给SubReactor \n\n3) subreactor 将连接加入到连接队列进行监听,并创建handler进行各种事件处理\n\n4) 当有新事件发生时， subreactor 就会调用对应的handler处理\n\n5) handler 通过read 读取数据，分发给后面的worker 线程处理\n\n6) worker 线程池分配独立的worker 线程进行业务处理，并返回结果\n\n7) handler 收到响应的结果后，再通过send 将结果返回给client\n\n8) Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor\n\n![](netty/主从 Reactor 多线程.png)\n\n## Netty模型\n\n1)Netty抽象出两组线程池 BossGroup 专门负责接收客户端的连接, WorkerGroup 专门负责网络的读写\n\n2)BossGroup 和 WorkerGroup 类型都是 NioEventLoopGroup\n\n3)NioEventLoopGroup 相当于一个事件循环组, 这个组中含有多个事件循环 ，每一个事件循环是 NioEventLoop\n\n4)NioEventLoop 表示一个不断循环的执行处理任务的线程， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络通讯\n\n5)NioEventLoopGroup 可以有多个线程, 即可以含有多个NioEventLoop\n\n6)每个Boss NioEventLoop 循环执行的步骤有3步\n\n​\t1.轮询accept 事件\n\n​\t2.处理accept 事件 , 与client建立连接 , 生成NioScocketChannel , 并将其注册到某个worker NIOEventLoop 上的 selector \n\n​\t3.处理任务队列的任务 ， 即 runAllTasks\n\n7) 每个 Worker NIOEventLoop 循环执行的步骤\n\n​\t1.轮询read, write 事件\n\n​\t2.处理i/o事件， 即read , write 事件，在对应NioScocketChannel 处理\n\n​\t3.处理任务队列的任务 ， 即 runAllTasks\n\n8) 每个Worker NIOEventLoop  处理业务时，会使用pipeline(管道), pipeline 中包含了 channel , 即通过pipeline 可以获取到对应通道, 管道中维护了很多的 处理器\n\n![](netty/netty模型.png)\n\n## Netty核心组件\n\n### bootStrap，serverBootStrap\n\n- Netty 中 Bootstrap类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类\n\n- 常见的方法\n  - public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法用于服务器端，用来设置两个 EventLoop\n  - public B group(EventLoopGroup group) ，该方法用于客户端，用来设置一个 EventLoop\n  - public B channel(Class<? extends C> channelClass)，该方法用来设置一个服务器端的通道实现\n  - public <T> B option(ChannelOption<T> option, T value)，用来给 ServerChannel 添加配置\n  - public <T> ServerBootstrap childOption(ChannelOption<T> childOption, T value)，用来给接收到的通道添加配置\n  - public ServerBootstrap childHandler(ChannelHandler childHandler)，该方法用来设置业务处理类（自定义的 handler）\n  - public ChannelFuture bind(int inetPort) ，该方法用于服务器端，用来设置占用的端口号\n  - public ChannelFuture connect(String inetHost, int inetPort) ，该方法用于客户端，用来连接服务器端\n\n### Future、ChannelFuture\n\n- Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件\n- 常见的方法有\n  - Channel channel()，返回当前正在进行 IO 操作的通道\n  - ChannelFuture sync()，等待异步操作执行完毕\n\n### Channel\n\n- Netty 网络通信的组件，能够用于执行网络 I/O 操作。\n- 通过Channel 可获得当前网络连接的通道的状态\n- 通过Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）\n\n- 常用的 Channel类型\n  - NioSocketChannel，异步的客户端 TCP Socket 连接。\n  - NioServerSocketChannel，异步的服务器端 TCP Socket 连接。\n  - NioDatagramChannel，异步的 UDP 连接。\n  - NioSctpChannel，异步的客户端 Sctp 连接。\n  - NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件IO。\n\n### Selector\n\n- Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。\n\n- 当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel \n\n### ChannelHandler及其实现类\n\n- ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。\n\n- ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类\n\n![](netty/ChannelHandler.png)\n\n```java\nChannelInboundHandler //用于处理入站 I/O 事件。\nChannelOutboundHandler //用于处理出站 I/O 操作。\n\n//适配器\nChannelInboundHandlerAdapter //用于处理入站 I/O 事件。\nChannelOutboundHandlerAdapter //用于处理出站 I/O 操作。\nChannelDuplexHandler //用于处理入站和出站事件\n```\n\n### Pipeline和ChannelPipeline\n\n在 Netty中每个 Channel都有且仅有一个ChannelPipeline与之对应，它们的组成关系如下\n\n![](picture/pipeline.png)\n\n- 一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler\n- 入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰\n\n### ChannelHandlerContext\n\n- 保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象\n- 即ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler进行调用.\n- 常用方法\n  - ChannelFuture close()，关闭通道\n  - ChannelOutboundInvoker flush()，刷新\n  - ChannelFuture writeAndFlush(Object msg) ， 将 数 据 写 到 ChannelPipeline 当中 \n  - ChannelHandler 的下一个 ChannelHandler 开始处理（出站）\n\n### ChannelOption\n\n- Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。\n\n- ChannelOption 参数\n\n  - **ChannelOption.SO_BACKLOG**\n\n    对应 TCP/IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。服\n\n    务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户\n\n    端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定\n\n    了队列的大小。\n\n  - **ChannelOption.SO_KEEPALIVE**\n\n    一直保持连接活动状态\n\n\n\n### EventLoopGroup和其实现类NioEventLoopGroup\n\n- EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。\n- EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop来处理任务。在 Netty 服务器端编程中，我们一般都需要提供两个 EventLoopGroup，例如：BossEventLoopGroup 和 WorkerEventLoopGroup。\n\n- 通常一个服务端口即一个ServerSocketChannel对应一个Selector和一个EventLoop线程。BossEventLoop 负责接收客户端的连接并将SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示\n\n![](netty/eventLoopGroup.png)\n\n- 说明\n  - BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了ServerSocketChannel 的 Selector 实例BossEventLoop 不断轮询 Selector 将连接事件分离出来\n  - 通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup\n  - WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop来将这个 SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理\n\n### Unpooled类\n\n1. Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类\n\n2. 常用方法如下所示\n\n   ```java\n   //通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）\n   public static ByteBuf copiedBuffer(CharSequence string, Charset charset)\n   ```\n\n   \n\n3. 举例说明Unpooled 获取 Netty的数据容器ByteBuf 的基本使用 【案例演示】\n\n\n\n## 编码和解码\n\n- 写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码。\n- codec(编解码器) 的组成部分有两个：decoder(解码器)和 encoder(编码器)。encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成业务数据\n\n### Netty 提供的编码器\n\n- StringEncoder，对字符串数据进行编码\n\n- ObjectEncoder，对 Java 对象进行编码\n  - netty提供的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象的编码和解码，底层使用的仍是 Java 序列化技术 。注意序列化的缺点是什么？1.无法跨语言，2.序列化后体积太大，是二进制编码的五倍多，3.序列化性能太低\n\n### 其他编码器\n\n- LineBasedFrameDecoder：这个类在Netty内部也有使用，它使用行尾控制字符（\\n或者\\r\\n）作为分隔符来解析数据。\n\n- DelimiterBasedFrameDecoder：使用自定义的特殊字符作为消息的分隔符。\n\n- HttpObjectDecoder：一个HTTP数据的解码器\n- LengthFieldBasedFrameDecoder：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。\n\n### Protobuf\n\n1) Protobuf 是 Google 发布的开源项目，全称 Google Protocol Buffers，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC[远程过程调用 remote procedure call ] 数据交换格式 。\n 目前很多公司 http+json è tcp+protobuf\n\n2) 参考文档 : [https://](https://developers.google.com/protocol-buffers/docs/proto)[developers.google.com/protocol-buffers/docs/proto](https://developers.google.com/protocol-buffers/docs/proto)   语言指南\n\n3) Protobuf 是以 message 的方式来管理数据的.\n\n4) 支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的] （**支持目前绝大多数语言**，例如 C++、C#、Java、python 等）\n\n5)高性能，高可靠性\n\n6)使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用.proto 文件进行描述。说明，在idea 中编写 .proto 文件时，会自动提示是否下载 .ptotot 编写插件. 可以让语法高亮。\n\n7)然后通过 protoc.exe 编译器根据.proto 自动生成.java 文件\n\n## Netty的handler链的调用机制\n\nChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的\n\n\n\n![](netty/handler链.png)\n\n## TCP 粘包和拆包基本介绍\n\n1)TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的\n\n2)由于TCP无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题, 看一张图\n\n\n\n![](netty/TCP粘拆包.png)\n\n假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：\n\n- 1)服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包\n\n- 2)服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包\n\n- 3)服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包\n\n- 4)服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。\n\n### 现象实例\n\nhttps://github.com/mk-passby/mk_learn/tree/master/netty/src/main/java/com/mk/learn/netty/tcp\n\n### 解决方案\n\n1)使用自定义协议 + 编解码器 来解决\n\n2)关键就是要解决 服务器端每次读取数据长度的问题, 这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 。\n\nhttps://github.com/mk-passby/mk_learn/tree/master/netty/src/main/java/com/mk/learn/netty/protocaltcp\n\n\n\n## 基于netty实现的简易Dubbo\n\nhttps://github.com/mk-passby/mk_learn/tree/master/netty/src/main/java/com/mk/learn/dubborpc","tags":["中间件"]},{"title":"BIO和NIO","url":"/2020/09/29/中间件/netty/BIO和NIO/","content":"\n\n\n## BIO\n\n### BIO 基本介绍\n\n- Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io \n- BIO(blocking I/O) 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善\n- BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解\n### BIO 工作机制\n\n![](BIO和NIO/BIO.png)\n\n- BIO编程简单流程\n\n   1)服务器端启动一个ServerSocket\n\n  2)客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯\n\n  3)客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝\n\n  4)如果有响应，客户端线程会等待请求结束后，在继续执行\n\n### 应用实例\n\n1)使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯。\n\n2)要求使用线程池机制改善，可以连接多个客户端.服务器端可以接收客户端发送的数据\n\n- 示例代码：\n\n```java\npackage com.mk.learn.bio;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-21 21:42\n **/\npublic class BIOServer {\n    public static void main(String[] args) throws Exception {\n        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();\n        ServerSocket server = new ServerSocket(6666);\n        System.out.println(\"tomcat服务启动...\");\n        while (true) {\n            final Socket socket = server.accept();\n            System.out.println(\"连接到一个客服端\");\n            newCachedThreadPool.execute(() -> {\n                //处理socket\n                handler(socket);\n            });\n        }\n\n    }\n    /**\n     * 处理类\n     *\n     * @param socket\n     */\n    public static void handler(Socket socket) {\n        try {\n            byte[] bytes = new byte[1024];\n            InputStream inputStream = socket.getInputStream();\n\n            while (true) {\n                int read = inputStream.read(bytes);\n                if (read != -1) {\n                    System.out.println(new String(bytes, 0, read, \"UTF-8\"));\n                } else {\n                    break;\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                System.out.println(\"断开和客户端的连接..\");\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n\n\n### BIO存在的问题\n\n1. 每个请求对应需要创建独立的线程，处理数据\n2. 并发量大，系统资源占用大\n3. 建立连接后，如果没有数据可读的时候，线程就阻塞在read操作上，造成资源浪费\n\n### windows下telnet基本使用\n\n- 输入链接(Socket)：`telnet 127.0.0.1 6666`\n- 发送一行信息\n  - 在弹出的输入框中首先需要切换到输入模式`CTRL+]`，默认是输入后直接发送\n\n### socket连接的创建方式\n\n- SocketServer\n\n```java\npackage com.mk.learn.bio;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-21 21:43\n **/\npublic class SocketServer {\n    public static void main(String[] args) throws IOException {\n        ServerSocket socketServer = new ServerSocket(3333);\n        Socket socket = socketServer.accept();\n        InputStream inputStream = socket.getInputStream();\n        byte[] bytes = new byte[1024];\n        while(true){\n            int len;\n            while ((len = inputStream.read(bytes)) != -1) {\n                System.out.println(new String(bytes, 0, len));\n            }\n        }\n    }\n}\n\n```\n\n- SocketClient\n\n```java\npackage com.mk.learn.bio;\n\nimport java.io.IOException;\nimport java.net.Socket;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-21 21:45\n **/\npublic class SocketClient {\n    public static void main(String[] args) {\n        new Thread(() -> {\n            Socket socket = null;\n            try {\n                Thread.sleep(2000);\n                socket = new Socket(\"127.0.0.1\", 3333);\n                socket.getOutputStream().write(\"test socket\".getBytes());\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n\n    }\n}\n\n```\n\n## NIO\n\n### NIO基本介绍\n\n- Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而<font color=\"##FF0000\">**不是保持线程阻塞**</font>，所以直至数据变的可以读取之前，该线程可以继续做其他的事情\n\n- NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个\n- HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级\n\n### NIO 三大核心原理\n\n![](BIO和NIO/NIO.png)\n\n1)每个channel 都会对应一个Buffer\n\n2)Selector 对应一个线程， 一个线程对应多个channel(连接)\n\n3)该图反应了有三个channel 注册到 该selector //程序\n\n4)程序切换到哪个channel 是有事件决定的, Event 就是一个重要的概念\n\n5)Selector 会根据不同的事件，在各个通道上切换\n\n6)Buffer 就是一个内存块 ， 底层是有一个数组\n\n7)数据的读取写入是通过Buffer, 这个和BIO , BIO 中要么是输入流，或者是\n 输出流, 不能双向，但是NIO的Buffer 是可以读也可以写, 需要 flip 方法切换\n\n8)channel 是双向的, 可以返回底层操作系统的情况, 比如Linux ， 底层的操作系统\n 通道就是双向的.\n\n#### Buffer\n\n![](BIO和NIO/Buffer.png)\n\n- 缓冲区（Buffer）：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer\n\n- Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息\n| 属性     | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| Capacity | 容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变 |\n| Limit    | 表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的 |\n| Position | 位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变改值，为下次读写作准备 |\n| Mark     | 标记                                                         |\n\n\n\n- Buffer类相关方法\n\n```java\npublic abstract class Buffer {\n    //JDK1.4时，引入的api\n    public final int capacity( )//返回此缓冲区的容量\n    public final int position( )//返回此缓冲区的位置\n    public final Buffer position (int newPositio)//设置此缓冲区的位置\n    public final int limit( )//返回此缓冲区的限制\n    public final Buffer limit (int newLimit)//设置此缓冲区的限制\n    public final Buffer mark( )//在此缓冲区的位置设置标记\n    public final Buffer reset( )//将此缓冲区的位置重置为以前标记的位置\n    public final Buffer clear( )//清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖\n    public final Buffer flip( )//反转此缓冲区\n    public final Buffer rewind( )//重绕此缓冲区\n    public final int remaining( )//返回当前位置与限制之间的元素数\n    public final boolean hasRemaining( )//告知在当前位置和限制之间是否有元素\n    public abstract boolean isReadOnly( );//告知此缓冲区是否为只读缓冲区\n \n    //JDK1.6时引入的api\n    public abstract boolean hasArray();//告知此缓冲区是否具有可访问的底层实现数组\n    public abstract Object array();//返回此缓冲区的底层实现数组\n    public abstract int arrayOffset();//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量\n    public abstract boolean isDirect();//告知此缓冲区是否为直接缓冲区\n}\n\n```\n\n\n\n##### ByteBuffer\n\n对于 Java 中的基本数据类型(boolean除外)，都有一个 Buffer类型与之相对应，最常用的自然是ByteBuffer 类（二进制数据），该类的主要方法如下\n\n```java\npublic abstract class ByteBuffer {\n    //缓冲区创建相关api\n    public static ByteBuffer allocateDirect(int capacity)//创建直接缓冲区\n    public static ByteBuffer allocate(int capacity)//设置缓冲区的初始容量\n    public static ByteBuffer wrap(byte[] array)//把一个数组放到缓冲区中使用\n    //构造初始化位置offset和上界length的缓冲区\n    public static ByteBuffer wrap(byte[] array,int offset, int length)\n     //缓存区存取相关API\n    public abstract byte get( );//从当前位置position上get，get之后，position会自动+1\n    public abstract byte get (int index);//从绝对位置get\n    public abstract ByteBuffer put (byte b);//从当前位置上添加，put之后，position会自动+1\n    public abstract ByteBuffer put (int index, byte b);//从绝对位置上put\n }\n\n```\n\n\n\n#### Channel\n\n1)NIO的通道类似于流，但有些区别如下：\n\n- 通道可以同时进行读写，而流只能读或者只能写\n\n- 通道可以实现异步读写数据\n\n- 通道可以从缓冲读数据，也可以写数据到缓冲\n\n2)BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。\n\n3)Channel在NIO中是一个接口 `public interface Channel extends Closeable{} `\n\n4)常用的 Channel 类有：`FileChannel`、`DatagramChannel`、`ServerSocketChannel` 和 `SocketChannel`。【`ServerSocketChanne` 类似 `ServerSocket` , `SocketChannel` 类似 `Socket`】\n\n5)`FileChannel` 用于文件的数据读写，`DatagramChannel` 用于 UDP 的数据读写，`ServerSocketChannel` 和 `SocketChannel` 用于 TCP 的数据读写。\n\n##### FileChannel类\n\n- public int read(ByteBuffer dst) ，从通道读取数据并放到缓冲区中\n- public int write(ByteBuffer src) ，把缓冲区的数据写到通道中\n- public long transferFrom(ReadableByteChannel src, long position, long count)，从目标通道中复制数据到当前通道\n- public long transferTo(long position, long count, WritableByteChannel target)，把数据从当前通道复制给目标通道\n\n\n\n##### 应用实例1-本地文件写数据\n\n- 使用ByteBuffer(缓冲) 和 FileChannel(通道)， 将 `hello,这是一个测试案例~`写入到file01.txt中\n\n  ```java\n  package com.mk.learn.nio;\n  \n  import java.io.File;\n  import java.io.FileOutputStream;\n  import java.io.IOException;\n  import java.nio.ByteBuffer;\n  import java.nio.channels.FileChannel;\n  \n  /**\n   * @program: learning-demo\n   * @description:\n   * @author: mk_passby\n   * @create: 2020-09-21 21:45\n   **/\n  public class NIOFileOper01 {\n  \n      /**\n       * 使用FileChannel，ByteBuffer将字符串写入文件\n       */\n      public static void main(String[] args) throws IOException {\n  \n          String str = \"hello,这是一个测试案例~\";\n          String filePath = NIOFileOper01.class.getResource(\"/\").getPath();\n          FileOutputStream fos = new FileOutputStream(filePath + File.separator + \"001.txt\");\n          //使用FileChannel 通道\n          //fos.getChannle 返回的是 FileChanel 的实现子类 FileChannelImpl\n          //可以追下源代码\n          FileChannel fc = fos.getChannel();\n          ByteBuffer buffer = ByteBuffer.allocate(1024);\n        /*\n         *NIO 中的通道是从输出流对象里通过 getChannel 方法获取到的，该通道是双向的，既可\n         以读，又可以写。在往通道里写数据之前，必须通过 put 方法把数据存到 ByteBuffer 中，然\n           后通过通道的 write 方法写数据。在 write 之前，需要调用 flip 方法翻转缓冲区，把内部重置\n           到初始位置，这样在接下来写数据时才能把所有数据写到通道里\n         */\n          buffer.put(str.getBytes());\n          buffer.flip();\n          fc.write(buffer);\n          fos.close();\n  \n      }\n  }\n  \n  ```\n\n##### 应用实例2-本地文件读数据\n\n- 使用ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读入到程序，并显示在控制台屏幕\n\n```java\npackage com.mk.learn.nio;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\n/**\n * @program: learning-demo\n * @description:使用ByteBuffer(缓冲) 和 FileChannel(通道)， 将 file01.txt 中的数据读入到程序，并显示在控制台屏幕\n * @author: mk_passby\n * @create: 2020-09-21 21:47\n **/\npublic class NIOFileOPer02 {\n    public static void main(String[] args) throws IOException {\n        File file=new File(\"D:/file01.txt\");\n        FileInputStream fileInputStream=new FileInputStream(file);\n        FileChannel channel = fileInputStream.getChannel();\n        ByteBuffer byteBuffer= ByteBuffer.allocate((int) file.length());\n        channel.read(byteBuffer);\n        System.out.println(new String(byteBuffer.array(),\"UTF-8\"));\n        fileInputStream.close();\n    }\n}\n\n```\n\n##### 应用实例3-使用一个Buffer完成文件读取\n\n- 使用 FileChannel(通道) 和 方法  read , write，完成文件的拷贝\n\n```java\npackage com.mk.learn.nio;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\n\n/**\n * @program: learning-demo\n * @description:\n * 实例要求: 使用 FileChannel(通道) 和 方法  read , write，\n * 完成文件的拷贝 拷贝一个文本文件 1.txt  , 放在项目下即可\n * @author: mk_passby\n * @create: 2020-09-21 21:50\n **/\npublic class NIOFileOPer03 {\n    public static void main(String[] args) throws IOException {\n        File file=new File(\"D:/file01.txt\");\n        FileInputStream fileInputStream=new FileInputStream(file);\n        FileChannel channel = fileInputStream.getChannel();\n        ByteBuffer byteBuffer=ByteBuffer.allocate((int) file.length());\n        //将channel里面的数据读到buffer中\n        channel.read(byteBuffer);\n        //将数据读到byteBuffer中，然后写出\n        FileOutputStream fileOutputStream=new FileOutputStream(\"D:/file02.txt\");\n        FileChannel outputStreamChannel = fileOutputStream.getChannel();\n        //byteBuffer由写操作flip成读操作\n        byteBuffer.flip();\n        outputStreamChannel.write(byteBuffer);\n        outputStreamChannel.close();\n        fileInputStream.close();\n    }\n}\n\n```\n\n##### 应用实例4-拷贝文件transferFrom 方法\n\n- 使用 FileChannel(通道) 和 方法  transferFrom ，完成文件的拷贝\n\n```java\npackage com.mk.learn.nio;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-21 21:51\n **/\npublic class NioFileCopy {\n    public static void main(String[] args) throws IOException {\n        FileInputStream fis=new FileInputStream(\"d:\\\\file01.txt\");\n        FileOutputStream fos=new FileOutputStream(\"d:\\\\file04.txt\");\n        /*\n         * 说明\n         * 从两个流中得到两个通道，sourCh ,destCh ，\n         * 然后直接调用 transferFrom 完成文件复制\n         */\n        FileChannel sourCh = fis.getChannel();\n        FileChannel destCh = fos.getChannel();\n\n        /*\n         * transferFrom 方法可以将两个通道连接起来，进行数据传输\n         * @param  src\n         *         The source channel\n         *\n         * @param  position\n         *         The position within the file at which the transfer is to begin;\n         *         must be non-negative\n         *\n         * @param  count\n         *         The maximum number of bytes to be transferred; must be\n         *         non-negative\n         *\n         * @return  The number of bytes, possibly zero,\n         *          that were actually transferred\n         */\n\n        destCh.transferFrom(sourCh, 0, sourCh.size());\n        sourCh.close();\n        destCh.close();\n        fis.close();\n        fos.close();\n        System.out.println(\"拷贝完毕~~\");\n    }\n}\n\n```\n\n#### selector\n\n##### 基本介绍\n\n1)Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到<font color='#ff0000'>Selector(选择器)</font>\n\n2)<font color='#ff0000'>**Selector** **能够检测多个注册的通道上是否有事件发生(注意多个Channel以事件的方式可以注册到同一个Selector)**</font>，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。\n\n3)只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程\n\n4)避免了多线程之间的上下文切换导致的开销\n\n##### 特点再说明\n\n![](BIO和NIO/Selector.png)\n\n1)Netty 的 IO 线程 NioEventLoop 聚合了 Selector(选择器，也叫多路复用器)，可以同时并发处理成百上千个客户端连接。\n\n2)当线程从某客户端 Socket 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。\n\n3)线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。\n\n4)由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。\n\n5)一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。\n\n##### Selector类相关方法\n\n```markdown\npublic abstract class Selector implements Closeable { \npublic static Selector open();//得到一个选择器对象\npublic int select(long timeout);//监控所有注册的通道，当其中有 IO 操作可以进行时，将\n对应的 SelectionKey 加入到内部集合中并返回，参数用来设置超时时间\npublic Set<SelectionKey> selectedKeys();//从内部集合中得到所有的 SelectionKey\t\n}\n```\n\n- selector 相关方法说明\n\n```java\nselector.select()//阻塞\nselector.select(1000);//阻塞1000毫秒，在1000毫秒后返回\nselector.wakeup();//唤醒selector\nselector.selectNow();//不阻塞，立马返还\n```\n\n\n\n### NIO 非阻塞 网络编程原理分析图\n\n![](BIO和NIO/NIOSocket.png)\n\n1. 当客户端连接时，会通过ServerSocketChannel 得到 SocketChannel\n2. Selector 进行监听  select 方法, 返回有事件发生的通道的个数.\n\n3. 将socketChannel注册到Selector上, register(Selector sel, int ops), 一个selector上可以注册多个SocketChannel\n\n4. 注册后返回一个 SelectionKey, 会和该Selector 关联(集合)\n5. 进一步得到各个 SelectionKey (有事件发生)\n6. 在通过 SelectionKey  反向获取 SocketChannel , 方法 channel()\n7. 可以通过  得到的 channel  , 完成业务处理\n\n#### selectkey\n\n1. 表示 Selector和网络通道的注册关系\n\n- int OP_ACCEPT：有新的网络连接可以 accept，值为 16\n\n- int OP_CONNECT：代表连接已经建立，值为 8\n\n- int OP_READ：代表读操作，值为 1 \n\n- int OP_WRITE：代表写操作，值为 4\n\n```java\npublic static final int OP_READ = 1 << 0; \npublic static final int OP_WRITE = 1 << 2;\npublic static final int OP_CONNECT = 1 << 3;\npublic static final int OP_ACCEPT = 1 << 4;\n```\n\n2. SelectionKey相关方法\n```java\npublic abstract class  SelectionKey {\n   public abstract Selector selector();//得到与之关联的 Selector 对象\n   public abstract SelectableChannel channel();//得到与之关联的通道\n   public final Object attachment();//得到与之关联的共享数据\n   public abstract SelectionKey interestOps(int ops);//设置或改变监听事件\n   public final boolean isAcceptable();//是否可以 accept\n   public final boolean isReadable();//是否可以读\n   public final boolean isWritable();//是否可以写\n}\n```\n\n#### ServerSocketChannel\n\n1. 在**服务器端监听新的客户端** **Socket** **连**接\n2. 相关方法\n\n```java\npublic abstract class ServerSocketChannel extends AbstractSelectableChannel implements NetworkChannel{\n\tpublic static ServerSocketChannel open()，//得到一个 ServerSocketChannel 通道\n\tpublic final ServerSocketChannel bind(SocketAddress local)，//设置服务器端端口号\n\tpublic final SelectableChannel configureBlocking(boolean block)，//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式\n\tpublic SocketChannel accept()，//接受一个连接，返回代表这个连接的通道对象\n\tpublic final SelectionKey register(Selector sel, int ops)，//注册一个选择器并设置监听事件\n}\n\n```\n\n#### SocketChannel\n\n1. 网络 IO 通道，**具体负责进行读写操作**。NIO 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区\n2. 相关方法\n\n```java\npublic abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel{\npublic static SocketChannel open();//得到一个 SocketChannel 通道\npublic final SelectableChannel configureBlocking(boolean block);//设置阻塞或非阻塞模式，取值 false 表示采用非阻塞模式\npublic boolean connect(SocketAddress remote);//连接服务器\npublic boolean finishConnect();//如果上面的方法连接失败，接下来就要通过该方法完成连接操作\npublic int write(ByteBuffer src);//往通道里写数据\npublic int read(ByteBuffer dst);//从通道里读数据\npublic final SelectionKey register(Selector sel, int ops, Object att);//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据\npublic final void close();//关闭通道\n}\n```\n\n### NIO 网络编程应用实例-群聊系统\n\n- GroupChatServer\n\n```java\npackage com.mk.learn.nio.qqchat;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.text.SimpleDateFormat;\nimport java.util.Iterator;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-21 22:30\n **/\npublic class GroupChatServer {\n    private Selector selector;\n    private ServerSocketChannel listenerChannel;\n    private static final int PORT = 6667; //服务器端口\n\n    public GroupChatServer() {\n        try {\n            // 得到选择器\n            selector = Selector.open();\n            // 打开监听通道\n            listenerChannel = ServerSocketChannel.open();\n            // 绑定端口\n            listenerChannel.socket().bind(new InetSocketAddress(PORT));\n            // 设置为非阻塞模式\n            listenerChannel.configureBlocking(false);\n            // 将选择器绑定到监听通道并监听 accept 事件\n            listenerChannel.register(selector, SelectionKey.OP_ACCEPT);\n            printInfo(\"服务器 ok.......\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void listen() {\n        try {\n            while (true) { //不停轮询\n                int count = selector.select();//获取就绪 channel\n                if (count > 0) {\n                    Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n                    while (iterator.hasNext()) {\n                        SelectionKey key = iterator.next();\n                        // 监听到 accept\n                        if (key.isAcceptable()) {\n                            SocketChannel sc = listenerChannel.accept();\n                            //非阻塞模式\n                            sc.configureBlocking(false);\n                            //注册到选择器上并监听 read\n                            sc.register(selector, SelectionKey.OP_READ);\n\n                            //System.out.println(sc.getRemoteAddress().toString().substring(1) + \"online ...\");\n                            System.out.println(sc.socket().getRemoteSocketAddress().toString().substring(1) + \" 上线 ...\");\n                            //将此对应的 channel 设置为 accept,接着准备接受其他客户端请求\n                            key.interestOps(SelectionKey.OP_ACCEPT);\n                        }\n                        //监听到 read\n                        if (key.isReadable()) {\n                            readData(key); //读取客户端发来的数据\n                        }\n                        //一定要把当前 key 删掉，防止重复处理\n                        iterator.remove();\n                    }\n                } else {\n                    System.out.println(\"waitting ...\");\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void readData(SelectionKey key) {\n        SocketChannel channel = null;\n        try {\n            // 得到关联的通道\n            channel = (SocketChannel) key.channel();\n            //设置 buffer 缓冲区\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            //从通道中读取数据并存储到缓冲区中\n            int count = channel.read(buffer);\n            //如果读取到了数据\n            if (count > 0) {\n                //把缓冲区数据转换为字符串\n                String msg = new String(buffer.array());\n\n                printInfo(msg);\n                //将关联的 channel 设置为 read，继续准备接受数据\n                key.interestOps(SelectionKey.OP_READ);\n                sendInfoToOtherClients(channel, msg); //向所有客户端广播数据\n            }\n            buffer.clear();\n        } catch (IOException e) {\n            try {\n                //当客户端关闭 channel 时，进行异常如理\n                //printInfo(channel.getRemoteAddress().toString().substring(1) + \"offline...\");\n                printInfo(channel.socket().getRemoteSocketAddress().toString().substring(1) + \" 离线了 ...\");\n                key.cancel(); //取消注册\n                channel.close(); //关闭通道\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n        }\n    }\n\n    public void sendInfoToOtherClients(SocketChannel except, String msg) throws IOException {\n        System.out.println(\"服务器进行消息转发 ...\");\n        //转发数据到所有的 SocketChannel 中\n        for (SelectionKey key : selector.keys()) {\n            Channel targetchannel = key.channel();\n            //排除自身\n            if (targetchannel instanceof SocketChannel && targetchannel != except) {\n                SocketChannel dest = (SocketChannel) targetchannel;\n                //把数据存储到缓冲区中\n                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());\n                //往通道中写数据\n                dest.write(buffer);\n            }\n        }\n    }\n\n    private void printInfo(String str) { //显示消息\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(\"服务器接收到消息 时间: [\" + sdf.format(new java.util.Date()) + \"] -> \" + str);\n    }\n\n    public static void main(String[] args) {\n        GroupChatServer server = new GroupChatServer();\n        server.listen();\n    }\n}\n\n```\n\n- GroupChatClient\n\n```java\npackage com.mk.learn.nio.qqchat;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.Set;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-21 22:31\n **/\npublic class GroupChatClient {\n    //服务器地址\n    private final String HOST = \"127.0.0.1\";\n    //服务器端口\n    private int PORT = 6667;\n    private Selector selector;\n    private SocketChannel socketChannel;\n    private String userName;\n\n    public GroupChatClient() throws IOException {\n        //得到选择器\n        selector = Selector.open();\n        //连接远程服务器\n        socketChannel = SocketChannel.open(new InetSocketAddress(HOST, PORT));\n        //设置非阻塞\n        socketChannel.configureBlocking(false);\n        //注册选择器并设置为 read\n        socketChannel.register(selector, SelectionKey.OP_READ);\n        //得到客户端 IP 地址和端口信息，作为聊天用户名使用\n        userName = socketChannel.getLocalAddress().toString().substring(1);\n        System.out.println(userName + \" is ok ~\");\n    }\n\n    //向服务器端发送数据\n    public void sendInfo(String info) throws Exception {\n        //如果控制台输入 exit 就关闭通道，结束聊天\n        if (info.equalsIgnoreCase(\"exit\")) {\n            socketChannel.write(ByteBuffer.wrap(info.getBytes()));\n            socketChannel.close();\n            socketChannel = null;\n            return;\n        }\n        info = userName + \" 说: \" + info;\n        try {\n            //往通道中写数据\n            socketChannel.write(ByteBuffer.wrap(info.getBytes()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    //从服务器端接收数据\n    public void readInfo() {\n        try {\n            int readyChannels = selector.select();\n            //有可用通道\n            if (readyChannels > 0) {\n                Set selectedKeys = selector.selectedKeys();\n                Iterator keyIterator = selectedKeys.iterator();\n                while (keyIterator.hasNext()) {\n                    SelectionKey sk = (SelectionKey) keyIterator.next();\n                    if (sk.isReadable()) {\n                        //得到关联的通道\n                        SocketChannel sc = (SocketChannel) sk.channel();\n                        //得到一个缓冲区\n                        ByteBuffer buff = ByteBuffer.allocate(1024);\n                        //读取数据并存储到缓冲区\n                        sc.read(buff);\n                        //把缓冲区数据转换成字符串\n                        String msg = new String(buff.array());\n                        System.out.println(msg.trim());\n                    }\n                    keyIterator.remove(); //删除当前 SelectionKey，防止重复处理\n                }\n            } else {\n                //会检测到没有可用的channel ，可以退出\n                System.out.println(\"没有可用channel ...\");\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws Exception  {\n        //创建一个聊天客户端对象\n        GroupChatClient chatClient = new GroupChatClient();\n        new Thread() { //单独开一个线程不断的接收服务器端广播的数据\n            public void run() {\n                while (true) {\n                    chatClient.readInfo();\n                    try { //间隔 3 秒\n                        Thread.currentThread().sleep(3000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }.start();\n\n        Scanner scanner = new Scanner(System.in);\n        //在控制台输入数据并发送到服务器端\n        while (scanner.hasNextLine()) {\n            String msg = scanner.nextLine();\n            chatClient.sendInfo(msg.trim());\n        }\n    }\n}\n\n```\n\n### NIO与零拷贝\n\nhttps://www.cnblogs.com/ericli-ericli/articles/12923420.html\n\n#### 传统IO\n\n- 四次上下文切换。userContext -> kernelContext -> userContext -> kernelContext\n- 四次拷贝。DMA copy -> CPU copy -> CPU copy -> DMA copy\n\n\n\n![](BIO和NIO/traditionalIO.png)\n\n\n\n\n\n\n\n#### mmap(内存映射) \n\n- 四次上下文切换。userContext -> kernelContext -> userContext -> kernelContext\n- 三次拷贝。DMA copy -> CPU copy -> DMA copy\n\n​\t![](BIO和NIO/mmap.png)\n\n#### sendFile\n\n- 三次上下文切换。userContext -> kernelContext -> userContext\n- 三次拷贝。DMA copy -> CPU copy -> DMA copy\n\n![](BIO和NIO/sendfile.png)\n\n##### sendfile的优化\n\nLinux 在 2.4 版本中，做了一些修改，避免了从内核缓冲区拷贝到 Socket\nbuffer 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝\n\n- 三次上下文切换。userContext -> kernelContext -> userContext\n- 三次拷贝。DMA copy  -> DMA copy\n  - 这里其实有 一次cpu 拷贝kernel buffer -> socket buffer但是，拷贝的信息很少，比如lenght , offset , 消耗低，可以忽略\n\n![](BIO和NIO/sendfile2.png)\n\n#### 总结\n\n1)mmap 适合小数据量读写，sendFile 适合大文件传输。\n\n2)mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。\n\n3)sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。","tags":["网络通讯"]},{"title":"Spring 工厂","url":"/2020/09/12/框架系列/spring/Spring工厂/","content":"\n\n\n## Spring 工厂\n\n1.传统的创建对象的方式为直接new一个对象，这样导致对象间耦合度高，如果对象发生变化，则需要到处修改。这样导致很多时候我们只是想在不同的地方调用对象的方法，但是不得不重复创建对象。\n\n### 创建对象\n\n这里列举两个对象的创建方式(不止这两个，序列化，克隆等都是，这里我们只介绍new和反射)\n\n- 直接new创建对象\n- 反射创建对象\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\nimport com.mk.learn.spring.ioc.module.User;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-27 22:40\n **/\npublic class Test {\n\n    public static void main(String[] args)\n        throws ClassNotFoundException, InstantiationException, IllegalAccessException {\n        //直接new创建对象\n        //User user=new User();\n        Test test = new Test();\n        //反射创建对象\n        User user = test.createUserByRefle();\n\n    }\n\n    private User createUserByRefle()\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return (User) Class.forName(\"com.mk.learn.spring.ioc.module.User\").newInstance();\n    }\n\n}\n\n```\n\n这样直接看两种创建方式似乎没什么差别，但是如果将`\"com.mk.learn.spring.ioc.module.User\"`这部分内容提出来呢。使用工厂模式，于是有了下面的变形\n\n### 将对象的创建交给工厂\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-17 21:10\n **/\npublic class NormalFactory {\n    public static Object createObjectByRefle(String className)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return Class.forName(className).newInstance();\n    }\n}\n```\n\n于是对象的创建就通过如下的方式\n\n```java\nUser user1 = (User) NormalFactory.createObjectByRefle(User.class.getName());\n```\n\n**思考该创建方式**\n\n- 为什么这里createObjectByRefle要用Object做返回值不用User对象呢？如果用User对象都不用强转不是更方便吗？\n  - 如果使用User对象做返回值<font color=#FF0000>扩展性极差</font>，假设有一个UserA对象需要用工厂创建，就需要新增一个创建UserA的方法。这样导致工厂类臃肿。使用Object做返回值则更优雅。\n\n\n\n但是这里又有一个问题，这里工厂创建的对象不够灵活。NormalFactory对象强依赖User.class.getName()。既然已经强依赖了，那么怎么思考下是不是需要统一管理呢？\n\n### 怎么处理类的统一管理呢？\n\n这里我们可以通过配置文件统一管理类名。\n\n这里使用properties举例：\n\n在resources下新增factoryObject.properties\n\n```properties\nuser=com.mk.learn.spring.ioc.module.User\n```\n\n那么我们的工厂类进一步变为如下的方式创建：\n\n```java\n public static Object createObjectByProperties(String name)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException {\n        InputStream\n            inputStream =\n            NormalFactory.class.getResourceAsStream(\"/factoryObject.properties\");\n        Properties properties=new Properties();\n        properties.load(inputStream);\n\n            //创建普通对象\n        return Class.forName(properties.getProperty(name)).newInstance();\n    }\n```\n\n\n\n我们创建对象的方式可以改用如下：\n\n```java\n User user2 = (User) NormalFactory.createObjectByProperties(\"user\");\n```\n\n\n\n### 至此，我们的完整代码如下：\n\n- NormalFactory普通工厂\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-17 21:10\n **/\npublic class NormalFactory {\n\n    /**\n     * 通过工厂创建对象\n     * @param className\n     * @return\n     * @throws ClassNotFoundException\n     * @throws IllegalAccessException\n     * @throws InstantiationException\n     */\n    public static Object createObjectByRefle(String className)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return Class.forName(className).newInstance();\n    }\n\n    /**\n     * 通过工厂+properties创建对象\n     * @param name\n     * @return\n     * @throws ClassNotFoundException\n     * @throws IllegalAccessException\n     * @throws InstantiationException\n     * @throws IOException\n     */\n    public static Object createObjectByProperties(String name)\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException, IOException {\n        InputStream\n            inputStream =\n            NormalFactory.class.getResourceAsStream(\"/factoryObject.properties\");\n        Properties properties=new Properties();\n        properties.load(inputStream);\n\n            //创建普通对象\n        return Class.forName(properties.getProperty(name)).newInstance();\n    }\n}\n\n```\n\n\n\n- Test测试类\n\n```java\npackage com.mk.learn.spring.ioc.factory;\n\nimport com.mk.learn.spring.ioc.module.User;\nimport java.io.IOException;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-27 22:40\n **/\npublic class Test {\n    public static void main(String[] args)\n        throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException {\n        //直接new创建对象\n        //User user=new User();\n        Test test = new Test();\n        System.out.println(\"通过new获取对象：\" + test);\n        System.out.println(test);\n        //反射创建对象\n        User user = test.createUserByRefle();\n        System.out.println(\"通过反射获取对象：\" + user);\n        //反射工厂创建对象\n        User user1 = (User) NormalFactory.createObjectByRefle(User.class.getName());\n        System.out.println(\"通过工厂反射获取对象：\" + user1);\n        //反射工厂+properties创建对象\n        User user2 = (User) NormalFactory.createObjectByProperties(\"user\");\n        System.out.println(\"通过properties获取对象：\" + user2);\n    }\n\n    private User createUserByRefle()\n        throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        //创建普通对象\n        return (User) Class.forName(\"com.mk.learn.spring.ioc.module.User\").newInstance();\n    }\n}\n```\n\n- user对象\n\n```java\npackage com.mk.learn.spring.ioc.module;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-25 22:20\n **/\npublic class User {\n    private String name;\n    private int age;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n\n```\n\n\n\n### spring怎么获取bean对象的呢\n\n#### 依赖jar包\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <parent>\n    <artifactId>learning-demo</artifactId>\n    <groupId>com.learn.mk</groupId>\n    <version>1.0-SNAPSHOT</version>\n  </parent>\n  <modelVersion>4.0.0</modelVersion>\n  <artifactId>spring-demo</artifactId>\n<dependencies>\n  <dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-context</artifactId>\n    <version>5.1.4.RELEASE</version>\n  </dependency>\n</dependencies>\n</project>\n```\n\n#### 创建xml配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user\" class=\"com.mk.learn.spring.ioc.module.User\"/>\n</beans>\n```\n\n#### 编写测试类测试\n\n```java\npackage com.mk.learn.spring.ioc.spring;\n\nimport com.mk.learn.spring.ioc.module.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-13 20:34\n **/\npublic class SpringBeanTest {\n\n    public static void main(String[] args) {\n        ApplicationContext applicationContext=new ClassPathXmlApplicationContext(\"springBean.xml\");\n        User user = (User) applicationContext.getBean(\"user\");\n        System.out.println(\"通过spring创建Bean\"+user);\n    }\n}\n```\n\n运行结果：\n\n```\n通过spring创建Beancom.mk.learn.spring.ioc.module.User@77caeb3e\n\nProcess finished with exit code 0\n```\n\n\n\n### spring工厂的本质\n\n结合前面springbean的创建方式和对象由工厂创建的思维。可以得到我们spring工厂的本质就是工厂模式。\n\n即：\n\n- ApplicationContext⼯⼚ +springBean.xml配置文件\n\n## ApplicationContext工厂\n\n### ApplicationContext接⼝类型\n\n- 接⼝：屏蔽实现的差异\n- ⾮web环境的实现类 ：ClassPathXmlApplicationContext(main junit)\n- web环境的实现类 ：XmlWebApplicationContext\n\n### ApplicationContext常用API\n\n| 方法                                         | 介绍                                                    |\n| -------------------------------------------- | ------------------------------------------------------- |\n| getBean(String name, Class<T> requiredType)  | 通过这种⽅式获得对象，就不需要强制类型转换              |\n| getBean(Class<T> requiredType)               | 当前Spring的配置⽂件中 只能有⼀个bean class是Person类型 |\n| getBeanDefinitionNames()                     | 获取的是 Spring⼯⼚配置⽂件中所有bean标签的id值         |\n| getBeanNamesForType(@Nullable Class<?> type) | 根据类型获得Spring配置⽂件中对应的id值                  |\n| containsBeanDefinition(String beanName)      | ⽤于判断是否存在指定id值得bean,不能判断name值           |\n| containsBean(String beanName)                | ⽤于判断是否存在指定id值得bean,能判断name值             |\n\n## 配置⽂件中需要注意的细节\n\n- 只配置class属性,得到的id是com.mk.learn.spring.ioc.module.Dog#0\n  - 如果需要被其他bean引用需要配置上这个id\n\n```xml\n<bean class=\"com.mk.learn.spring.ioc.module.Dog\"/>\n```\n\n- name属性\n  - ⽤于在Spring的配置⽂件中，为bean对象定义别名。\n  - id是唯一值，只能有一个，但是别名可以定义多个。\n\n## 开发过程中，所有的对象都交给Spring⼯⼚来创建？\n\n- 理论上 是的，但是有特例 ：实体对象(entity)是不会交给Spring创建，它是由持久层框架进⾏创建\n\n## Spring5.x与⽇志框架的整合\n\n- Spring与⽇志框架进⾏整合，⽇志框架就可以在控制台中，输出Spring框架运⾏过程中的⼀些重要的信息。\n- 好处：便于了解Spring框架的运⾏过程，利于程序的调试\n\n### Spring如何整合⽇志框架\n\n -  引⼊log4j jar包\n\n    - POM文件\n\n```xml\n<dependency>\n <groupId>org.slf4j</groupId>\n <artifactId>slf4jlog4j12</artifactId>\n <version>1.7.25</version>\n</dependency>\n<dependency>\n <groupId>log4j</groupId>\n <artifactId>log4j</artifactId>\n <version>1.2.17</version>\n</dependency>\n```\n\n- log4j.properties，放在resources目录下\n\n```properties\n### 配置根\nlog4j.rootLogger =debug,console\n### ⽇志输出到控制台显示\nlog4j.appender.console=org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target=System.out\nlog4j.appender.console.layout=org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n\n运行结果如下：\n\n```markdown\n2020-09-13 21:29:09 DEBUG ClassPathXmlApplicationContext:590 - Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@1edf1c96\n2020-09-13 21:29:09 DEBUG XmlBeanDefinitionReader:395 - Loaded 3 bean definitions from class path resource [springBean.xml]\n2020-09-13 21:29:09 DEBUG DefaultListableBeanFactory:213 - Creating shared instance of singleton bean 'user'\n2020-09-13 21:29:09 DEBUG DefaultListableBeanFactory:213 - Creating shared instance of singleton bean 'user1'\n2020-09-13 21:29:09 DEBUG DefaultListableBeanFactory:213 - Creating shared instance of singleton bean 'com.mk.learn.spring.ioc.module.Dog#0'\n通过spring创建Beancom.mk.learn.spring.ioc.module.User@1f36e637\nBeanDefinitionName is:user\nBeanDefinitionName is:user1\nBeanDefinitionName is:com.mk.learn.spring.ioc.module.Dog#0\nbeanNamesForType = user\nbeanNamesForType = user1\n```\n\n## 注⼊(Injection)\n\n- 通过编码的⽅式，为成员变量进⾏赋值，存在耦合\n\n### 如何进⾏注⼊\n\n- 类的成员变量提供set get⽅法\n- 配置spring的配置⽂件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n  <bean id=\"user\" class=\"com.mk.learn.spring.ioc.module.User\">\n    <property name=\"name\">\n      <value>AAA1111</value>\n    </property>\n    <property name=\"age\" value=\"123\"/>\n  </bean>\n</beans>\n```\n\n- 测试类\n\n```java\npackage com.mk.learn.spring.ioc.spring;\n\nimport com.mk.learn.spring.ioc.module.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-13 21:34\n **/\npublic class SpringIocTest  {\n\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\n            \"springIoc.xml\");\n        User user = (User) applicationContext.getBean(\"user\");\n        System.out.println(\"user.getName() = \" + user.getName());\n        System.out.println(\"user.getAge() = \" + user.getAge());\n    }\n}\n```\n\n### 常用的注入方式\n\n#### JDK类型\n\n- 数组/List集合\n\n```xml\n<list>\n <value>AAA</value>\n <value>BBBB</value>\n <value>CCC</value>\n</list>\n```\n\n- Set集合\n\n```xml\n<set>\n <value>AAA</value>\n <value>BBBB</value>\n <value>CCC</value>\n</set>\n```\n\n- Map集合\n\n```xml\n<map>\n <entry>\n <key><value>AA</value></key>\n <value>CCCC</value>\n </entry>\n <entry>\n <key><value>AA1</value></key>\n <ref bean=\"XXXX\"/>\n </entry>\n</map>\n```\n\n- Properites\n\n```properties\n<props>\n <prop key=\"key1\">value1</prop>\n <prop key=\"key2\">value2</prop>\n</props>\n```\n\n#### ⽤户⾃定义类型\n\n- 直接配置bean对象注入\n  - 为成员变量提供set get⽅法\n  - 配置⽂件中进⾏注⼊\n\n```xml\n<bean id=\"userService\" class=\"xxxx.UserServiceImpl\">\n \t<property name=\"userDAO\">\n \t\t<bean class=\"xxx.UserDAOImpl\"/>\n \t</property>\n</bean>\n```\n\n- 使用ref指向bean\n\n```xml\n<bean id=\"userDAO\" class=\"xxx.UserDAOImpl\"/>\n<bean id=\"userService\" class=\"xxx.UserServiceImpl\">\n\t<property name=\"userDAO\">\n \t\t<ref bean=\"userDAO\"/>\n \t</property>\n</bean>\n```\n\n#### Set注⼊的简化写法\n\n```markdown\n<property name=\"aaa\">\n \t<value>CCCC</value>\n</property>\n \t可以简化为\n<property name=\"aaa\" value=\"CCCC\"/>\n\n-------------------------------\n⽤户⾃定义类型\n<property name=\"userDAO\">\n \t<ref bean=\"userDAO\"/>\n</property>\n\t可以简化为\n<property name=\"userDAO\" ref=\"userDAO\"/>\n\n-------------------------------\n<bean id=\"person\" class=\"xxxx.Person\">\n <property name=\"name\">\n \t<value>AAA</value>\n </property>\n</bean>\n\t可以简化为(需要引入命名空间p标签)\n<bean id=\"person\" class=\"xxx.Person\" p:name=\"AAA\"/>\n\n---------------------------------\n<bean id=\"userService\" class=\"xx.UserServiceImpl\">\n\t<property name=\"userDAO\">\n \t\t<ref bean=\"userDAO\"/>\n \t</property>\n</bean>\n\t可以简化为(需要引入命名空间p标签)\n<bean id=\"userService\" class=\"xxx.UserServiceImpl\" p:userDAO-ref=\"userDAO\"/>\n```\n\n\n\n#### 构造注⼊\n\n- 参数个数不同时通过控制`<constructor-arg>`标签的数量进⾏区分\n- 构造参数个数相同时,通过在标签引⼊ type属性 进⾏类型的区分`<constructor-arg type=\"\">`\n\n```java\npublic class ConstructorModule {\n    private int age;\n    private String naem;\n    public ConstructorModule(int age, String naem) {\n        this.age = age;\n        this.naem = naem;\n    }\n}\n```\n\n\n\n\n\n```xml\n <!--构造器注入-->\n  <bean id=\"constructorDemo\" class=\"com.mk.learn.spring.ioc.module.ConstructorModule\">\n    <constructor-arg value=\"123\"/>\n    <constructor-arg value=\"AAAA\"/>\n  </bean>\n```\n\n## Spring⼯⼚创建复杂对象\n\n- 复杂对象：指的就是不能直接通过new构造⽅法创建的对象(Connection,SqlSessionFactory)\n\n### Spring⼯⼚创建复杂对象的3种⽅式\n\n#### 1.FactoryBean接⼝\n\n- 实现FactoryBean接⼝\n- Spring内部运⾏流程\n  1. 通过conn获得ConnectionFactoryBean类的对象 ，进⽽通过instanceof 判断出是FactoryBean接⼝的实现类\n  2. Spring按照规定 getObject() --->Connection\n  3. 返回Connection\n\n```java\npackage com.mk.learn.spring.ioc.module;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport org.springframework.beans.factory.FactoryBean;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-09-13 22:26\n **/\npublic class ConnectionFactoryBean implements FactoryBean<Connection> {\n\n    @Override\n    public Connection getObject() throws Exception {\n        Class.forName(\"com.mysql.jdbc.Driver\");\n        Connection connection= DriverManager.getConnection(\n            \"jdbc:mysql://localhost:3306/test?useSSL=false\",\n            \"root\",\n            \"xxxx\");\n        return connection;\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return Connection.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}\n```\n\n#### 2.实例⼯⼚\n\n```xml\n<bean id=\"connFactory\" class=\"com.mk.learn.spring.ioc.module.ConnectionFactoryBean\"></bean>\n<bean id=\"conn\" factorybean=\"connFactory\" factorymethod=\"getConnection\"/>\n```\n\n#### 3.静态⼯⼚\n\n```xml\n<bean id=\"conn\" class=\"com.mk.learn.spring.ioc.module.ConnectionFactoryBean\"  factorymethod=\"getConnection\"/>\n```\n\n\n\n## 控制Spring⼯⼚创建对象的次数\n\n### 简单对象的创建次数\n\n```markdown\n<bean id=\"account\" scope=\"singleton|prototype\" class=\"xxxx.Account\"/>\n\tsigleton:只会创建⼀次简单对象 默认值\n\tprototype:每⼀次都会创建新的对象\n```\n\n### 复杂对象的创建次数\n\n```markdown\nFactoryBean{\n isSingleton(){\n \treturn true 只会创建⼀次\n \treturn false 每⼀次都会创建新的\n }\n}\n\t如没有isSingleton⽅法 还是通过scope属性 进⾏对象创建次数的控制\n```\n\n","tags":["spring"]},{"title":"springcloud-总结","url":"/2020/08/23/框架系列/springcloud/springcloud总结/","content":"\n\n\n# 基础选型\n\n## springcloud系统基础项目实战\n\n-   [springcloud项目搭建](./SpringCloud项目搭建.md)\n    - 所有项目地址：[点击此处](https://github.com/mk-passby/springcloud2020)\n- [springcloud_1.版本选型](./springcloud_1.版本选型.md)\n\n## 微服务编码与构建\n\n### 热部署\n\n- 为什么需要热部署，热部署到底是干什么的？\n  \n- springboot热部署就是当一个项目在运行过程中，如果有代码修改，项目会自动重启，部署好最新的修改代码，避免人为手动重启。\n  \n- ​\t怎么设置热部署\n\n  - 新增pom依赖\n\n    ```markdown\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n       <scope>runtime</scope>\n        <optional>true</optional>\n    </dependency>\n    ```\n\n  - 新增pom插件\n\n    ```markdown\n     \n    <build>\n      <plugins>\n        <plugin>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-maven-plugin</artifactId>\n          <configuration>\n            <fork>true</fork>\n            <addResources>true</addResources>\n          </configuration>\n        </plugin>\n      </plugins>\n    </build>\n    ```\n\n  - 开启自动build\n\n    ![](./springcloud总结/1.png)\n\n  - 设置应用运行时自动重启，快捷键ctrl+shift+alt+/\n\n    ![](./springcloud总结/2.png)\n\n\n\n### DependencyManagement\n\n在我们的分模块项目开发中通常会在父pom中看见DependencyManagement这个标签\n\n- 作用\n  - 能让所有子项目中引用一个依赖而不用显示的列出版本号\n- 注意\n  - DependencyManagement只是声明依赖，**不实现引入**，需要子项目显示声明所需要的依赖\n  - 如果子项目中声明的依赖没有知名version和scope，都是读取自父pom\n  - 如果子项目中指定了版本号，那么就用子项目中自己指定的版本\n\n\n\n# 服务注册与发现\n\n## Eureka基础知识\n\n### 服务治理\n\n![](./springcloud总结/3.bmp)\n\n### 服务注册与发现\n\n![](./springcloud总结/4.bmp)\n![](./springcloud总结/5.bmp)\n\n### Eureka两大组件\n![](./springcloud总结/6.bmp)\n\n### 单机Eureka构建步骤\n\n- EurekaServer\n  - yaml文件配置\n\n  ```yaml\n  server:\n    port: 7001\n  \n  eureka:\n    instance:\n      hostname: localhost  #eureka服务端的实例名字\n    client:\n      register-with-eureka: false    #表识不向注册中心注册自己\n      fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n       service-url:\n        defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/    #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n   \n  ```\n  - 主启动类加上@EnableEurekaServer\n\n  ```java\n  @EnableEurekaServer\n  @SpringBootApplication\n  public class EurekaMain7001 {\n      public static void main(String[] args) {\n          SpringApplication.run(EurekaMain7001.class,args);\n      }\n  }\n  ```\n\n  - pom\n\n  ```markdown\n   <dependencies>\n          <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server -->\n          <dependency>\n              <groupId>org.springframework.cloud</groupId>\n              <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n          </dependency>\n  </dependencies>\n  ```\n  \n    \n  \n    \n  \n- EurekaClient\n\n  - yaml\n\n    ```yaml\n    ![7](E:\\developProject\\hexo-aircloud-blog\\source\\_posts\\框架系列\\springcloud\\springcloud总结\\7.bmp)eureka:\n      client:\n        register-with-eureka: true\n        fetchRegistry: true\n        service-url:\n          defaultZone: http://localhost:7001/eureka\n    ```\n\n  - 主启动类@EnableEurekaClient\n\n    ```java\n    @EnableEurekaClient\n    @SpringBootApplication\n    public class PaymentMain8001 {\n        public static void main(String[] args) {\n            SpringApplication.run(PaymentMain8001.class,args);\n        }\n    }\n    ```\n    \n  - 导pom\n  \n      ```markdown\n       <dependencies>\n      <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server -->\n              <dependency>\n                  <groupId>org.springframework.cloud</groupId>\n                  <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n              </dependency>\n       </dependencies>\n      ```\n\n### Eureka集群\n\n#### 原理说明\n\n![](springcloud总结\\7.bmp)\n\n解决办法：搭建Eureka注册中心集群，实现负载均衡+故障容错\n\n#### 构建步骤\n\n- EurekaService(7001和7002作为eureka集群)\n\n  - 7001的yaml\n\n  ```yaml\n  server:\n    port: 7001\n  \n  eureka:\n    instance:\n      hostname: eureka7001.com    #eureka服务端的实例名字\n    client:\n      register-with-eureka: false    #表识不向注册中心注册自己\n      fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n      service-url:\n        defaultZone: http://eureka7002.com:7002/eureka/    #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n   \n  ```\n\n  - 7002的yaml\n\n  ```yaml\n  server:\n    port: 7002\n  \n  eureka:\n    instance:\n      hostname: eureka7002.com #eureka服务端的实例名字\n    client:\n      register-with-eureka: false    #表识不向注册中心注册自己\n      fetch-registry: false   #表示自己就是注册中心，职责是维护服务实例，并不需要去检索服务\n      service-url:\n        defaultZone: http://eureka7001.com:7001/eureka/     #设置与eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n   \n  ```\n\n  - 其他配置类似，此处省略\n\n- EurekaClient\n\n  - 注册到7001和7002上，修改yaml配置\n\n  ```yaml\n  service-url:\n    defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka  #集群版\n  ```\n\n  - 其他配置类似，省略\n\n\n\n### 服务发现Discovery\n\n- 启动类上加上@EnableDiscoveryClient\n\n- 注入DiscoveryClient\n\n  ```java\n  @Resource\n  private DiscoveryClient discoveryClient;\n  ```\n\n  \n\n### Eureka自我保护\n\n- 某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存\n- 属于CAP里面的AP分支\n  ![](springcloud总结\\8.bmp)\n  ![](springcloud总结\\9.bmp)\n  ![](springcloud总结\\10.bmp)\n\n- 禁用自我保护机制\n\n  - eureakeServer端\n\n    - 出厂默认，自我保护机制是开启的。默认配置如：eureka.server.enable-self-preservation = true，如下是关闭的配置\n\n    ```yaml\n    server:\n      enable-self-preservation: false\n      eviction-interval-timer-in-ms: 2000\n    ```\n\n  - eureakeClient端\n\n    - eureka.instance.lease-renewal-interval-in-seconds=30 客户端想法段发送心跳的时间间隔\n    - eureka.instance.lease-expiration-duration-in-seconds=90服务端的心跳超时时间\n  \n  ![](springcloud总结\\11.bmp)\n\n## zookeeper提供服务注册与发现\n\n### 构建步骤\n\n- zookeeer搭建不走此处省略，可参考dubbo文章中安装zookeeper教程，[点此处跳转](../../中间件/dubbo/DUBBO+ZOOKEEPER入门.md)\n\n- pom\n\n```markdown\n  <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-zookeeper-discovery -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n        </dependency>\n\n```\n\n- 由于zookeeper自身就是一个服务提供者，所以不需要新建zkServcer的module了\n- 消费者注册到zookeeper\n  - 可能出现重启失败，zk的jar包冲突导致，spring-cloud-starter-zookeeper-discovery中的jar包和自己使用的zk版本冲突\n  - 服务节点是临时节点~~还是持久节点~~\n\n```yaml\nserver:\n  port: 8004\n\nspring:\n  application:\n    name: cloud-provider-payment\n  cloud:\n    zookeeper:\n      connect-string: 192.168.11.128:2181,192.168.11.129:2181,192.168.11.130:2181\n      base-sleep-time-ms: 10000\n```\n\n- 所有设置参考springcloud2020中，cloud-provider-payment8004和cloud-consumerzk-order80模块\n\n\n\n## Consul服务注册与发现\n\n- 是什么\n\n  https://www.consul.io/intro/index.html\n![](springcloud总结\\12.bmp)\n\n\n\n- 能做什么\n  - 服务发现\n  - 健康检查\n  - KV存储\n  - 安全\n  - 加密服务通信\n  - 多数据中心\n\n![1598160434397](springcloud总结\\13.png)\n\n- 怎么用\n\n  - 下载安装，由于官网软件下载太慢，推荐使用springcloud2020中soft中，我已下载好的，直接安装\n\n  - 双击运行，或使用开发模式启动(\n\n    ```shell\n    consul agent -dev\n    ```\n\n  - 访问Consul的首页：http;//localhost:8500\n\n### 构建步骤\n\n  Consul的构建和zk类似\n\n- 改pom，引入jar包\n\n```markdown\n   <dependencies>\n        <!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-consul-discovery -->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n```\n\n\n\n- 同样自己就是一个注册中心应用，自己就是server\n- 服务注册者注册consul，改yaml\n\n```yaml\nserver:\n  port: 8006\n\n\nspring:\n  application:\n    name: consul-provider-payment\n  cloud:\n    consul:\n      host: localhost\n      port: 8500\n      discovery:\n        service-name: ${spring.application.name}\n \n```\n\n\n\n## 三个注册中心异同点\n\n### CAP理论\n![](springcloud总结\\14.bmp)\n![](springcloud总结\\15.bmp)\n\n### AP(Eureka)\n![](springcloud总结\\16.bmp)\n\n\n### CP(Zookeeper/Consul)\n![](springcloud总结\\17.bmp)\n\n\n\n# Ribbon负载均衡服务调用\n\n- 是什么\n\n![](springcloud总结\\18.bmp)\n\n- 官网：https://github.com/Netflix/ribbon/wiki/Getting-Started\n- 类别\n  - 集中式LB\n    - 在消费方和提供方之间使用独立的LB设施，将访问请求通过某种策略传给消费方(F5,NGNIX)\n  - 进程内LB\n    - 将LB逻辑集成到消费方，消费方从服务注册中心获取哪些地址可用，然后自己选择一个合适的服务器(Ribbon)\n- 架构说明\n![](springcloud总结\\19.bmp)\n![](springcloud总结\\20.bmp)\n- ribbon的使用\n\n  - ribbon的使用相对很简单，因为eureka已经集成了ribbon，所以不需要我们再导包\n  - 负载均衡+RestTemplate调用\n\n### 核心组件IRule\n\nIRule:根据特定算法从服务列表中选取一个要访问的服务\n\n| 实现类                                  | 作用                                                         |\n| --------------------------------------- | ------------------------------------------------------------ |\n| com.netflix.loadbalancer.RoundRobinRule | 轮询                                                         |\n| com.netflix.loadbalancer.RandomRule     | 随机                                                         |\n| com.netflix.loadbalancer.RetryRule      | 先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试 |\n| WeightedResponseTimeRule                | 对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择 |\n| BestAvailableRule                       | 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 |\n| AvailabilityFilteringRule               | 先过滤掉故障实例，再选择并发较小的实例                       |\n| ZoneAvoidanceRule                       | 默认规则，复合判断server所在区域的性能和server的可用性选择服务器 |\n\n\n\n### 自定义自己的轮询算法\n\n参见文章，[Ribbon详解](Ribbon详解.md)\n\n# OpenFeign服务接口调用\n\n- 是什么\n\n![](springcloud总结\\21.bmp)\n![](springcloud总结\\22.bmp)\n\n\n\n- 官网：https://github.com/spring-cloud/spring-cloud-openfeign\n- 有什么用\n\n![](springcloud总结\\23.bmp)\n\n## 使用步骤\n\n- 改pom\n\n```markdown\n <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-openfeign</artifactId>\n        </dependency>\n```\n\n- 主启动类@EnableFeignClients\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n/**\n * @program: springcloud2020\n * @description: feign启动类\n * @author: mk_passby\n * @create: 2020-08-02 15:55\n **/\n@SpringBootApplication\n@EnableFeignClients\npublic class OrderFeignMain80 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(OrderFeignMain80.class, args);\n    }\n}\n\n```\n\n- 业务类，在接口配置@FeignClient\n\n```java\n\npackage com.bli.guigu.springcloud.service;\n\nimport com.bli.guigu.springcloud.entities.CommonResult;\nimport com.bli.guigu.springcloud.entities.Payment;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 15:59\n **/\n@Component\n@FeignClient(value = \"CLOUD-PAYMENT-SERVICE\")\npublic interface PaymentFeignService {\n\n    @GetMapping(value = \"payment/get/{id}\")\n    public CommonResult<Payment> getPayment(@PathVariable(\"id\") Long id);\n\n    @GetMapping(value = \"/payment/feign/timeout\")\n    public String paymentFeignTimeout();\n\n\n}\n```\n\n## OpenFeign超时控制\n\nOpenFeign接口调用默认等待一秒钟，超过后报错\n\n- YML文件里需要开启OpenFeign客户端超时控制\n\n```yaml\nribbon:\n  ReadTimeout:  5000\n  ConnectTimeout: 5000\n```\n\n\n\n## OpenFeign日志打印功能\n\nFeign提供了日志打印功能，我们可以通过配置日志的级别来了解到Feign中http请求的细节。(接口调用情况的监控)\n\n- 配置一个日志级别的bean\n\n```java\npackage com.bli.guigu.springcloud.config;\n\nimport feign.Logger;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 16:23\n **/\n@Configuration\npublic class FeignConfig {\n\n    @Bean\n    Logger.Level feignLoggerLevel(){\n        return Logger.Level.FULL;\n    }\n}\n```\n\n- YML文件里需要开启日志的Feign客户端\n\n```yaml\nlogging:\n  level:\n    com.bli.guigu.springcloud.service.PaymentFeignService: debug\n```\n\n# Hystrix断路器\n\n- 是什么\n  ![](springcloud总结\\24.bmp)\n\n- 作用：\n  - 服务降级：服务器忙，请稍候再试，不让客户端等待并立刻返回一个友好提示，fallback\n  - 服务熔断：直接拒绝访问\n  - 接近实时的监控\n\n- 官网：https://github.com/Netflix/Hystrix/wiki/How-To-Use\n\n## 服务降级构建\n\n### pom引入jar包\n\n```markdown\n   <!--新增hystrix-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n        </dependency>\n```\n\n### 业务类开启服务降级\n\n- @HystrixCommand报异常后如何处理\n- 主启动类添加注解@EnableCircuitBreaker\n\n```java\npackage com.bli.guigu.springcloud.service;\n\nimport cn.hutool.core.util.IdUtil;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;\nimport com.netflix.hystrix.contrib.javanica.annotation.HystrixProperty;\nimport io.micrometer.core.instrument.Meter.Id;\nimport java.util.concurrent.TimeUnit;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n/**\n * @program: springcloud2020\n * @description: service\n * @author: mk_passby\n * @create: 2020-08-02 16:46\n **/\n@Service\npublic class PaymentService {\n\n    public String paymentInfo_OK(Integer id) {\n        return \"线程池：\" + Thread.currentThread().getName() + \",paymentInfo_OK ,id:\" + id\n            + \"----------\";\n    }\n\n    @HystrixCommand(fallbackMethod = \"paymentInfo_TimeOutHandler\", commandProperties = {\n        @HystrixProperty(name = \"execution.isolation.thread.timeoutInMilliseconds\", value = \"5000\")})\n    public String paymentInfo_TimeOut(Integer id) {\n        try {\n            TimeUnit.SECONDS.sleep(id);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return \"线程池：\" + Thread.currentThread().getName() + \"   paymentInfo_TimeOut,id：  \" + id\n            + \"\\t\" + \"呜呜呜\" + \" 耗时(秒)\" + id;\n\n    }\n\n    public String paymentInfo_TimeOutHandler(Integer id) {\n        return \"线程池：\" + Thread.currentThread().getName() + \"  Error or timeout,id：  \" + id\n            + \"\\t\" + \"QAQ\";\n    }\n\n\n    //服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),  //是否开启断路器\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),   //请求次数\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),  //时间范围\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"), //失败率达到多少后跳闸\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id){\n        if (id < 0){\n            throw new RuntimeException(\"*****id 不能负数\");\n        }\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功,流水号：\"+serialNumber;\n    }\n    public String paymentCircuitBreaker_fallback(@PathVariable(\"id\") Integer id){\n        return \"id 不能负数，请稍候再试,(┬＿┬)/~~     id: \" +id;\n    }\n}\n\n```\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.ServletRegistrationBean;\nimport org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;\nimport org.springframework.cloud.netflix.eureka.EnableEurekaClient;\nimport org.springframework.context.annotation.Bean;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 16:45\n **/\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker\npublic class PaymentHystrixMain8001 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(PaymentHystrixMain8001.class, args);\n    }\n\n    /**\n     * 此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑\n     * servletRegistrationBean因为springBoot的默认路径不是\"/hystrix.stream\"\n     * @return\n     */\n    @Bean\n    public ServletRegistrationBean getServlet(){\n        HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();\n        ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);\n        registrationBean.setLoadOnStartup(1);\n        registrationBean.addUrlMappings(\"/hystrix.stream\");\n        registrationBean.setName(\"HystrixMetricsStreamServlet\");\n        return registrationBean;\n    }\n}\n\n```\n\n### 服务调用方开启服务降级\n\n- yaml配置\n\n```yaml\nfeign:\n  hystrix:\n    enabled: true #如果处理自身的容错就开启。开启方式与生产端不一样\n```\n\n- 主启动开启@EnableHystrix\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.hystrix.EnableHystrix;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-02 17:25\n **/\n@SpringBootApplication\n@EnableFeignClients\n@EnableHystrix\npublic class OrderHystrixMain80 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(OrderHystrixMain80.class, args);\n    }\n\n}\n```\n\n- 业务类自己再设置兜底\n\n```java\n  @GetMapping(\"/consumer/payment/hystrix/timeout/{id}\")\n    @HystrixCommand(fallbackMethod = \"paymentTimeOutFallbackMethod\",\n        commandProperties = {\n            @HystrixProperty(\n                name = \"execution.isolation.thread.timeoutInMilliseconds\",\n                value = \"4000\") //1.5秒钟以内就是正常的业务逻辑\n        })\n    //@HystrixCommand\n    public String paymentInfo_TimeOut(@PathVariable(\"id\") Integer id) {\n        String result = paymentHystrixService.paymentInfo_TimeOut(id);\n        return result;\n    }\n  //兜底方法\n    public String paymentTimeOutFallbackMethod(@PathVariable(\"id\") Integer id) {\n        return \"我是消费者80，对付支付系统繁忙请10秒钟后再试或者自己运行出错请检查自己,(┬＿┬)\";\n    }\n\n```\n\n\n\n### 上述配置的问题\n\n每个方法配置一个兜底方法，过于膨胀\n\n- @DefaultProperties(defaultFallback = \"\")\n\n![](springcloud总结\\25.bmp)\n\n![](springcloud总结\\26.png)\n\n\n\n## 服务熔断\n- 是什么\n\n![](springcloud总结\\27.bmp)\n\n### 怎么配置\n```java\n //服务熔断\n    @HystrixCommand(fallbackMethod = \"paymentCircuitBreaker_fallback\",commandProperties = {\n        @HystrixProperty(name = \"circuitBreaker.enabled\",value = \"true\"),  //是否开启断路器\n        @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\",value = \"10\"),   //请求次数\n        @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\",value = \"10000\"),  //时间范围\n        @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\",value = \"60\"), //失败率达到多少后跳闸\n    })\n    public String paymentCircuitBreaker(@PathVariable(\"id\") Integer id){\n        if (id < 0){\n            throw new RuntimeException(\"*****id 不能负数\");\n        }\n        String serialNumber = IdUtil.simpleUUID();\n\n        return Thread.currentThread().getName()+\"\\t\"+\"调用成功,流水号：\"+serialNumber;\n    }\n\n```\n\n### 参数说明\n\n![](springcloud总结\\28.bmp)\n\n## 服务监控hystrixDashboard\n\n- 见springcloud2020下的cloud-consumer-hystrix-dashboard9001\n\n![](springcloud总结\\29.bmp)\n![](springcloud总结\\30.bmp)\n![](springcloud总结\\31.bmp)\n\n\n\n# Gateway新一代网关\n\n- 官网：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/\n- 是什么\n  - Spring Cloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架\n ![](springcloud总结\\32.bmp)\n ![](springcloud总结\\33.bmp)\n ![](springcloud总结\\34.bmp)\n- 作用\n  - 反向代理\n  - 鉴权\n  - 流控\n  - 熔断\n  - 日志监控\n\n## 微服务架构中的网关\n\n ![](springcloud总结\\35.bmp)\n\n## 为什么选用springcloud gateway\n\n- neflix不太靠谱，zuul2.0一直跳票,迟迟不发布\n- SpringCloud Gateway与Zuul的区别\n ![](springcloud总结\\36.bmp)\n\n## spingcloudgateway的特点\n ![](springcloud总结\\37.bmp)\n\n- Route路由\n  - 路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由\n- Predicate断言\n  - 参考的是java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与断言相匹配则进行路由\n- Filter(过滤)\n  - 指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。\n\n![](springcloud总结\\38.bmp)\n\n## 路由和断言配置方式\n\n### 在配置文件yaml中配置\n\n- pom\n\n```markdown\n   <dependencies>\n        <!--新增gateway-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-gateway</artifactId>\n        </dependency>\n```\n\n- 改yaml\n\n```yaml\nserver:\n  port: 9527\nspring:\n  application:\n    name: cloud-gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名\n          uri: http://localhost:8001   #匹配后提供服务的路由地址\n          predicates:\n            - Path=/payment/get/**   #断言,路径相匹配的进行路由\n\n        - id: payment_routh2\n          uri: http://localhost:8001\n          predicates:\n            - Path=/payment/lb/**   #断言,路径相匹配的进行路由\n            #- After=2020-03-08T10:59:34.102+08:00[Asia/Shanghai]\n            #- Cookie=username,zhangshuai #并且Cookie是username=zhangshuai才能访问\n            #- Header=X-Request-Id, \\d+ #请求头中要有X-Request-Id属性并且值为整数的正则表达式\n            #- Host=**.atguigu.com\n            #- Method=GET\n            #- Query=username, \\d+ #要有参数名称并且是正整数才能路由\n\n\neureka:\n  instance:\n    hostname: cloud-gateway-service\n  client:\n    service-url:\n      register-with-eureka: true\n      fetch-registry: true\n      defaultZone: http://eureka7001.com:7001/eureka\n```\n\n###  代码中注入RouteLocator的Bean\n\n- 配置类如下\n\n```java\npackage com.bli.guigu.springcloud.config;\n\nimport org.springframework.cloud.gateway.route.RouteLocator;\nimport org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n *\n * @program: springcloud2020\n * @description:文档路径：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/\n * @author: mk_passby\n * @create: 2020-08-03 23:01\n **/\n@Configuration\npublic class GatewayConfig {\n\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n        //http://news.baidu.com/guoji\n        return builder.routes()\n            .route(\"path_route_bliguigu\",\n                r -> r.path(\"/guonei\").uri(\"http://news.baidu.com/guonei\")).build();\n    }\n\n\n```\n\n## 使用网关做过滤\n\n### 在配置文件yaml中配置i \n\n- 这里就取一个springcloudGateway的官网的例子吧，Example 13. application.yml\n\n  ```yaml\n  spring:\n    cloud:\n      gateway:\n        routes:\n        - id: add_request_header_route\n          uri: https://example.org\n          filters:\n          - AddRequestHeader=X-Request-red, blue\n          - AddRequestParameter=red, blue\n  ```\n  - 注意这里的过滤是指可以修改传入或传出的HTTP请求响应。\n  - 如上 - AddRequestHeader=X-Request-red, blue表示给所有匹配的请求头中添加了 X-Request-red: blue\n  - AddRequestParameter=red, blue表示给所有匹配的请求添加查询字符串`red=blue`，比如我的请求是localhost/getUser，实际传过去的就是多传了一个red=blue的传参过去，类似get请求的localhost/getUser?red=blue\n\n### 代码中注入RouteLocator的Bean\n\n```java\n\npackage com.bli.guigu.springcloud.config;\n\nimport org.springframework.cloud.gateway.route.RouteLocator;\nimport org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @program: springcloud2020\n * @description:文档路径：https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.2.1.RELEASE/reference/html/\n * @author: mk_passby\n * @create: 2020-08-03 23:01\n **/\n@Configuration\npublic class GatewayConfig {\n\n    @Bean\n    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n        //http://news.baidu.com/guoji\n        return builder.routes()\n            .route(\"path_route_bliguigu\",\n                r -> r.path(\"/guonei\")\n                    .filters(f -> f.addRequestHeader(\"X-Request-red\", \"blue\"))\n                    .uri(\"http://news.baidu.com/guonei\")).build();\n    }\n}\n\n```\n\n## 自定义全局gatewayfilter方式\n\n\n\n- 官网描述如下\n\n```java\n6.1. Combined Global Filter and GatewayFilter Ordering\nWhen a request matches a route, the filtering web handler adds all instances of GlobalFilter and all route-specific instances of GatewayFilter to a filter chain. This combined filter chain is sorted by the org.springframework.core.Ordered interface, which you can set by implementing the getOrder() method.\n\nAs Spring Cloud Gateway distinguishes between “pre” and “post” phases for filter logic execution (see How it Works), the filter with the highest precedence is the first in the “pre”-phase and the last in the “post”-phase.\n\nThe following listing configures a filter chain:\n\nExample 56. ExampleConfiguration.java\n@Bean\npublic GlobalFilter customFilter() {\n    return new CustomGlobalFilter();\n}\n\npublic class CustomGlobalFilter implements GlobalFilter, Ordered {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        log.info(\"custom global filter\");\n        return chain.filter(exchange);\n    }\n\n    @Override\n    public int getOrder() {\n        return -1;\n    }\n}\n```\n\n- 实现接口GlobalFilter, Ordered\n- 注意，此处就是一个责任链的设计模式\n\n```java\n\npackage com.bli.guigu.springcloud.filter;\n\nimport java.time.ZonedDateTime;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.cloud.gateway.filter.GlobalFilter;\nimport org.springframework.core.Ordered;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n/**\n * @program: springcloud2020\n * @description:\n * @author: mk_passby\n * @create: 2020-08-04 21:55\n **/\n@Component\n@Slf4j\npublic class MyLogGateWayFilter implements GlobalFilter, Ordered {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        log.info(\"***********come in :\" + ZonedDateTime.now());\n        String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\");\n        if (StringUtils.isEmpty(uname)) {\n            log.info(\"用户名为null，非法用户\");\n            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);\n            return exchange.getResponse().setComplete();\n        }\n        return chain.filter(exchange);\n    }\n\n    @Override\n    public int getOrder() {\n        return 0;\n    }\n}\n\n```\n\n# SpringCloud config分布式配置中心\n\n- 解决分布式系统中配置散乱的不好维护的问题，统一由配置中心管理，所有的应用都从配置中心去获取参数设置\n\n- 官网https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.2.1.RELEASE/reference/html/\n\n- 作用\n\n  - 集中管理配置文件\n  - 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release\n  - 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n  - 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置\n  - 将配置信息以REST接口的形式暴露，post、curl访问刷新均可....\n\n- 配置文件修改后，需要运维人员发送Post请求刷新3355(curl -X POST \"http://localhost:3355/actuator/refresh\")，但是每次刷新的都是一个configClient，如果有一万台configClient，那运维不得疯？怎么处理呢？详见CommandBus的使用\n\n  \n\n### configServer的构建\n\n- pom\n\n```markdown\n  <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n      <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n```\n\n\n\n- 改yaml\n\n```yaml\nserver:\n  port: 3344\nspring:\n  application:\n    name: cloud-config-center\n  cloud:\n    config:\n      server:\n        git:\n          uri:  https://github.com/mk-passby/sprincloud-config.git #填写你自己的github路径\n          # 搜索路径\n          search-paths:\n            - springcloud-config\n      # 读取分支\n      label: master\neureka:\n  client:\n    service-url:\n      defaultZone:  http://localhost:7001/eureka\n\nrabbitmq:\n  host: localhost\n  port: 5672\n  username: guest\n  password: guest\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: 'bus-refresh'\n```\n\n- 启动类\n\n\n\n```java\npackage com.bli.guigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.config.server.EnableConfigServer;\n\n/**\n * @program: springcloud2020\n * @description: 配置中心3344\n * @author: mk_passby\n * @create: 2020-08-04 22:48\n **/\n@SpringBootApplication\n@EnableConfigServer\npublic class ConfigCenterMain3344 {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigCenterMain3344.class, args);\n    }\n}\n\n```\n\n\n\n### configClient的构建\n\n- pom\n\n```markdown\n <dependency>\n      <groupId>org.springframework.cloud</groupId>\n      <artifactId>spring-cloud-starter-config</artifactId>\n    </dependency>\n      <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n\n\n```\n\n- yarm\n\n```yaml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    config:\n      label: master #分支名称\n      name: config #配置文件名称\n      profile: dev #读取后缀名称，读取http://config-3344.com:3344/master/config-dev.yml\n      uri: http://localhost:3344 #配置中心地址\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka\n\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: '*'\n```\n\n- 启动类\n\n```java\npackage com.atguigu.springcloud;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class ConfigClientMain3355 {\n    public static void main(String[] args) {\n            SpringApplication.run( ConfigClientMain3355.class,args);\n        }\n}\n \n \n\n```\n\n\n\n\n\n- 业务类\n\n```java\npackage com.atguigu.springcloud.Controller;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RefreshScope\n@RestController//自动刷新\npublic class ConfigClientController {\n\n    @Value(\"${config.info}\")\n    private String configInfo;\n\n    @GetMapping(\"/configInfo\")\n    public String getConfigInfo(){\n        return configInfo;\n    }\n}\n```\n\n\n\n# SpringCloud Bus 消息总线\n\n- Spring Cloud Bus配合Spring Cloud Config使用可以实现配置的动态刷新\n![](./springcloud总结/39.bmp)\n- Bus支持两种消息代理：RabbitMQ和Kafka\n- SpringCloudBus可以管理和传播分布式系统之间的消息，可用于广播状态更新，事件推送等，也可以作为微服务之前的通讯通道\n- 为什么称为总线：<img src=\"./springcloud总结/40.bmp\"  />\n\n- 一次修改，广播通知，处处生效\n\n## 构建\n\n- pom\n\n```markdown\n<dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n</dependency>\n```\n\n- yaml\n\n```yaml\nserver:\n  port: 3355\n\nspring:\n  application:\n    name: config-client\n  cloud:\n    config:\n      label: master\n      name: config\n      profile: dev\n      uri: http://localhost:3344\n\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://eureka7001.com:7001/eureka\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: \"*\"\n \n```\n\n## 通知总结\n\n\n\n\n\n![](springcloud总结/41.bmp)\n![](springcloud总结/42.bmp)\n\n- 利用消息总线触发一个服务端ConfigServer的/bus/refresh端点,而刷新所有客户端的配置\n\n","tags":["springcloud"]},{"title":"springcloud项目搭建","url":"/2020/08/22/框架系列/springcloud/SpringCloud项目搭建/","content":"\n# SpringCloud:\n\n\n\n## 0,SpringCloud升级,部分组件停用:\n\n1,Eureka停用,可以使用zk作为服务注册中心\n\n2,服务调用,Ribbon准备停更,代替为LoadBalance\n\n3,Feign改为OpenFeign\n\n4,Hystrix停更,改为resilence4j\n\n​\t\t或者阿里巴巴的sentienl\n\n5.Zuul改为gateway\n\n6,服务配置Config改为  Nacos\n\n7,服务总线Bus改为Nacos\n\n\n\n\n\n# 环境搭建:\n\n\n\n## 1,创建父工程,pom依赖\n\n```java\n....\n```\n\n## 2,创建子模块,pay模块\n\n![](SpringCloud项目搭建\\sc的3.png)\n\n### 1,子模块名字:\n\n​\t\tcloud_pay_8001\n\n### 2,pom依赖\n\n### 3,创建application.yml\n\n```yml\nserver:\n\tport: 8001   \nspring:\n\tapplication:\n\t\tname: cloud-payment-service\n\tdatasource:\n    # 当前数据源操作类型\n    type: com.alibaba.druid.pool.DruidDataSource\n    # mysql驱动类\n    driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/db2019?useUnicode=true&characterEncoding=\n            UTF-8&useSSL=false&serverTimezone=GMT%2B8\t\t\t\t\t\t\t\t\n    username: root\n    password: root\nmybatis:\t\t\t\n    mapper-locations: classpath*:mapper/*.xml\n   \ttype-aliases-package: com.eiletxie.springcloud.entities\n   \t\t\t它一般对应我们的实体类所在的包，这个时候会自动取对应包中不包括包名的简单类名作为包括包名的别名。多个package之间可以用逗号或者分号等来进行分隔（value的值一定要是包的全）\n```\n\n### 4,主启动类    \n\n​\t\t....\n\n### 5,业务类\n\n#### 1,sql\n\n![](SpringCloud项目搭建\\sc的4.png)\n\n#### \t2,实体类\n\n![](SpringCloud项目搭建\\sc的5.png)\n\n#### 3,.entity类\n\n![](SpringCloud项目搭建\\sc的6.png)\n\n#### 4,dao层:\n\n![](SpringCloud项目搭建\\sc的7.png)\n\n#### 5,mapper配置文件类\n\n​\t\t\t\t**在resource下,创建mapper/PayMapper.xml**\n\n![](SpringCloud项目搭建\\sc的8.png)\n\n#### 6,写service和serviceImpl\n\n![](SpringCloud项目搭建\\sc的9.png)\n\n![sc的9](SpringCloud项目搭建\\sc的10.png)\n\n#### 7,controller\n\n![](SpringCloud项目搭建\\sc的11.png)\n\n![](SpringCloud项目搭建\\sc的12.png)\n\n\n\n\n\n\n\n## 3,热部署:\n\n![](SpringCloud项目搭建\\sc的13.png)\n\n![](SpringCloud项目搭建\\sc的14.png)\n\n.....\n\n.....\n\n....\n\n\n\n\n\n## 4,order模块\n\n![](SpringCloud项目搭建\\sc的3.png)\n\n### **1,pom**\t\t\n\n### **2,yml配置文件**\n\n![](SpringCloud项目搭建\\order模块1.png)\n\n### **3,主启动类**\n\n### **4.复制pay模块的实体类,entity类**\n\n### **5,写controller类**\n\n​\t\t因为这里是消费者类,主要是消费,那么就没有service和dao,需要调用pay模块的方法\n\n​\t\t并且这里还没有微服务的远程调用,那么如果要调用另外一个模块,则需要使用基本的api调用\n\n使用RestTemplate调用pay模块,\n\n​\t![](SpringCloud项目搭建\\order模块2.png)\n\n![](SpringCloud项目搭建\\order模块3.png)\n\n\n\n​\t将restTemplate注入到容器\n\n![](SpringCloud项目搭建\\order模块4.png)\n\n编写controller:\n\n![](SpringCloud项目搭建\\order模块5.png)\n\n\n\n## 5,重构,\n\n新建一个模块,将重复代码抽取到一个公共模块中\n\n### 1,创建commons模块\n\n### 2,抽取公共pom\n\n![](SpringCloud项目搭建\\commons模块.png)\n\n### 3,entity和实体类放入commons中\n\n![](SpringCloud项目搭建\\commons模块2.png)\n\n### 4,使用mavne,将commone模块打包(install),\n\n​\t\t其他模块引入commons\n\n\n\n\n\n\n\n# 2,服务注册与发现\n\n\n\n## 6,Eureka:\n\n前面我们没有服务注册中心,也可以服务间调用,为什么还要服务注册?\n\n当服务很多时,单靠代码手动管理是很麻烦的,需要一个公共组件,统一管理多服务,包括服务是否正常运行,等\n\nEureka用于**==服务注册==**,目前官网**已经停止更新**\n\n​\t![](SpringCloud项目搭建\\Eureka的1.png)\n\n\n\n![](SpringCloud项目搭建\\Eureka的2.png)\n\n![](SpringCloud项目搭建\\Eureka的3.png)\n\n\n\n ![](SpringCloud项目搭建\\Eureka的4.png)\n\n\n\n### **单机版eureka:**\n\n#### **1,创建项目cloud_eureka_server_7001**\n\n#### **2,引入pom依赖**\n\n​\t\teurka最新的依赖变了\n\n![](SpringCloud项目搭建\\Eureka的5.png)\n\n#### 3,配置文件:\n\n![](SpringCloud项目搭建\\Eureka的6.png)\n\n#### 4,主启动类\t\n\n![](SpringCloud项目搭建\\Eureka的7.png)\n\n#### **5,此时就可以启动当前项目了**\n\n#### **6,其他服务注册到eureka:**\n\n比如此时pay模块加入eureka:\n\n##### 1.主启动类上,加注解,表示当前是eureka客户端\n\n![](SpringCloud项目搭建\\Eureka的10.png)\n\n##### 2,修改pom,引入\n\n![](SpringCloud项目搭建\\Eureka的8.png)\n\n##### 3,修改配置文件:\n\n![](SpringCloud项目搭建\\Eureka的9.png)\n\n##### 4,pay模块重启,就可以注册到eureka中了\n\n\n\n\n\n**==order模块的注册是一样的==**\n\n\n\n\n\n### 集群版eureka:\n\n#### 集群原理:\n\n![](SpringCloud项目搭建\\Eureka的11.png)\n\n ```java\n1,就是pay模块启动时,注册自己,并且自身信息也放入eureka\n2.order模块,首先也注册自己,放入信息,当要调用pay时,先从eureka拿到pay的调用地址\n3.通过HttpClient调用\n \t并且还会缓存一份到本地,每30秒更新一次\n ```\n\n![](SpringCloud项目搭建\\Eureka的12.png)\n\n**集群构建原理:**\n\n​\t\t互相注册\n\n![](SpringCloud项目搭建\\Eureka的13.png)\n\n\n\n#### **构建新erueka项目**\n\n名字:cloud_eureka_server_7002\n\n##### 1,pom文件:\n\n​\t\t粘贴7001的即可\n\n##### 2,配置文件:\n\n​\t\t在写配置文件前,修改一下主机的hosts文件\n\n![](SpringCloud项目搭建\\Eureka的14.png)\n\n首先修改之前的7001的eureka项目,因为多个eureka需要互相注册\n\n![](SpringCloud项目搭建\\Eureka的15.png)\n\n然后修改7002\n\n​\t\t\t**7002也是一样的,只不过端口和地址改一下**\n\n##### 3,主启动类:\n\n​\t\t复制7001的即可\n\n##### 4,然后启动7001,7002即可\n\n*![](SpringCloud项目搭建\\Eureka的16.png)*\n\n\n\n\n\n#### 将pay,order模块注册到eureka集群中:\n\n##### 1,只需要修改配置文件即可:\n\n![](SpringCloud项目搭建\\Eureka的17.png)\n\n##### 2,两个模块都修改上面的都一样即可\n\n​\t\t\t然后启动两个模块\n\n​\t\t\t要先启动7001,7002,然后是pay模块8001,然后是order(80)\n\n\n\n### 3,将pay模块也配置为集群模式:\n\n#### 0,创建新模块,8002\n\n​\t名称: cloud_pay_8002\n\n#### 1,pom文件,复制8001的\n\n#### 2,pom文件复制8001的\n\n#### 3,配置文件复制8001的\n\n​\t\t端口修改一下,改为8002\n\n​\t\t服务名称不用改,用一样的\n\n#### 4.主启动类,复制8001的\n\n#### 5,mapper,service,controller都复制一份\n\n​\t\t然后就启动服务即可\n\n​\t\t此时访问order模块,发现并没有负载均衡到两个pay,模块中,而是只访问8001\n\n​\t\t虽然我们是使用RestTemplate访问的微服务,但是也可以负载均衡的\n\n​\t\t![](SpringCloud项目搭建\\Eureka的18.png)\n\n**注意这样还不可以,需要让RestTemplate开启负载均衡注解,还可以指定负载均衡算法,默认轮询**\n\n![](SpringCloud项目搭建\\Eureka的19.png)\n\n\n\n\n\n\n\n### 4,修改服务主机名和ip在eureka的web上显示\n\n比如修改pay模块\n\n#### 1,修改配置文件:\n\n![](SpringCloud项目搭建\\Eureka的20.png)\n\n\n\n\n\n### 5,eureka服务发现:\n\n![](SpringCloud项目搭建\\Eureka的21.png)\n\n以pay模块为例\n\n#### 1,首先添加一个注解,在controller中\n\n![](SpringCloud项目搭建\\Eureka的22.png)\n\n![](SpringCloud项目搭建\\Eureka的23.png)\n\n\n\n#### 2,在主启动类上添加一个注解\n\n![](SpringCloud项目搭建\\Eureka的24.png)\n\n**然后重启8001.访问/payment/discover**y\n\n\n\n\n\n### 6,Eureka自我保护:\n\n![](SpringCloud项目搭建\\Eureka的26.png)\n\n![](SpringCloud项目搭建\\Eureka的27.png)\n\n![](SpringCloud项目搭建\\Eureka的25.png)\n\n\n\n![](SpringCloud项目搭建\\Eureka的28.png)\n\n\n\n**eureka服务端配置:**\n\n![](SpringCloud项目搭建\\Eureka的29.png)\n\n![](SpringCloud项目搭建\\Eureka的30.png)\n\n​\t\t\t**设置接受心跳时间间隔**\n\n\n\n**客户端(比如pay模块):**\n\n![](SpringCloud项目搭建\\Eureka的31.png)\n\n\n\n\n\n**此时启动erueka和pay.此时如果直接关闭了pay,那么erueka会直接删除其注册信息**\n\n\n\n\n\n\n\n\n\n## 7,Zookeeper服务注册与发现:\n\n### 1,启动zk,到linux上\n\n\n\n### 2,创建新的pay模块,\n\n单独用于注册到zk中  \n\n名字 : cloud_pay_8003\n\n#### 1,pom依赖\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\zookeeper的3.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\zookeeper的1.png)\n\n#### 4,controller\n\n![](SpringCloud项目搭建\\zookeeper的2.png)\n\n#### 5,然后就可以启动\n\n**此时启动,会报错,因为jar包与我们的zk版本不匹配**\n\n解决:\n\t\t修改pom文件,改为与我们zk版本匹配的jar包\n\n![](SpringCloud项目搭建\\zookeeper的4.png)\n\n**此时8003就注册到zk中了**\n\n```java\n我们在zk上注册的node是临时节点,当我们的服务一定时间内没有发送心跳\n  \t那么zk就会`将这个服务的node删除了\n```\n\n\n\n**这里测试,就不写service与dao什么的了**\n\n\n\n\n\n\n\n\n\n### 3,创建order消费模块注册到zk\n\n#### 1,创建项目\n\n名字: cloud_order_zk_80\n\n#### 2,pom\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\zookeeper的5.png)\n\n#### 4主启动类:\n\n![](SpringCloud项目搭建\\zookeeper的1.png)\n\n#### 5,RestTemolate\n\n![注意,这里使用RestTemolate,要先注册它](SpringCloud项目搭建\\zookeeper的6.png)\n\n#### 6,controller\n\n![](SpringCloud项目搭建\\zookeeper的7.png)\n\n**然后启动即可注册到zk**\n\n#### 8,集群版zk注册:\n\n只需要修改配置文件:\n\n![](SpringCloud项目搭建\\zookeeper的5.png)\n\n这个connect-string指定多个zk地址即可\n\nconnect-string: 1.2.3.4,2.3.4.5\n\n#### \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 8,Consul:\n\n![](SpringCloud项目搭建\\consul的1.png)\n\n\n\n![](SpringCloud项目搭建\\consul的2.png)\n\n\n\n\n\n### 1,按照consul\n\n需要下载一个安装包\n\n![](SpringCloud项目搭建\\consul的3.png)\n\n启动是一个命令行界面,需要输入consul agen-dev启动\n\n\n\n### 2,创建新的pay模块,8006\n\n#### 1,项目名字\n\ncloud_consule_pay_8006\n\n#### 2,pom依赖\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\consul的4.png)\n\n#### 4,主启动类\n\n![](SpringCloud项目搭建\\consul的5.png)\n\n#### 5,controller\n\n![](SpringCloud项目搭建\\consul的6.png)\n\n#### 6,启动服务\n\n\n\n#### \n\n\n\n### 3,创建新order模块\n\ncloud-consul-order-80\n\n\n\n#### 1,pom文件\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\consul的7.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\consul的5.png)\n\n#### 4,RestTemplate注册\n\n配置类注册\n\n#### 5,controller\n\n![](SpringCloud项目搭建\\consul的8.png)\n\n#### 6,启动服务,测试\n\n\n\n\n\n\n\n## 9,三个注册中心的异同:\n\n![](SpringCloud项目搭建\\consul的9.png)\n\n![](SpringCloud项目搭建\\consul的10.png)\n\n![](SpringCloud项目搭建\\consul的11.png)\n\n\n\n\n\n\n\n# 3,服务调用\n\n\n\n## 10,Ribbon负载均衡:\n\n![](SpringCloud项目搭建\\Ribbon.png)\n\n**Ribbon目前也进入维护,基本上不准备更新了**\n\n![](SpringCloud项目搭建\\Ribbon的2.png)\n\n**进程内LB(本地负载均衡)**\n\n![](SpringCloud项目搭建\\Ribbon的5.png)\n\n\n\n\n\n**集中式LB(服务端负载均衡)**\n\n![](SpringCloud项目搭建\\Ribbon的4.png)\n\n\n\n\n\n\n\n**区别**\n\n![](SpringCloud项目搭建\\Ribbon的3.png)\n\n\n\n**Ribbon就是负载均衡+RestTemplate**\n\n![](SpringCloud项目搭建\\Ribbon的6.png)\n\n\n\n![](SpringCloud项目搭建\\Ribbon的7.png)\n\n\n\n![](SpringCloud项目搭建\\Ribbon的8.png)\n\n\n\n\n\n\n\n### 使用Ribbon:\n\n#### 1,默认我们使用eureka的新版本时,它默认集成了ribbon:\n\n![](SpringCloud项目搭建\\Ribbon的9.png)\n\n**==这个starter中集成了reibbon了==**\n\n\n\n#### 2,我们也可以手动引入ribbon\n\n**放到order模块中,因为只有order访问pay时需要负载均衡**\n\n![](SpringCloud项目搭建\\Ribbon的10.png)\n\n\n\n#### 3,RestTemplate类:\n\n![](SpringCloud项目搭建\\Ribbon的11.png)\n\n![](SpringCloud项目搭建\\Ribbon的12.png)\n\n```java\nRestTemplate的:\n\t\txxxForObject()方法,返回的是响应体中的数据\n    xxxForEntity()方法.返回的是entity对象,这个对象不仅仅包含响应体数据,还包含响应体信息(状态码等)\n```\n\n\n\n\n\n#### Ribbon常用负载均衡算法:\n\n**IRule接口,Riboon使用该接口,根据特定算法从所有服务中,选择一个服务,**\n\n**Rule接口有7个实现类,每个实现类代表一个负载均衡算法**\n\n![](SpringCloud项目搭建\\Ribbon的14.png)\n\n\n\n\n\n\n\n#### 使用Ribbon:\n\n**==这里使用eureka的那一套服务==**\n\n![](SpringCloud项目搭建\\Ribbon的15.png)\n\n**==也就是不能放在主启动类所在的包及子包下==**\n\n##### 1,修改order模块\n\n##### 2,额外创建一个包\n\n![](SpringCloud项目搭建\\Ribbon的16.png)\n\n##### 3,创建配置类,指定负载均衡算法\n\n![](SpringCloud项目搭建\\Ribbon的17.png)\n\n##### 4,在主启动类上加一个注解\n\n![](SpringCloud项目搭建\\Ribbon的18.png)\n\n**表示,访问CLOUD_pAYMENT_SERVICE的服务时,使用我们自定义的负载均衡算法**\n\n\n\n\n\n\n\n#### 自定义负载均衡算法:\n\n##### 1,ribbon的轮询算法原理\n\n![](SpringCloud项目搭建\\Ribbon的19.png)\n\n![](SpringCloud项目搭建\\Ribbon的21.png)\n\n\n\n##### 2,自定义负载均衡算法:\n\n**1,给**pay模块(8001,8002),的controller方法添加一个方法,返回当前节点端口\n\n![](SpringCloud项目搭建\\Ribbon的23.png)\n\n![](SpringCloud项目搭建\\Ribbon的22.png)\n\n**2,修改order模块**\n\n去掉@LoadBalanced\n\n![](SpringCloud项目搭建\\Ribbon的24.png)\n\n\n\n##### 3,自定义接口\n\n![](SpringCloud项目搭建\\Ribbon的29.png)\n\n​\t\t\t\t\t==具体的算法在实现类中实现==\n\n##### 4,接口实现类\n\n![](SpringCloud项目搭建\\Ribbon的25.png)\n\n![](SpringCloud项目搭建\\Ribbon的26.png)\n\n\n\n##### 5,修改controller:\n\n![](SpringCloud项目搭建\\Ribbon的27.png)\n\n![](SpringCloud项目搭建\\Ribbon的28.png)\n\n\n\n##### 6,启动服务,测试即可\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 11,OpenFeign\n\n![](SpringCloud项目搭建\\Feign的1.png)\n\n**是一个声明式的web客户端,只需要创建一个接口,添加注解即可完成微服务之间的调用**\n\n\n\n![](SpringCloud项目搭建\\Feign的2.png)\n\n==就是A要调用B,Feign就是在A中创建一个一模一样的B对外提供服务的的接口,我们调用这个接口,就可以服务到B==\n\n\n\n### **Feign与OpenFeign区别**\n\n![](SpringCloud项目搭建\\Feign的3.png)\n\n\n\n\n\n### 使用OpenFeign\n\n```java\n之前的服务间调用,我们使用的是ribbon+RestTemplate\n\t\t现在改为使用Feign\n```\n\n#### 1,新建一个order项目,用于feign测试\n\n名字cloud_order_feign-80\n\n#### 2,pom文件\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\Feign的4.png)\n\n#### 4,主启动类\n\n![](SpringCloud项目搭建\\Feign的5.png)\n\n#### 5,fegin需要调用的其他的服务的接口\n\n![](SpringCloud项目搭建\\Feign的6.png)\n\n#### 6,controller\n\n![](SpringCloud项目搭建\\Feign的7.png)\n\n#### 7测试:\n\n启动两个erueka(7001,7002)\n\n启动两个pay(8001,8002)\n\n启动当前的order模块\n\n\n\n**Feign默认使用ribbon实现负载均衡**\n\n\n\n\n\n### OpenFeign超时机制:\n\n==OpenFeign默认等待时间是1秒,超过1秒,直接报错==\n\n#### 1,设置超时时间,修改配置文件:\n\n**因为OpenFeign的底层是ribbon进行负载均衡,所以它的超时时间是由ribbon控制**\n\n![](SpringCloud项目搭建\\Feign的8.png)\n\n\n\n\n\n### OpenFeign日志:\n\n![](SpringCloud项目搭建\\Feign的9.png)\n\n\n\n**OpenFeign的日志级别有:**\n![](SpringCloud项目搭建\\Feign的10.png)\n\n\n\n\n\n#### \t1,使用OpenFeign的日志:\n\n**实现在配置类中添加OpenFeign的日志类**\n\n![](SpringCloud项目搭建\\Feign的11.png)\n\n#### 2,为指定类设置日志级别:\n\n![](SpringCloud项目搭建\\Feign的13.png)\n\n**配置文件中:**\n\n![](SpringCloud项目搭建\\Feign的12.png)\n\n\n\n#### \t3,启动服务即可\n\n\n\n# 4,服务降级:\n\n\n\n## 12,Hystrix服务降级\n\n![](SpringCloud项目搭建\\Hystrix的2.png)\n\n\n\n![](SpringCloud项目搭建\\Hystrix的3.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\Hystrix的4.png)\n\n\n\n\n\n\n\n### hystrix中的重要概念:\n\n#### 1,服务降级\n\n**比如当某个服务繁忙,不能让客户端的请求一直等待,应该立刻返回给客户端一个备选方案**\n\n\n\n#### 2,服务熔断\n\n**当某个服务出现问题,卡死了,不能让用户一直等待,需要关闭所有对此服务的访问**\n\n​\t\t\t**然后调用服务降级**\n\n\n\n#### 3,服务限流\n\n**限流,比如秒杀场景,不能访问用户瞬间都访问服务器,限制一次只可以有多少请求**\n\n\n\n\n\n### 使用hystrix,服务降级:\n\n#### 1,创建带降级机制的pay模块 :\n\n名字: cloud-hystrix-pay-8007\n\n##### 2,pom文件\n\n##### 3,配置文件\n\n![](SpringCloud项目搭建\\Hystrix的5.png)\n\n##### 4,主启动类\n\n![](SpringCloud项目搭建\\Hystrix的8.png)\n\n##### 5,service\n\n![](SpringCloud项目搭建\\Hystrix的6.png)\n\n##### 6controller\n\n![](SpringCloud项目搭建\\Hystrix的7.png)\n\n##### 7,先测试:\n\n```java\n此时使用压测工具,并发20000个请求,请求会延迟的那个方法,\n\t\t压测中,发现,另外一个方法并没有被压测,但是我们访问它时,却需要等待\n\t\t这就是因为被压测的方法它占用了服务器大部分资源,导致其他请求也变慢了\n```\n\n\n\n##### 8,先不加入hystrix,\n\n\n\n#### 2,创建带降级的order模块:\n\n##### 1,名字:  cloud-hystrix-order-80\n\n##### 2,pom\n\n##### 3,配置文件\n\n![](SpringCloud项目搭建\\Hystrix的9.png)\n\n##### 4,主启动类\n\n![](SpringCloud项目搭建\\Hystrix的11.png)\n\n##### 5,远程调用pay模块的接口:\n\n![](SpringCloud项目搭建\\Hystrix的12.png)\n\n##### 6,controller:\n\n![](SpringCloud项目搭建\\Hystrix的13.png)\n\n##### 7,测试\n\n​\t\t\t启动order模块,访问pay\n\n​\t\t\t再次压测2万并发,发现order访问也变慢了\n\n![](SpringCloud项目搭建\\Hystrix的14.png)\n\n\n\n**解决:**\n\n![](SpringCloud项目搭建\\Hystrix的15.png)\n\n##### ![](SpringCloud项目搭建\\Hystrix的16.png)\n\n\n\n\n\n\n\n#### 3,配置服务降级:\n\n##### 1,修改pay模块\n\n###### 1,为service的指定方法(会延迟的方法)添加@HystrixCommand注解\n\n![](SpringCloud项目搭建\\Hystrix的17.png)\n\n###### 2,主启动类上,添加激活hystrix的注解\n\n![](SpringCloud项目搭建\\Hystrix的18.png)\n\n###### 3,触发异常\n\n![](SpringCloud项目搭建\\Hystrix的19.png)\n\n![](SpringCloud项目搭建\\Hystrix的20.png)**可以看到,也触发了降级**\n\n\n\n##### 2,修改order模块,进行服务降级\n\n一般服务降级,都是放在客户端(order模块),\n\n![](SpringCloud项目搭建\\Hystrix的21.png)\n\n###### 1,修改配置文件:\n\n![](SpringCloud项目搭建\\Hystrix的22.png)\n\n###### **2,主启动类添加直接,启用hystrix:**\n\n![](SpringCloud项目搭建\\Hystrix的23.png)\n\n​\t\n\n###### 3,修改controller,添加降级方法什么的\n\n![](SpringCloud项目搭建\\Hystrix的24.png)\n\n\n\n###### 4,测试\n\n启动pay模块,order模块,\n\n**注意:,这里pay模块和order模块都开启了服务降级**\n\n​\t\t\t但是order这里,设置了1.5秒就降级,所以访问时,一定会降级\n\n \n\n##### 4,重构:\n\n**上面出现的问题:**\n\t\t1,降级方法与业务方法写在了一块,耦合度高\n\n​\t\t2.每个业务方法都写了一个降级方法,重复代码多\n\n##### **解决重复代码的问题**:\n\n**配置一个全局的降级方法,所有方法都可以走这个降级方法,至于某些特殊创建,再单独创建方法**\n\n###### 1,创建一个全局方法\n\n![](SpringCloud项目搭建\\Hystrix的26.png)\n\n###### 2,使用注解指定其为全局降级方法(默认降级方法)\n\n![](SpringCloud项目搭建\\Hystrix的27.png)\n\n![](SpringCloud项目搭建\\Hystrix的25.png)\n\n\n\n###### 3,业务方法使用默认降级方法:\n\n![](SpringCloud项目搭建\\Hystrix的28.png)\n\n\n\n###### 4,测试:\n\n![](SpringCloud项目搭建\\Hystrix的29.png)\n\n\n\n\n\n\n\n\n\n\n\n##### 解决代码耦合度的问题:\n\n修改order模块,这里开始,pay模块就不服务降级了,服务降级写在order模块即可\n\n###### 1,Payservice接口是远程调用pay模块的,我们这里创建一个类实现service接口,在实现类中统一处理异常\n\n![](SpringCloud项目搭建\\Hystrix的30.png)\n\n###### 2,修改配置文件:添加:\n\n![](SpringCloud项目搭建\\Hystrix的31.png)\n\n###### \t3,让PayService的实现类生效:\n\n![](SpringCloud项目搭建\\Hystrix的32.png)\n\n```java\n它的运行逻辑是:\n\t\t当请求过来,首先还是通过Feign远程调用pay模块对应的方法\n    但是如果pay模块报错,调用失败,那么就会调用PayMentFalbackService类的\n    当前同名的方法,作为降级方法\n```\n\n###### 4,启动测试\n\n启动order和pay正常访问--ok\n\n==此时将pay服务关闭,order再次访问==\n\n![](SpringCloud项目搭建\\Hystrix的33.png)\n\n可以看到,并没有报500错误,而是降级访问==实现类==的同名方法\n\n这样,即使服务器挂了,用户要不要一直等待,或者报错\n\n问题:\n\n​\t\t**这样虽然解决了代码耦合度问题,但是又出现了过多重复代码的问题,每个方法都有一个降级方法**\n\n\n\n\n\n\n\n### 使用服务熔断:\n\n![](SpringCloud项目搭建\\Hystrix的34.png)\n\n**比如并发达到1000,我们就拒绝其他用户访问,在有用户访问,就访问降级方法**\n\n\n\n![](SpringCloud项目搭建\\Hystrix的35.png)\n\n\n\n#### 1,修改前面的pay模块\n\n##### **1,修改Payservice接口,添加服务熔断相关的方法:**\n\n![](SpringCloud项目搭建\\Hystrix的37.png)\n\n这里属性整体意思是:\n\t\t\t10秒之内(窗口,会移动),如果并发==超过==10个,或者10个并发中,失败了6个,就开启熔断器\n\n![image-20200414152637247](SpringCloud项目搭建\\Hystrix的43.png)\n\n\n\nIdUtil是Hutool包下的类,这个Hutool就是整合了所有的常用方法,比如UUID,反射,IO流等工具方法什么的都整合了\n\n\n\n\n\n![](SpringCloud项目搭建\\Hystrix的36.png)\n\n```java\n断路器的打开和关闭,是按照一下5步决定的\n  \t1,并发此时是否达到我们指定的阈值\n  \t2,错误百分比,比如我们配置了60%,那么如果并发请求中,10次有6次是失败的,就开启断路器\n  \t3,上面的条件符合,断路器改变状态为open(开启)\n  \t4,这个服务的断路器开启,所有请求无法访问\n  \t5,在我们的时间窗口期,期间,尝试让一些请求通过(半开状态),如果请求还是失败,证明断路器还是开启状态,服务没有恢复\n  \t\t如果请求成功了,证明服务已经恢复,断路器状态变为close关闭状态\n```\n\n\n\n##### 2,修改controller\n\n添加一个测试方法;\n\n![](SpringCloud项目搭建\\Hystrix的39.png)\n\n\n\n##### 3,测试:\n\n启动pay,order模块\n\n==多次访问,并且错误率超过60%:==\n\n![](SpringCloud项目搭建\\Hystrix的40.png)\n\n此时服务熔断,此时即使访问正确的也会报错:\n\n![](SpringCloud项目搭建\\Hystrix的41.png)\n\n**但是,当过了几秒后,又恢复了**\n\n​\t\t\t\t因为在10秒窗口期内,它自己会尝试接收部分请求,发现服务可以正常调用,慢慢的当错误率低于60%,取消熔断\n\n\n\n\n\n\n\n\n\n\n\n### Hystrix所有可配置的属性:\n\n**全部在这个方法中记录,以成员变量的形式记录,**\n\n​\t\t以后需要什么属性,查看这个类即可\n\n![](SpringCloud项目搭建\\Hystrix的38.png)\n\n\n\n\n\n\n\n\n\n### 总结:\n\n![](SpringCloud项目搭建\\Hystrix的42.png)\n\n**==当断路器开启后:==**\n\n​\t![](SpringCloud项目搭建\\Hystrix的44.png)\n\n\n\n**==其他参数:==**\n\n![](SpringCloud项目搭建\\Hystrix的45.png)\n\n![](SpringCloud项目搭建\\Hystrix的46.png)\n\n![](SpringCloud项目搭建\\Hystrix的47.png)\n\n![](SpringCloud项目搭建\\Hystrix的48.png)\n\n![](SpringCloud项目搭建\\Hystrix的49.png)\n\n\n\n**熔断整体流程:**\n\n```java\n1请求进来,首先查询缓存,如果缓存有,直接返回\n  \t如果缓存没有,--->2\n2,查看断路器是否开启,如果开启的,Hystrix直接将请求转发到降级返回,然后返回\n  \t如果断路器是关闭的,\n\t\t\t\t判断线程池等资源是否已经满了,如果已经满了\n  \t\t\t\t\t也会走降级方法\n  \t\t\t如果资源没有满,判断我们使用的什么类型的Hystrix,决定调用构造方法还是run方法\n        然后处理请求\n        然后Hystrix将本次请求的结果信息汇报给断路器,因为断路器此时可能是开启的\n          \t\t\t(因为断路器开启也是可以接收请求的)\n        \t\t断路器收到信息,判断是否符合开启或关闭断路器的条件,\n\t\t\t\t如果本次请求处理失败,又会进入降级方法\n        如果处理成功,判断处理是否超时,如果超时了,也进入降级方法\n        最后,没有超时,则本次请求处理成功,将结果返回给controller\n         \n \n```\n\n\n\n\n\n\n\n### Hystrix服务监控:\n\n#### HystrixDashboard\n\n![](SpringCloud项目搭建\\Hystrix的51.png)\n\n#### 2,使用HystrixDashboard:\n\n##### 1,创建项目:\n\n名字: cloud_hystrixdashboard_9001\n\n##### 2,pom文件\n\n##### 3,配置文件\n\n![](SpringCloud项目搭建\\Hystrix的52.png)\n\n##### 4,主启动类\n\n![](SpringCloud项目搭建\\Hystrix的53.png)\n\n##### 5,修改所有pay模块(8001,8002,8003...)\n\n**他们都添加一个pom依赖:**\n\n![](SpringCloud项目搭建\\Hystrix的54.png)\n\n之前的pom文件中都添加过了,==这个是springboot的监控组件==\n\n##### 6,启动9001即可\n\n​\t\t\t访问: **localhost:9001/hystrix**\n\n##### 7,注意,此时仅仅是可以访问HystrixDashboard,并不代表已经监控了8001,8002\n\n​\t\t\t\t\t\t\t如果要监控,还需要配置:(8001为例)\n\n==8001的主启动类添加:==\n\n![](SpringCloud项目搭建\\Hystrix的55.png)\n\n**其他8002,8003都是一样的**\n\n##### 8,到此,可以启动服务\n\n启动7001,8001,9001\n\n**然后在web界面,指定9001要监控8001:**\n\n##### ![](SpringCloud项目搭建\\Hystrix的56.png)\n\n\n\n![](SpringCloud项目搭建\\Hystrix的57.png)\n\n![](SpringCloud项目搭建\\Hystrix的59.png)\n\n![](SpringCloud项目搭建\\Hystrix的58.png)\n\n![](SpringCloud项目搭建\\Hystrix的60.png)\n\n![](SpringCloud项目搭建\\Hystrix的61.png)\n\n![](SpringCloud项目搭建\\Hystrix的62.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 5,服务网关:\n\nzuul停更了,\n\n## 13,GateWay\n\n\n\n![](SpringCloud项目搭建\\gateway的1.png)\n\n![](SpringCloud项目搭建\\gateway的2.png)\n\n**gateway之所以性能号,因为底层使用WebFlux,而webFlux底层使用netty通信(NIO)**\n\n\n\n![](SpringCloud项目搭建\\gateway的3.png)\n\n\n\n### GateWay的特性:\n\n![](SpringCloud项目搭建\\gateway的4.png)\n\n\n\n### GateWay与zuul的区别:\n\n![](SpringCloud项目搭建\\gateway的5.png)\n\n\n\n### zuul1.x的模型:\n\n![](SpringCloud项目搭建\\gateway的6.png)\n\n![](SpringCloud项目搭建\\gateway的7.png)\n\n\n\n\n\n### 什么是webflux:\n\n**是一个非阻塞的web框架,类似springmvc这样的**\n\n![](SpringCloud项目搭建\\gateway的8.png)\n\n\n\n### GateWay的一些概念:\n\n#### 1,路由:\n\n![](SpringCloud项目搭建\\gateway的9.png)\n\n就是根据某些规则,将请求发送到指定服务上\n\n\n\n#### 2,断言:\n\n![](SpringCloud项目搭建\\gateway的10.png)\n\n就是判断,如果符合条件就是xxxx,反之yyyy\n\n\n\n#### 3,过滤:\n\n![](SpringCloud项目搭建\\gateway的11.png)\n\n​\t**路由前后,过滤请求**\n\n\n\n\n\n### GateWay的工作原理:\n\n![](SpringCloud项目搭建\\gateway的12.png)\n\n![](SpringCloud项目搭建\\gateway的13.png)\n\n\n\n\n\n### 使用GateWay:\n\n想要新建一个GateWay的项目\n\n名字: \tcloud_gateway_9527\n\n#### 1,pom\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\gateway的14.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\gateway的15.png)\n\n#### 4,针对pay模块,设置路由:\n\n![](SpringCloud项目搭建\\gateway的16.png)\n\n![](SpringCloud项目搭建\\gateway的18.png)\n\n**==修改GateWay模块(9527)的配置文件==:**\n\n![](SpringCloud项目搭建\\gateway的17.png)\n\n这里表示,\n\n​\t\t\t当访问localhost:9527/payment/get/1时,     \n\n​\t\t\t路由到localhost:8001/payment/get/1\n\n\n\n#### 5,开始测试\n\n**启动7001,8001,9527**\n\n```java\n如果启动GateWay报错\n  \t可能是GateWay模块引入了web和监控的starter依赖,需要移除\n```\n\n访问:\n\n​\t\tlocalhost:9527/payment/get/1\n\n![](SpringCloud项目搭建\\gateway的19.png)\n\n\n\n\n\n\n\n#### 6,GateWay的网关配置,\n\n​\t\t**GateWay的网关配置,除了支持配置文件,还支持硬编码方式**\n\n#### 7使用硬编码配置GateWay:\n\n##### 创建配置类:\n\n![](SpringCloud项目搭建\\gateway的20.png)\n\n#### 8,然后重启服务即可\n\n \n\n\n\n### 重构:\n\n上面的配置虽然首先了网关,但是是在配置文件中写死了要路由的地址\n\n现在需要修改,不指定地址,而是根据微服务名字进行路由,我们可以在注册中心获取某组微服务的地址\n\n需要:\n\n​\t\t1个eureka,2个pay模块\n\n#### 修改GateWay模块的配置文件:\n\n![](SpringCloud项目搭建\\gateway的21.png)\n\n\n\n#### 然后就可以启动微服务.测试\n\n\n\n\n\n\n\n### Pridicate断言:\n\n![](SpringCloud项目搭建\\gateway的24.png)\n\n**我们之前在配置文件中配置了断言:**\n\n![](SpringCloud项目搭建\\gateway的22.png)\n\n**这个断言表示,如果外部访问路径是指定路径,就路由到指定微服务上**\n\n可以看到,这里有一个Path,这个是断言的一种,==断言的类型==:\n\n![](SpringCloud项目搭建\\gateway的23.png)\n\n\n\n```java\nAfter:\n\t\t可以指定,只有在指定时间后,才可以路由到指定微服务\n```\n\n![](SpringCloud项目搭建\\gateway的26.png)\n\n​\t\t\t\t这里表示,只有在==2020年的2月21的15点51分37秒==之后,访问==才可以路由==\n\n​\t\t\t\t在此之前的访问,都会报404\n\n如何获取当前时区?**\n\n![](SpringCloud项目搭建\\gateway的25.png)\n\n\n\n```java\nbefore:\n\t\t与after类似,他说在指定时间之前的才可以访问\nbetween:\n\t\t需要指定两个时间,在他们之间的时间才可以访问\n```\n\n![](SpringCloud项目搭建\\gateway的27.png)\n\n\n\n\n\n```java\ncookie:\n\t\t只有包含某些指定cookie(key,value),的请求才可以路由\n```\n\n![](SpringCloud项目搭建\\gateway的28.png)\n\n![](SpringCloud项目搭建\\gateway的29.png)\n\n\n\n```java\nHeader:\n\t\t只有包含指定请求头的请求,才可以路由\n```\n\n![](SpringCloud项目搭建\\gateway的31.png)\n\n![](SpringCloud项目搭建\\gateway的32.png)\n\n测试:\n![](SpringCloud项目搭建\\gateway的33.png)\n\n\n\n\n\n\n\n```java\nhost:\n\t\t只有指定主机的才可以访问,\n\t\t比如我们当前的网站的域名是www.aa.com\n    那么这里就可以设置,只有用户是www.aa.com的请求,才进行路由\n```\n\n![](SpringCloud项目搭建\\gateway的34.png)\n\n![gateway的34](SpringCloud项目搭建\\gateway的35.png)\n\n![](SpringCloud项目搭建\\gateway的36.png)\n\n![](SpringCloud项目搭建\\gateway的37.png)\n\n可以看到,如果带了域名访问,就可以,但是直接访问ip地址.就报错了\n\n\n\n\n\n\n\n```java\nmethod:\n\t\t只有指定请求才可以路由,比如get请求...\n```\n\n![](SpringCloud项目搭建\\gateway的38.png)\n\n```java\npath:\n\t\t只有访问指定路径,才进行路由\n     比如访问,/abc才路由\n```\n\n![](SpringCloud项目搭建\\gateway的39.png)\n\n\n\n```java\nQuery:\n\t\t必须带有请求参数才可以访问\n```\n\n![](SpringCloud项目搭建\\gateway的40.png)\n\n\n\n\n\n\n\n### Filter过滤器:\n\n![](SpringCloud项目搭建\\gateway的41.png)\n\n\n\n#### 生命周期:\n\n**在请求进入路由之前,和处理请求完成,再次到达路由之前**\n\n\n\n#### 种类:\n\n![](SpringCloud项目搭建\\gateway的42.png)\n\nGateWayFilter,单一的过滤器\n\n**与断言类似,比如闲置,请求头,只有特定的请求头才放行,反之就过滤**:\n\n![](SpringCloud项目搭建\\gateway的43.png)\n\nGlobalFilter,全局过滤器:\n\n\n\n\n\n#### **自定义过滤器:**\n\n实现两个接口\n\n![](SpringCloud项目搭建\\gateway的44.png)\n\n​\t**然后启动服务,即可,因为过滤器通过@COmponet已经加入到容器了**\n\n![](SpringCloud项目搭建\\gateway的46.png)\n\n![](SpringCloud项目搭建\\gateway的45.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 6,服务配置:\n\n## Spring Config分布式配置中心:\n\n==微服务面临的问题==\n\n```java\n可以看到,每个微服务都需要一个配置文件,并且,如果有几个微服务都需要连接数据库\n\t\t那么就需要配4次数据库相关配置,并且当数据库发生改动,那么需要同时修改4个微服务的配置文件才可以\n```\n\n所以有了springconfig配置中心\n\n![](SpringCloud项目搭建\\springconfig的1.png)\n\n![](SpringCloud项目搭建\\springconfig的2.png)\n\n![](SpringCloud项目搭建\\springconfig的3.png)\n\n![](SpringCloud项目搭建\\springconfig的4.png)\n\n\n\n\n\n### 使用配置中心:\n\n#### 0,使用github作为配置中心的仓库:\n\n**初始化git环境:**\n\n![](SpringCloud项目搭建\\springconfig的5.png)\n\n\n\n#### 1,新建config模块:\n\n名字:   cloud-config-3344\n\n#### 2,pom\n\n#### 3,配置文件\n\n![](SpringCloud项目搭建\\springconfig的6.png)\n\n#### 4,主启动类\n\n![](SpringCloud项目搭建\\springconfig的7.png)\n\n#### 5,修改hosts:\n\n![](SpringCloud项目搭建\\springconfig的8.png)\n\n#### 6,配置完成\n\n测试,3344是否可以从github上获取配置\n\n启动3344\t(要先启动eureka)\n\n![](SpringCloud项目搭建\\springconfig的9.png)\n\n它实际上就是,读取到配置文件中的GitHub的地址,然后拼接上/master/config-dev.yml\n\n#### 7,读取配置文件的规则:\n\n![](SpringCloud项目搭建\\springconfig的10.png)\n\n\n\n==2,==\n\n![](SpringCloud项目搭建\\springconfig的11.png)\n\n**这里默认会读取master分支,因为我们配置文件中配置了**\n\n![](SpringCloud项目搭建\\springconfig的12.png)\n\n==3==\n\n![](SpringCloud项目搭建\\springconfig的13.png)\n\n注意,这个方式读取到的配置是==json格式==的\n\n**所有规则:**\n\n![](SpringCloud项目搭建\\springconfig的14.png)\n\n\n\n### 2,创建配置中心客户端:\n\n#### 1,创建config客户端项目\n\n名字: \tcloud-config-client-3355\n\n#### 2,pom\n\n#### 3,配置文件\n\n注意这个配置文件就不是application.yml\n\n​\t\t\t而是bootstrap.yml\n\n这个配置文件的作用是,先到配置中心加载配置,然后加载到application.yml中\n\n![](SpringCloud项目搭建\\springconfig的15.png)\n\n![](SpringCloud项目搭建\\springconfig的16.png)\n\n\n\n#### 4,主启动类:\n\n![](SpringCloud项目搭建\\springconfig的17.png)\n\n#### 5,controller类\n\n就是上面提到的,以rest风格将配置对外暴露\n\n![](SpringCloud项目搭建\\springconfig的18.png)\n\n![](SpringCloud项目搭建\\springconfig的19.png)\n\n**如果客户端运行正常,就会读取到github上配置文件的,config.info下的配置**\n\n#### 6,测试:\n\n启动3344,3355\n\n​\t访问3355的  /configInfo\n\n![](SpringCloud项目搭建\\springconfig的21.png)\n\n\n\n\n\n#### 7,问题::\n\n```java\n上面3355确实获取到了配置文件,但是如果此时配置文件修改了,3355是获取不到的\n\t\t3344可以实时获取到最新配置文件,但是3355却获取不到\n  \t除非重启服务\n```\n\n#### **8,实现动态刷新:**\n\n##### 1,修改3355,添加一个pom依赖:\n\n![](SpringCloud项目搭建\\springconfig的22.png)\n\n##### 2,修改配置文件,添加一个配置:\n\n![](SpringCloud项目搭建\\springconfig的23.png)\n\n##### 3,修改controller:\n\n![](SpringCloud项目搭建\\springconfig的24.png)\n\n\n\n##### 4,此时重启服务\n\n**此时3355还不可以动态获取**\n\n因为此时,还需要==外部==发送post请求通知3355\n\n![](SpringCloud项目搭建\\springconfig的25.png)\n\n**此时在刷新3355,发现可以获取到最新的配置文件了,这就实现了动态获取配置文件,因为3355并没有重启**\n\n\n\n具体流程就是:\n\n​\t\t\t我们启动好服务后\n\n​\t\t\t运维人员,修改了配置文件,然后发送一个post请求通知3355\n\n​\t\t\t3355就可以获取最新配置文件\n\n\n\n\n\n**问题:**\n\n​\t\t如果有多个客户端怎么办(3355,3356,3357.....)\n\n​\t\t\t\t\t\t虽然可以使用shell脚本,循环刷新\n\n​\t\t但是,可不可以使用广播,一次通知??\n\n​\t\t\t\t\t这些springconfig做不到,需要使用springcloud Bus消息总线\n\n\n\n\n\n\n\n# 消息总线:\n\n## SpringCloud Bus:\n\n![](/SpringCloud项目搭建/springconfig的26.png)\n\n\n\n\n\n\n\n![](SpringCloud项目搭建\\springconfig的27.png)\n\n![](SpringCloud项目搭建\\springconfig的31.png)\n\n注意,这里年张SpringCloud项目搭建,就代表两种广播方式\n\n​\t\t\t图1:\t\t**它是Bus直接通知给其中一个客户端,由这个客户端开始蔓延,传播给其他所有客户端**\n\n​\t\t\t图2:\t\t它**是通知给配置中心的服务端,有服务端广播给所有客户端**\n\n\n\n\n\n**为什么被称为总线?**\n\n![](SpringCloud项目搭建\\springconfig的28.png)\n\n```java\n就是通过消息队列达到广播的效果\n  \t\t我们要广播每个消息时,主要放到某个topic中,所有监听的节点都可以获取到\n```\n\n\n\n\n\n### 使用Bus:\n\n#### 1,配置rabbitmq环境:\n\n![](SpringCloud项目搭建\\springconfig的29.png)\n\n\n\n#### **2,之前只有一个配置中心客户端,这里在创建一个**\n\n​\t\t==**复制3355即可,创建为3366**==\n\n![](SpringCloud项目搭建\\springconfig的30.png)\n\n全部复制3355的即可\n\n\n\n#### 2,使用Bus实现全局广播\n\n**Bus广播有两种方式:**\n\n​\t\t==就是上面两个SpringCloud项目搭建的两种方式==\n\n![](SpringCloud项目搭建\\springconfig的32.png)\n\n**这两种方式,第二种跟合适,因为:**\n\n​\t\t\t==第一种的缺点:==\n\n![](SpringCloud项目搭建\\springconfig的33.png)\n\n\n\n\n\n#### **配置第二种方式:**\n\n##### **1,配置3344(配置中心服务端):**\n\n###### 1,修改配置文件:\n\n![](SpringCloud项目搭建\\Bus的1.png)\n\n###### 2,添加pom\n\n**springboot的监控组件,和消息总线**\n\n![](SpringCloud项目搭建\\Bus的3.png)\n\n![](SpringCloud项目搭建\\Bus的2.png)\n\n\n\n##### 2,修改3355(配置中心的客户端)\n\n###### 1,pom:\n\n![](SpringCloud项目搭建\\Bus的3.png)\n\n![Bus的2](SpringCloud项目搭建\\Bus的2.png)\n\n\n\n###### 2,配置文件:\n\n==注意配置文件的名字,要改为bootstrap.yml==\n\n![](SpringCloud项目搭建\\Bus的5.png)\n\n![image-20200415102708661](SpringCloud项目搭建\\Bus的4)\n\n\n\n\n\n##### 3,修改3366(也是配置中心的客户端)\n\n​\t\t\t修改与3355是一模一样的\n\n\n\n\n\n\n\n##### 4,测试\n\n启动7001,3344,3355,3366\n\n此时修改GitHub上的配置文件\n\n==此时只需要刷新3344,即可让3355,3366动态获取最新的配置文件==\n\n![](SpringCloud项目搭建\\Bus的6.png)\n\n\n\n其原理就是:\n\n![](SpringCloud项目搭建\\Bus的7.png)\n\n**所有客户端都监听了一个rabbitMq的topic,我们将信息放入这个topic,所有客户端都可以送到,从而实时更新**\n\n\n\n\n\n\n\n\n\n#### 配置定点通知\n\n​\t\t就是只通知部分服务,比如只通知3355,不通知3366\n\n![](SpringCloud项目搭建\\Bus的8.png)\n\n![Bus的8](SpringCloud项目搭建\\Bus的9.png)\n\n\n\n**只通知3355**\n\n![](SpringCloud项目搭建\\Bus的11.png)\n\n​\t![](SpringCloud项目搭建\\Bus的12.png)\n\n**可以看到,实际上就是通过==微服务的名称+端口号==进行指定**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 8,消息驱动:\n\n## Spring Cloud Stream:\n\n```java\n现在一个很项目可能分为三部分:\n\t\t\t前端--->后端---->大数据\n\t\t\t而后端开发使用消息中间件,可能会使用RabbitMq\n\t\t\t而大数据开发,一般都是使用Kafka,\n\t\t\t那么一个项目中有多个消息中间件,对于程序员,因为人员都不友好\n```\n\n而Spring Cloud Stream就类似jpa,屏蔽底层消息中间件的差异,程序员主要操作Spring Cloud Stream即可\n\n​\t\t\t不需要管底层是kafka还是rabbitMq\n\n![](SpringCloud项目搭建\\SpringCloudStream的1.png)\n\n### ==什么是Spring Cloud Stream==\n\n![](SpringCloud项目搭建\\SpringCloudStream的2.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\SpringCloudStream的3.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的4.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的5.png)\n\n\n\n\n\n### ==**Spring Cloud Stream是怎么屏蔽底层差异的?**==\n\n![](SpringCloud项目搭建\\SpringCloudStream的6.png)\n\n\n\n\n\n**绑定器:**\n\n![](SpringCloud项目搭建\\SpringCloudStream的7.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的8.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的9.png)\n\n\n\n\n\n### **Spring Cloud Streamd 通信模式:**\n\n![](SpringCloud项目搭建\\SpringCloudStream的10.png)![](SpringCloud项目搭建\\SpringCloudStream的11.png)\n\n\n\n\n\n### Spring Cloud Stream的业务流程:\n\n![](SpringCloud项目搭建\\SpringCloudStream的12.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的14.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的13.png)\n\n```java\n类似flume中的channel,source,sink  估计是借鉴(抄袭)的\n  \tsource用于获取数据(要发送到mq的数据)\n  \tchannel类似SpringCloudStream中的中间件,用于存放source接收到的数据,或者是存放binder拉取的数据\t\n```\n\n\n\n\n\n\n\n### 常用注解和api:\n\n![](SpringCloud项目搭建\\SpringCloudStream的15.png)\n\n\n\n\n\n### 使用SpringCloudStream:\n\n需要创建三个项目,一个生产者,两个消费者\n\n![](SpringCloud项目搭建\\SpringCloudStream的16.png)\n\n### 1,创建生产者\n\n#### 1,pom\n\n#### 2,配置文件\n\n![image-20200415114816133](SpringCloud项目搭建\\SpringCloudStream的17)\n\n![](SpringCloud项目搭建\\SpringCloudStream的18.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\SpringCloudStream的19.png)\n\n#### 4,service和实现类\n\nservice定义发送消息\n\n![](SpringCloud项目搭建\\SpringCloudStream的20.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的21.png)\n\n**这里,就会调用send方法,将消息发送给channel,**\n\n​\t\t\t\t**然后channel将消费发送给binder,然后发送到rabbitmq中**\n\n#### 5,controller\n\n![](SpringCloud项目搭建\\SpringCloudStream的22.png)\n\n#### 6,可以测试\n\n**启动rabbitmq**\n\n**启动7001,8801**\n\n​\t\t确定8801后,会在rabbitmq中创建一个Exchange,就是我们配置文件中配置的exchange\n\n**访问8801的/sendMessage**\n\n\n\n\n\n\n\n### 创建消费者:\n\n#### 1,pom文件\n\n#### 2,配置文件\n\n==**这里排版一点问题**==\n\n**==input==就表示,当前服务是一个消费者,需要消费消息,下面就是指定消费哪个Exchange中的消息**\n\n![](SpringCloud项目搭建\\SpringCloudStream的23.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的24.png)\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\SpringCloudStream的25.png)\n\n#### 4,业务类(消费数据)\n\n![](SpringCloud项目搭建\\SpringCloudStream的26.png)\n\n**生产者发送消息时,使用send方法发送,send方法发送的是一个个Message,里面封装了数据**\n\n#### 5,测试:\n\n启动7001.8801.8802\n\n**此时使用生产者生产消息**\n\n![](SpringCloud项目搭建\\SpringCloudStream的27.png)\n\n==可以看到,消费者已经接收到消息了==\n\n\n\n\n\n### 创建消费者2\n\n创建8803,\n\n==与8802创建一模一样,就不写了==\n\n**创建8803主要是为了演示重复消费等问题**\n\n...\n\n....\n\n...\n\n\n\n\n\n### ==重复消费问题:==\n\n此时启动7001.8801.8802.8803\n\n此时生产者生产一条消息\n\n但是此时查询消费者,发现8802,8803==都消费到了同一条数据==\n\n![](SpringCloud项目搭建\\SpringCloudStream的28.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的29.png)\n\n#### 1,自定义分组\n\n**修改8802,8803的配置文件**\n\n![](SpringCloud项目搭建\\SpringCloudStream的30.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的31 - 副本.png)\n\n**现在将8802,8803都分到了A组**\n\n然后去重启02,03\n\n**然后此时生产者生产两条消息**\n\n![](SpringCloud项目搭建\\SpringCloudStream的33.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的34.png)\n\n![](SpringCloud项目搭建\\SpringCloudStream的35.png)\n\n**可以看到,每人只消费了一条消息,并且没有重复消费**\n\n\n\n\n\n\n\n### 持久化问题:\n\n就是当服务挂了,怎么消费没有消费的数据??\n\n\n\n这里,先将8802移除A组,\n\n​\t\t然后将02,03服务关闭\n\n此时生产者开启,发送3条消息\n\n​\t\t此时重启02,03\n\n​\t\t可以看到,当02退出A组后,它就获取不到在它宕机的时间段内的数据\n\n​\t\t但是03重启后,直接获取到了宕机期间它没有消费的数据,并且消费了\n\n总结:\n\t\t也就是,当我们没有配置分组时,会出现消息漏消费的问题\n\n​\t\t而配置分组后,我们可以自动获取未消费的数据\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 9,链路追踪:\n\n## Spring Cloud Sleuth\n\n**sleuth要解决的问题:**\n\n![](SpringCloud项目搭建\\sleuth的1.png)\n\n**而来sleuth就是用于追踪每个请求的整体链路**\n\n![](SpringCloud项目搭建\\sleuth的2.png)\n\n\n\n### 使用sleuth:\n\n#### 1,安装zipkin:\n\n![](SpringCloud项目搭建\\sleuth的3.png)\n\n**运行jar包**\n\n​\t\t\tjava -jar xxxx.jar\n\n**然后就可以访问web界面,  默认zipkin监听的端口是9411**\n\n​\t\t\tlocalhost:9411/zipkin/\n\n![](SpringCloud项目搭建\\sleuth的4.png)\n\n\n\n**一条链路完整SpringCloud项目搭建:**\n\n![](SpringCloud项目搭建\\sleuth的5.png)\n\n**精简版:**\n\n![](SpringCloud项目搭建\\sleuth的6.png)\n\n**可以看到,类似链表的形式**\n\n\n\n\n\n\n\n#### 2,使用sleuth:\n\n不需要额外创建项目,使用之前的8001和order的80即可\n\n\n\n##### 1,修改8001\n\n**引入pom:**\n\n![](SpringCloud项目搭建\\sleuth的7.png)\n\n这个包虽然叫zipkin但是,里面包含了zpikin与sleuth\n\n**修改配置文件:**\n\n![](SpringCloud项目搭建\\sleuth的8.png)\n\n\n\n##### 2,修改80\n\n**添加pom**\n\n与上面是一样的\n\n\n\n**添加配置**:\n\n与上面也是一样的\n\n\n\n\n\n\n\n##### 3,测试:\n\n启动7001.8001,80,9411\n\n![](SpringCloud项目搭建\\sleuth的9.png)\n\n\n\n\n\n\n\n\n\n\n\n# 10,Spring CloudAlibaba:\n\n**之所以有Spring CloudAlibaba,是因为Spring Cloud Netflix项目进入维护模式**\n\n​\t\t**也就是,就不是不更新了,不会开发新组件了**\n\n​\t\t**所以,某些组件都有代替版了,比如Ribbon由Loadbalancer代替,等等**\n\n==支持的功能==\n\n![](SpringCloud项目搭建\\Alibaba的1.png)\n\n几乎可以将之前的Spring Cloud代替\n\n\n\n\n\n\n\n==具体组件==:\n![](SpringCloud项目搭建\\Alibaba的2.png)\n\n\n\n\n\n\n\n\n\n\n\n## Nacos:\n\n**服务注册和配置中心的组合**\n\n​\t\t\tNacos=erueka+config+bus\n\n\n\n\n\n### 安装Nacos:\n\n需要java8  和 Mavne\n\n**1,到github上下载安装包**\n\n​\t\t解压安装包\n\n**2,启动Nacos**\n\n​\t\t在bin下,进入cod\n\n​\t\t./startup.cmd\n\n**3,访问Nacos**\n\n​\t\tNacos默认监听8848\n\n​\t\tlocalhost:8848/nacos\n\n​\t\t账号密码:默认都是nacos\n\n\n\n\n\n### 使用Nacos:\n\n新建pay模块\n\n​\t\t**现在不需要额外的服务注册模块了,Nacos单独启动了**\n\n名字: cloudalibaba-pay-9001\n\n#### 1,pom\n\n父项目管理alibaba的依赖:\n\n![](SpringCloud项目搭建\\Alibaba的4.png)\n\n![](SpringCloud项目搭建\\Alibaba的3.png)\n\n==9001的pom==:\n\n​\t\t\t另外一个文件.....\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\Alibaba的5.png)\n\n#### 3,启动类\n\n![](SpringCloud项目搭建\\Alibaba的6.png)\n\n#### 4,controller:\n\n![](SpringCloud项目搭建\\Alibaba的7.png)\n\n#### 5,测试\n\n启动9001\n\n然后查看Nacos的web界面,可以看到9001已经注册成功\n\n\n\n### \n\n\n\n\n\n### 创建其他Pay模块\n\n​\t\t额外在创建9002,9003\n\n​\t\t直接复制上面的即可\n\n### 创建order模块\n\n名字:  cloudalibaba-order-83\n\n#### 1,pom\n\n**为什么Nacos支持负载均衡?**\n\n​\t\t\t\tNacos直接集成了Ribon,所以有负载均衡\n\n#### 2,配置文件\n\n![](SpringCloud项目搭建\\Alibaba的8.png)\n\n**这个server-url的作用是,我们在controller,需要使用RestTempalte远程调用9001,**\n\n​\t\t**这里是指定9001的地址**\n\n\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\Alibaba的9.png)\n\n#### 4,编写配置类\n\n​\t==因为Naocs要使用Ribbon进行负载均衡,那么就需要使用RestTemplate==\n\n![](SpringCloud项目搭建\\Alibaba的10.png)\n\n#### 5,controller:\n\n![](SpringCloud项目搭建\\Alibaba的11.png)\n\n\n\n#### 6,测试\n\n启动83,访问9001,9002,可以看到,实现了负载均衡\n\n\n\n\n\n### Nacos与其他服务注册的对比\n\nNacos它既可以支持CP,也可以支持AP,可以切换\n\n![](SpringCloud项目搭建\\Alibaba的12.png)\n\n![](SpringCloud项目搭建\\Alibaba的13.png)\n\n==下面这个curl命令,就是切换模式==\n\n\n\n\n\n### 使用Nacos作为配置中心:\n\n![](SpringCloud项目搭建\\Alibaba的14.png)\n\n**==需要创建配置中心的客户端模块==**\n\ncloudalibaba-Nacos-config-client-3377\n\n#### 1,pom\n\n#### 2,配置文件\n\n这里需要配置两个配置文件,application.ymk和bootstarp.yml\n\n​\t\t\t主要是为了可以与spring clodu config无缝迁移\n\n![](SpringCloud项目搭建\\Alibaba的15.png)\n\n```java\n可以看到\n```\n\n![](SpringCloud项目搭建\\Alibaba的16.png)\n\n\n\n#### 3,主启动类\n\n![](SpringCloud项目搭建\\Alibaba的18.png)\n\n#### 4,controller\n\n![](SpringCloud项目搭建\\Alibaba的17.png)\n\n```java\n可以看到,这里也添加了@RefreshScope\n  \t\t之前在Config配置中心,也是添加这个注解实现动态刷新的\t\n  \n```\n\n![](SpringCloud项目搭建\\Alibaba的19.png)\n\n#### 5,在Nacos添加配置信息:\n\n==**Nacos的配置规则:**==\n\n![](SpringCloud项目搭建\\Alibaba的20.png)\n\n**配置规则,就是我们在客户端如何指定读取配置文件,配置文件的命名的规则**\n\n默认的命名方式:\n\n![](SpringCloud项目搭建\\Alibaba的21.png)\n\n```java\nprefix:\n\t\t默认就是当前服务的服务名称\n \t\t也可以通过spring.cloud.necos.config.prefix配置\nspring.profile.active:\n\t\t就是我们在application.yml中指定的,当前是开发环境还是测试等环境\n    这个可以不配置,如果不配置,那么前面的 -  也会没有\nfile-extension\n     就是当前文件的格式(后缀),目前只支持yml和properties\n```\n\n![](SpringCloud项目搭建\\Alibaba的24.png)\n\n![](SpringCloud项目搭建\\Alibaba的25.png)\n\n==在web UI上创建配置文件:==\n\n![](SpringCloud项目搭建\\Alibaba的22.png)\n\n![](SpringCloud项目搭建\\Alibaba的23.png)\n\n注意,DataId就是配置文件名字:\n\n​\t\t名字一定要按照上面的==规则==命名,否则客户端会读取不到配置文件\n\n#### 6,测试\n\n重启3377客户端\n\n访问3377\n\n![](SpringCloud项目搭建\\Alibaba的26.png)\n\n**拿到了配置文件中的值**\n\n\n\n#### 7,注意默认就开启了自动刷新\n\n此时我们修改了配置文件\n\n客户端是可以立即更新的\n\n​\t\t\t因为Nacos支持Bus总线,会自动发送命令更新所有客户端\n\n\n\n\n\n### Nacos配置中心之分类配置:\n\n![](SpringCloud项目搭建\\Alibaba的27.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\Alibaba的28.png)\n\n![](SpringCloud项目搭建\\Alibaba的29.png)\n\nNameSpace默认有一个:public名称空间\n\n这三个类似java的: 包名 + 类名 + 方法名\n\n![](SpringCloud项目搭建\\Alibaba的30.png)\n\n\n\n![](SpringCloud项目搭建\\Alibaba的31.png)\n\n\n\n\n\n#### 1,配置不同DataId:\n\n![](SpringCloud项目搭建\\Alibaba的32.png)\n\n![](SpringCloud项目搭建\\Alibaba的33.png)\n\n\n\n​\t==通过配置文件,实现多环境的读取:==\n\n![](SpringCloud项目搭建\\Alibaba的34.png)\n\n```java\n此时,改为dev,就会读取dev的配置文件,改为test,就会读取test的配置文件\n```\n\n\n\n\n\n#### 2,配置不同的GroupID:\n\n直接在新建配置文件时指定组\n\n![](SpringCloud项目搭建\\Alibaba的35.png)\n\n![](SpringCloud项目搭建\\Alibaba的36.png)\n\n\n\n==在客户端配置,使用指定组的配置文件:==\n\n![](SpringCloud项目搭建\\Alibaba的37.png)\n\n**这两个配置文件都要修改**\n\n![](SpringCloud项目搭建\\Alibaba的38.png)\n\n​\t\n\n重启服务,即可\n\n\n\n\n\n\n\n#### 配置不同的namespace:\n\n![](SpringCloud项目搭建\\Alibaba的39.png)\n\n![](SpringCloud项目搭建\\Alibaba的42.png)\n\n==客户端配置使用不同名称空间:==\n\n![](SpringCloud项目搭建\\Alibaba的41.png)\n\n**要通过命名空间id指定**\n\nOK,测试\n\n\n\n\n\n\n\n\n\n### Nacos集群和持久化配置:\n\n![](SpringCloud项目搭建\\Alibaba的45.png)\n\nNacos默认有自带嵌入式数据库,derby,但是如果做集群模式的话,就不能使用自己的数据库\n\n​\t\t\t不然每个节点一个数据库,那么数据就不统一了,需要使用外部的mysql\n\n![](SpringCloud项目搭建\\Alibaba的43.png)\n\n\n\n#### 1,单机版,切换mysql数据库:\n\n​\t\t\t\t\t**将nacos切换到使用我们自己的mysql数据库:**\n\n**1,nacos默认自带了一个sql文件,在nacos安装目录下**\n\n​\t\t\t将它放到我们的mysql执行\n\n**2,修改Nacos安装目录下的安排application.properties,添加:**\n\n![](SpringCloud项目搭建\\Alibaba的46.png)\n\n\n\n\n\n**3,此时可以重启nacos,那么就会改为使用我们自己的mysql**\n\n\n\n\n\n\n\n#### Linux上配置Nacos集群+Mysql数据库\n\n==官方架构图:==\n\n![](SpringCloud项目搭建\\Alibaba的45.png)\n\n**需要一个Nginx作为VIP**\n\n\n\n1,下载安装Nacos的Linux版安装包\n\n2,进入安装目录,现在执行自带的sql文件\n\n​\t\t\t进入mysql,执行sql文件\n\n3.修改配置文件,切换为我们的mysql\n\n​\t\t\t就是上面windos版要修改的几个属性\n\n4,修改cluster.conf,指定哪几个节点是Nacos集群\n\n​\t\t\t这里使用3333,4444,5555作为三个Nacos节点监听的端口\n\n![](SpringCloud项目搭建\\Alibaba的47.png)\n\n5,我们这里就不配置在不同节点上了,就放在一个节点上\n\n​\t\t\t既然要在一个节点上启动不同Nacos实例,就要修改startup.sh,使其根据不同端口启动不同Nacos实例\n\n![](SpringCloud项目搭建\\Alibaba的48.png)\n\n![](SpringCloud项目搭建\\Alibaba的49.png)\n\n可以看到,这个脚本就是通过jvm启动nacos\n\n​\t\t所以我们最后修改的就是,nohup java -Dserver.port=3344\n\n\n\n\n\n6,配置Nginx:\n\n​\t\t\t![](SpringCloud项目搭建\\Alibaba的50.png)\n\n7,启动Nacos:\n\t\t\t./startup.sh -p 3333\n\n​\t\t\t./startup.sh -p 4444\n\n​\t\t\t./startup.sh -p 5555\n\n7,启动nginx\n\n8,测试:\n\n​\t\t访问192.168.159.121:1111\n\n​\t\t如果可以进入nacos的web界面,就证明安装成功了\n\n\n\n\n\n9,将微服务注册到Nacos集群:\n![](SpringCloud项目搭建\\Alibaba的51.png)\n\n10,进入Nacos的web界面\n\n​\t\t可以看到,已经注册成功\n\n![](SpringCloud项目搭建\\Alibaba的52.png)\n\n\n\n\n\n\n\n\n\n\n\n## Sentinel:\n\n实现熔断与限流,就是Hystrix\n\n![](SpringCloud项目搭建\\Alibaba的53.png)\n\n​\t![](SpringCloud项目搭建\\Alibaba的54.png)\n\n### ==使用sentinel:==\n\n\n\n1,下载sentinel的jar包\n\n2,运行sentinel\n\n​\t\t由于是一个jar包,所以可以直接java -jar运行\t\n\n​\t\t注意,默认sentinel占用8080端口\n\n3,访问sentinel\n\n​\t\tlocalhost:8080\n\n\n\n\n\n### 微服务整合sentinel:\n\n##### 1,启动Nacos\n\n##### 2,新建一个项目,8401,主要用于配置sentinel\n\n1.  pom\n\n2.   配置文件\n\n    ![](SpringCloud项目搭建\\Alibaba的55.png)\n\n3.   主启动类\n\n    ![](SpringCloud项目搭建\\Alibaba的56.png)\n\n4.   controller\\\n\n    ![](SpringCloud项目搭建\\sentinel的1.png)\n\n5.   到这里就可以启动8401\n\n    ​\t此时我们到sentinel中查看,发现并8401的任何信息\n\n    ​\t是因为,sentinel是懒加载,需要我们执行一次访问,才会有信息\n\n    ​\t访问localhost/8401/testA\n\n    ![](SpringCloud项目搭建\\sentinel的2.png)\n\n6.   可以看到.已经开始监听了\n\n​    \n\n\n\n### sentinel的流控规则\n\n流量限制控制规则\n\n![](SpringCloud项目搭建\\sentinel的7.png)\n\n![](SpringCloud项目搭建\\sentinel的3.png)\n\n\n\n![](SpringCloud项目搭建\\sentinel的4.png)\n\n==流控模式==:\n\n1.   直接快速失败\n\n    ![](SpringCloud项目搭建\\sentinel的9.png)\n\n    ![](SpringCloud项目搭建\\sentinel的5.png)\n\n       ==直接失败的效果:==\n\n    ![](SpringCloud项目搭建\\sentinel的6.png)\n\n2.  线程数:\n\n    ​\t\t![](SpringCloud项目搭建\\sentinel的8.png)\n\n    ​\t![](SpringCloud项目搭建\\sentinel的10.png)\n\n    ```\n    比如a请求过来,处理很慢,在一直处理,此时b请求又过来了\n    \t\t此时因为a占用一个线程,此时要处理b请求就只有额外开启一个线程\n    \t\t那么就会报错\n    ```\n\n    ![](SpringCloud项目搭建\\sentinel的11.png)\n\n    \n\n3.   关联:\n\n     ![](SpringCloud项目搭建\\sentinel的12.png)\n\n     ==应用场景:  比如**支付接口**达到阈值,就要限流下**订单的接口**,防止一直有订单==\n\n     ![](SpringCloud项目搭建\\sentinel的13.png)\n\n     **当testA达到阈值,qps大于1,就让testB之后的请求直接失败**\n\n     可以使用postman压测\n\n​    \n\n4.   链路:\n     多个请求调用同一个微服务\n\n5.   预热Warm up:\n\n    ​\t ![](SpringCloud项目搭建\\sentinel的14.png)\n\n      ![](SpringCloud项目搭建\\sentinel的15.png)\n\n     ![](SpringCloud项目搭建\\sentinel的16.png)\n\n     ==应用场景==\n\n     ![](SpringCloud项目搭建\\sentinel的17.png)\n\n6.   排队等待:\n\n    ![](SpringCloud项目搭建\\sentinel的18.png)\n\n    ![](SpringCloud项目搭建\\sentinel的19.png)\n\n\n\n\n\n\n\n\n\n### 降级规则:\n\n**就是熔断降级**\n\n![](SpringCloud项目搭建\\sentinel的21.png)\n\n![](SpringCloud项目搭建\\sentinel的20.png)\n\n\n\n\n\n![](SpringCloud项目搭建\\sentinel的22.png)\n\n![](SpringCloud项目搭建\\sentinel的23.png)\n\n\n\n#### 1,RT配置:\n\n新增一个请求方法用于测试\n\n![](SpringCloud项目搭建\\sentinel的24.png)\n\n==配置RT:==\n\n​\t\t\t\t这里配置的PT,默认是秒级的平均响应时间\n\n![](SpringCloud项目搭建\\sentinel的25.png)\n\n默认计算平均时间是: 1秒类进入5个请求,并且响应的平均值超过阈值(这里的200ms),就报错]\n\n​\t\t\t1秒5请求是Sentinel默认设置的\n\n==测试==\n\n![](SpringCloud项目搭建\\sentinel的27.png)\n\n![](SpringCloud项目搭建\\sentinel的26.png)\n\n**默认熔断后.就直接抛出异常**\n\n\n\n\n\n\n\n#### 2,异常比例:\n\n![](SpringCloud项目搭建\\sentinel的28.png)\n\n修改请求方法\n\n![](SpringCloud项目搭建\\sentinel的29.png)\n\n配置:\n\n![](SpringCloud项目搭建\\sentinel的31.png)\n\n\n\n==如果没触发熔断,这正常抛出异常==:\n\n![](SpringCloud项目搭建\\sentinel的32.png)\n\n==触发熔断==:\n\n![](SpringCloud项目搭建\\sentinel的33.png)\n\n\n\n\n\n\n\n\n\n#### 3, 异常数:\n\n![](SpringCloud项目搭建\\sentinel的34.png)\n\n![](SpringCloud项目搭建\\sentinel的35.png)\n\n一分钟之内,有5个请求发送异常,进入熔断\n\n\n\n\n\n\n\n\n\n### 热点规则:\n\n![](SpringCloud项目搭建\\sentinel的36.png)\n\n​\t![](SpringCloud项目搭建\\sentinel的37.png)\n\n比如:\n\n​\t\t\tlocalhost:8080/aa?name=aa\n\n​\t\t\tlocalhost:8080/aa?name=b'b\n\n​\t\t\t加入两个请求中,带有参数aa的请求访问频次非常高,我们就现在name==aa的请求,但是bb的不限制\n\n\n\n==如何自定义降级方法,而不是默认的抛出异常?==\n\n![](SpringCloud项目搭建\\sentinel的38.png)\n\n**使用@SentinelResource直接实现降级方法,它等同Hystrix的@HystrixCommand**\n\n![](SpringCloud项目搭建\\sentinel的39.png)\n\n\n\n==定义热点规则:==\n\n ![](SpringCloud项目搭建\\sentinel的40.png)\n\n![](SpringCloud项目搭建\\sentinel的42.png)\n\n**此时我们访问/testHotkey并且带上才是p1**\n\n​\t\t\t如果qps大于1,就会触发我们定义的降级方法\n\n![](SpringCloud项目搭建\\sentinel的41.png)\n\n**但是我们的参数是P2,就没有问题**\n\n![](SpringCloud项目搭建\\sentinel的44.png)\n\n\n\n只有带了p1,才可能会触发热点限流\n\n![](SpringCloud项目搭建\\sentinel的43.png)\n\n\n\n\n\n#### 2,设置热点规则中的其他选项:\n\n![](SpringCloud项目搭建\\sentinel的45.png)\n\n**需求:**\n\n![](SpringCloud项目搭建\\sentinel的46.png)\n\n\n\n![](SpringCloud项目搭建\\sentinel的47.png)\n\n==测试==\n\n![](SpringCloud项目搭建\\sentinel的48.png)\n\n![](SpringCloud项目搭建\\sentinel的49.png)\n\n\n\n**注意:**\n\n参数类型只支持,8种基本类型+String类\n\n\n\n\n\n==注意:==\n\n如果我们程序出现异常,是不会走blockHander的降级方法的,因为这个方法只配置了热点规则,没有配置限流规则\n\n我们这里配置的降级方法是sentinel针对热点规则配置的\n\n只有触发热点规则才会降级\n\n![](SpringCloud项目搭建\\sentinel的50.png)\n\n\n\n\n\n\n\n\n\n### 3,系统规则:\n\n系统自适应限流:\n\t\t\t从整体维度对应用入口进行限流\n\n对整体限流,比如设置qps到达100,这里限流会限制整个系统不可以\n\n*![](SpringCloud项目搭建\\sentinel的51.png)*\n\n\n\n![](SpringCloud项目搭建\\sentinel的52.png)\n\n==测试==:\n![](SpringCloud项目搭建\\sentinel的53.png)\n\n![](SpringCloud项目搭建\\sentinel的54.png)\n\n\n\n\n\n\n\n\n\n\n\n### @SentinelResource注解:\n\n**用于配置降级等功能**\n\n1,环境搭建\n\n1.  为8401添加依赖\n\n    添加我们自己的commone包的依赖\n\n    ![](SpringCloud项目搭建\\sentinel的55.png)\n\n2.   额外创建一个controller类\n\n    ​\t ![](SpringCloud项目搭建\\sentinel的56.png)\n\n     \n\n3.   配置限流\n\n    **注意,我们这里配置规则,资源名指定的是@SentinelResource注解value的值,**\n\n    **这样也是可以的,也就是不一定要指定访问路径**\n\n    ![](SpringCloud项目搭建\\sentinel的57.png)\n\n4.   测试.\n\n    可以看到已经进入降级方法了\n\n    ![](SpringCloud项目搭建\\sentinel的58.png)\n\n5.   ==此时我们关闭8401服务==\n\n    可以看到,这些定义的规则是临时的,关闭服务,规则就没有了\n\n    ![](SpringCloud项目搭建\\sentinel的59.png)\n\n\n\n**可以看到,上面配置的降级方法,又出现Hystrix遇到的问题了**\n\n​\t\t\t降级方法与业务方法耦合\n\n​\t\t\t每个业务方法都需要对应一个降级方法\n\n#### 自定义限流处理逻辑:\n\n1.  ==单独创建一个类,用于处理限流==\n\n    ![](SpringCloud项目搭建\\sentinel的的1.png)\n\n2.  ==在controller中,指定使用自定义类中的方法作为降级方法==\n\n    ![](SpringCloud项目搭建\\sentinel的的2.png)\n\n3.   ==Sentinel中定义流控规则==:\n\n     这里资源名,是以url指定,也可以使用@SentinelResource注解value的值指定\n\n     ![](SpringCloud项目搭建\\sentinel的的5.png)\n\n     \n\n4.  ==测试==:\n\n    ![](SpringCloud项目搭建\\sentinel的的3.png)\n\n5.  ==整体==:\n\n    ![](SpringCloud项目搭建\\sentinel的的4.png)\n\n6.   \n\n\n\n\n\n#### @SentinelResource注解的其他属性:\n\n\n\n![](SpringCloud项目搭建\\sentinel的的7.png)\n\n![](SpringCloud项目搭建\\sentinel的的6.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 服务熔断:\n\n1.  **启动nacos和sentinel**\n\n2.   **新建两个pay模块  9003和9004**\n\n    1.   pom\n\n    2.   配置文件\n\n        ![](SpringCloud项目搭建\\sentinel的的8.png)*\n\n    3.   主启动类 \n\n        ```java\n        @SpringBootApplication\n        @EnableDiscoveryClient\n        public class PaymentMain9003 {\n        \n            public static void main(String[] args) {\n                SpringApplication.run(PaymentMain9003.class,args);\n            }\n        }\n         \n        \n        ```\n\n    4.   controller\n\n        ![](SpringCloud项目搭建\\sentinel的的9.png)\n\n         **然后启动9003.9004**\n\n3.   **新建一个order-84消费者模块:**\n\n    1.   pom\n\n        与上面的pay一模一样\n\n    2.   配置文件\n\n        ![](SpringCloud项目搭建\\sentinel的的10.png)\n\n    3.   主启动类\n\n        ![](SpringCloud项目搭建\\sentinel的的11.png)\n\n    4.  配置类\n\n        ![](SpringCloud项目搭建\\sentinel的的12.png)\n\n    5.   controller\n\n        ![](SpringCloud项目搭建\\sentinel的的13.png)\n\n        \n\n    6.   **==为业务方法添加fallback来指定降级方法==**:\n\n        ![](SpringCloud项目搭建\\sentinel的的14.png)\n\n        ​\t==重启order==\n\n        测试:\n\n        ![](SpringCloud项目搭建\\sentinel的的15.png)\n\n         \n\n         ==所以,fallback是用于管理异常的,当业务方法发生异常,可以降级到指定方法==\n\n        ​\t\t\t注意,我们这里==并没有使用sentinel配置任何规则==,但是却降级成功,就是因为\n\n        ​\t\t\tfallback是用于管理异常的,当业务方法发生异常,可以降级到指定方法==\n\n        \n\n    7.   **==为业务方法添加blockHandler,看看是什么效果==**\n\n         ![](SpringCloud项目搭建\\sentinel的的16.png)\n\n         **重启84,访问业务方法:**\n\n        ![](SpringCloud项目搭建\\sentinel的的17.png)\n\n         可以看到.,直接报错了,并没有降级\n\n        ​\t\t\t\t也就是说,blockHandler==只对sentienl定义的规则降级==\n\n         \n\n    8.   **==如果fallback和blockHandler都配置呢?==**]\n\n         ![](SpringCloud项目搭建\\sentinel的的18.png)\n\n         **设置qps规则,阈值1**\n\n         ![](SpringCloud项目搭建\\sentinel的的19.png)\n\n         ==测试:==\n\n        ![](SpringCloud项目搭建\\sentinel的的20.png)\n\n         \n\n         可以看到,当两个都同时生效时,==blockhandler优先生效==\n\n    9.  **==@SentinelResource还有一个属性,exceptionsToIgnore==**\n\n         ![](SpringCloud项目搭建\\sentinel的的21.png)\n\n         **exceptionsToIgnore指定一个异常类,**\n\n        ​\t\t\t\t\t**表示如果当前方法抛出的是指定的异常,不降级,直接对用户抛出异常**\n\n         ![](SpringCloud项目搭建\\sentinel的的22.png)\n\n         \n\n         \n\n    \n\n\n\n### sentinel整合ribbon+openFeign+fallback\n\n\n\n1.  修改84模块,使其支持feign\n\n    1.  pom\n\n        ![](SpringCloud项目搭建\\sentinel的的23.png)\n\n    2.  配置文件\n\n        ![](SpringCloud项目搭建\\sentinel的的24.png)\n\n    3.  主启动类,也要修改\n\n        ![](SpringCloud项目搭建\\sentinel的的25.png)\n\n    4.  创建远程调用pay模块的接口\n\n        ![](SpringCloud项目搭建\\sentinel的的26.png)\n\n    5.  创建这个接口的实现类,用于降级\n\n        ![](SpringCloud项目搭建\\sentinel的的27.png)\n\n    6.   再次修改接口,指定降级类\n\n        ![](SpringCloud项目搭建\\sentinel的的28.png)\n\n    7.   controller添加远程调用\n\n        ![](SpringCloud项目搭建\\sentinel的的29.png)\n\n    8.  测试\n\n        启动9003,84\n\n    9.   测试,如果关闭9003.看看84会不会降级\n\n        ![](SpringCloud项目搭建\\sentinel的的30.png)\n\n        **可以看到,正常降级了**\n\n        \n\n**熔断框架比较**\n\n![](SpringCloud项目搭建\\sentinel的的31.png)\n\n\n\n\n\n\n\n\n\n### sentinel持久化规则\n\n默认规则是临时存储的,重启sentinel就会消失\n\n![](SpringCloud项目搭建\\sentinel的的32.png)\n\n**这里以之前的8401为案例进行修改:**\n\n1.  修改8401的pom\n\n    ```xml\n    添加:\n    <!-- SpringCloud ailibaba sentinel-datasource-nacos 持久化需要用到-->\n    <dependency>\n        <groupId>com.alibaba.csp</groupId>\n        <artifactId>sentinel-datasource-nacos</artifactId>\n    </dependency>\n     \n    ```\n\n    \n\n2.   修改配置文件:\n\n    添加:\n\n     ![](SpringCloud项目搭建\\sentinel的的33.png)\n\n     **实际上就是指定,我们的规则要保证在哪个名称空间的哪个分组下**\n\n     \t\t\t这里没有指定namespace, 但是是可以指定的\n\n    ​\t\t\t**注意,这里的dataid要与8401的服务名一致**\n\n3.   **在nacos中创建一个配置文件,dataId就是上面配置文件中指定的**\n\n     ![](SpringCloud项目搭建\\sentinel的的34.png)\n\n     ==json中,这些属性的含义:==\n\n    ​\t![](SpringCloud项目搭建\\sentinel的的35.png)\n\n     \n\n    \n\n4.   启动8401:\n\n     ![](SpringCloud项目搭建\\sentinel的的36.png)\n\n     可以看到,直接读取到了规则\n\n5.   关闭8401\n\n    ![](SpringCloud项目搭建\\sentinel的的37.png)\n\n6.   此时重启8401,如果sentinel又可以正常读取到规则,那么证明持久化成功\n\n    可以看到,又重新出现了\n\n     ![](SpringCloud项目搭建\\sentinel的的38.png)\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Seata:\n\n是一个分布式事务的解决方案,\n\n**分布式事务中的一些概念,也是seata中的概念:**\n\n​\t\t![](SpringCloud项目搭建\\seala.png)\n\n![](SpringCloud项目搭建\\seala的2.png)\n\n![](SpringCloud项目搭建\\seala的3.png)\n\n\n\n\n\n### seata安装:\n\n1.  **下载安装seata的安装包**\n\n2.  **修改file.conf**\n\n     ![](SpringCloud项目搭建\\seala的4.png)\n\n     ![](SpringCloud项目搭建\\seala的5.png)\n\n     ![](SpringCloud项目搭建\\seala的6.png)\n\n3.   **mysql建库建表**\n\n     1,上面指定了数据库为seata,所以创建一个数据库名为seata\n\n     2,建表,在seata的安装目录下有一个db_store.sql,运行即可\n\n4.   **继续修改配置文件,修改registry.conf**\n\n    配置seata作为微服务,指定注册中心\n\n    ![](SpringCloud项目搭建\\seala的7.png)\n\n5.   启动\n\n    先启动nacos\n\n    在启动seata-server(运行安装目录下的,seata-server.bat)\n\n    \n\n**业务说明**\n\n![](SpringCloud项目搭建\\seala的8.png)\n\n下单--->库存--->账号余额\n\n\n\n1.  创建三个数据库\n\n    ![](SpringCloud项目搭建\\seala的9.png)\n\n2.   创建对应的表\n\n    ![](SpringCloud项目搭建\\seala的10.png)\n\n3.   创建回滚日志表,方便查看\n\n    ![](SpringCloud项目搭建\\seala的11.png)\n\n    **注意==每个库都要执行一次==这个sql,生成回滚日志表**\n\n4.   ==每个业务都创建一个微服务,也就是要有三个微服务,订单,库存,账号==\n\n    ​     ==订单==,seta-order-2001\n\n    1.   pom\n\n    2.   配置文件\n\n        ```yaml\n        server:\n          port: 2001\n        \n        spring:\n          application:\n            name: seata-order-service\n          cloud:\n            alibaba:\n              seata:\n                # 自定义事务组名称需要与seata-server中的对应,我们之前在seata的配置文件中配置的名字\n                tx-service-group: fsp_tx_group\n            nacos:\n              discovery:\n                server-addr: 127.0.0.1:8848\n          datasource:\n            # 当前数据源操作类型\n            type: com.alibaba.druid.pool.DruidDataSource\n            # mysql驱动类\n            driver-class-name: com.mysql.cj.jdbc.Driver\n            url: jdbc:mysql://localhost:3306/seata_order?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=GMT%2B8\n            username: root\n            password: root\n        feign:\n          hystrix:\n            enabled: false\n        logging:\n          level:\n            io:\n              seata: info\n        \n        mybatis:\n          mapperLocations: classpath*:mapper/*.xml\n        \n         \n         \n        \n        ```\n\n        还要额外创建其他配置文件,创建一个file.conf:\n\n         ```.conf\n        transport {\n          # tcp udt unix-domain-socket\n          type = \"TCP\"\n          #NIO NATIVE\n          server = \"NIO\"\n          #enable heartbeat\n          heartbeat = true\n          #thread factory for netty\n          thread-factory {\n            boss-thread-prefix = \"NettyBoss\"\n            worker-thread-prefix = \"NettyServerNIOWorker\"\n            server-executor-thread-prefix = \"NettyServerBizHandler\"\n            share-boss-worker = false\n            client-selector-thread-prefix = \"NettyClientSelector\"\n            client-selector-thread-size = 1\n            client-worker-thread-prefix = \"NettyClientWorkerThread\"\n            # netty boss thread size,will not be used for UDT\n            boss-thread-size = 1\n            #auto default pin or 8\n            worker-thread-size = 8\n          }\n          shutdown {\n            # when destroy server, wait seconds\n            wait = 3\n          }\n          serialization = \"seata\"\n          compressor = \"none\"\n        }\n        service {\n          #vgroup->rgroup\n          # 事务组名称\n          vgroup_mapping.fsp_tx_group = \"default\"\n          #only support single node\n          default.grouplist = \"127.0.0.1:8091\"\n          #degrade current not support\n          enableDegrade = false\n          #disable\n          disable = false\n          #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent\n          max.commit.retry.timeout = \"-1\"\n          max.rollback.retry.timeout = \"-1\"\n        }\n         \n        client {\n          async.commit.buffer.limit = 10000\n          lock {\n            retry.internal = 10\n            retry.times = 30\n          }\n          report.retry.count = 5\n          tm.commit.retry.count = 1\n          tm.rollback.retry.count = 1\n        }\n         \n        ## transaction log store\n        store {\n          ## store mode: file、db\n          #mode = \"file\"\n          mode = \"db\"\n         \n          ## file store\n          file {\n            dir = \"sessionStore\"\n         \n            # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions\n            max-branch-session-size = 16384\n            # globe session size , if exceeded throws exceptions\n            max-global-session-size = 512\n            # file buffer size , if exceeded allocate new buffer\n            file-write-buffer-cache-size = 16384\n            # when recover batch read size\n            session.reload.read_size = 100\n            # async, sync\n            flush-disk-mode = async\n          }\n         \n          ## database store\n          db {\n            ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.\n            datasource = \"dbcp\"\n            ## mysql/oracle/h2/oceanbase etc.\n            db-type = \"mysql\"\n            driver-class-name = \"com.mysql.jdbc.Driver\"\n            url = \"jdbc:mysql://127.0.0.1:3306/seata\"\n            user = \"root\"\n            password = \"root\"\n            min-conn = 1\n            max-conn = 3\n            global.table = \"global_table\"\n            branch.table = \"branch_table\"\n            lock-table = \"lock_table\"\n            query-limit = 100\n          }\n        }\n        lock {\n          ## the lock store mode: local、remote\n          mode = \"remote\"\n         \n          local {\n            ## store locks in user's database\n          }\n         \n          remote {\n            ## store locks in the seata's server\n          }\n        }\n        recovery {\n          #schedule committing retry period in milliseconds\n          committing-retry-period = 1000\n          #schedule asyn committing retry period in milliseconds\n          asyn-committing-retry-period = 1000\n          #schedule rollbacking retry period in milliseconds\n          rollbacking-retry-period = 1000\n          #schedule timeout retry period in milliseconds\n          timeout-retry-period = 1000\n        }\n         \n        transaction {\n          undo.data.validation = true\n          undo.log.serialization = \"jackson\"\n          undo.log.save.days = 7\n          #schedule delete expired undo_log in milliseconds\n          undo.log.delete.period = 86400000\n          undo.log.table = \"undo_log\"\n        }\n         \n        ## metrics settings\n        metrics {\n          enabled = false\n          registry-type = \"compact\"\n          # multi exporters use comma divided\n          exporter-list = \"prometheus\"\n          exporter-prometheus-port = 9898\n        }\n         \n        support {\n          ## spring\n          spring {\n            # auto proxy the DataSource bean\n            datasource.autoproxy = false\n          }\n        }\n        \n         ```\n\n        创建registry.conf:\n\n        ```conf\n        registry {\n          # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa\n          type = \"nacos\"\n         \n          nacos {\n            #serverAddr = \"localhost\"\n            serverAddr = \"localhost:8848\"\n            namespace = \"\"\n            cluster = \"default\"\n          }\n          eureka {\n            serviceUrl = \"http://localhost:8761/eureka\"\n            application = \"default\"\n            weight = \"1\"\n          }\n          redis {\n            serverAddr = \"localhost:6379\"\n            db = \"0\"\n          }\n          zk {\n            cluster = \"default\"\n            serverAddr = \"127.0.0.1:2181\"\n            session.timeout = 6000\n            connect.timeout = 2000\n          }\n          consul {\n            cluster = \"default\"\n            serverAddr = \"127.0.0.1:8500\"\n          }\n          etcd3 {\n            cluster = \"default\"\n            serverAddr = \"http://localhost:2379\"\n          }\n          sofa {\n            serverAddr = \"127.0.0.1:9603\"\n            application = \"default\"\n            region = \"DEFAULT_ZONE\"\n            datacenter = \"DefaultDataCenter\"\n            cluster = \"default\"\n            group = \"SEATA_GROUP\"\n            addressWaitTime = \"3000\"\n          }\n          file {\n            name = \"file.conf\"\n          }\n        }\n         \n        config {\n          # file、nacos 、apollo、zk、consul、etcd3\n          type = \"file\"\n         \n          nacos {\n            serverAddr = \"localhost\"\n            namespace = \"\"\n          }\n          consul {\n            serverAddr = \"127.0.0.1:8500\"\n          }\n          apollo {\n            app.id = \"seata-server\"\n            apollo.meta = \"http://192.168.1.204:8801\"\n          }\n          zk {\n            serverAddr = \"127.0.0.1:2181\"\n            session.timeout = 6000\n            connect.timeout = 2000\n          }\n          etcd3 {\n            serverAddr = \"http://localhost:2379\"\n          }\n          file {\n            name = \"file.conf\"\n          }\n        }\n        \n        ```\n\n        ==实际上,就是要将seata中的我们之前修改的两个配置文件复制到这个项目下==\n\n    3.   **主启动类**\n\n        ```java\n        @SpringBootApplication(exclude = DataSourceAutoConfiguration.class) //取消数据源的自动创建\n        @EnableDiscoveryClient\n        @EnableFeignClients\n        public class SeataOrderMain2001 {\n        \n            public static void main(String[] args) {\n                SpringApplication.run(SeataOrderMain2001.class,args);\n            }\n        }\n        ```\n\n        \n\n    4.   **service层**\n\n         ```xml\n        public interface OrderService {\n        \n            /**\n             * 创建订单\n             * @param order\n             */\n            void create(Order order);\n        }\n        ```\n\n        ```xml\n        @FeignClient(value = \"seata-storage-service\")\n        public interface StorageService {\n        \n            /**\n             * 减库存\n             * @param productId\n             * @param count\n             * @return\n             */\n            @PostMapping(value = \"/storage/decrease\")\n            CommonResult decrease(@RequestParam(\"productId\") Long productId, @RequestParam(\"count\") Integer count);\n        }\n        ```\n\n        ```xml\n        @FeignClient(value = \"seata-account-service\")\n        public interface AccountService {\n        \n            /**\n             * 减余额\n             * @param userId\n             * @param money\n             * @return\n             */\n            @PostMapping(value = \"/account/decrease\")\n            CommonResult decrease(@RequestParam(\"userId\") Long userId, @RequestParam(\"money\") BigDecimal money);\n        }\n         \n         \n        \n        ```\n\n        ```xml\n        @Service\n        @Slf4j\n        public class OrderServiceImpl implements OrderService {\n        \n            @Resource\n            private OrderDao orderDao;\n            @Resource\n            private AccountService accountService;\n            @Resource\n            private StorageService storageService;\n        \n            /**\n             * 创建订单->调用库存服务扣减库存->调用账户服务扣减账户余额->修改订单状态\n             * 简单说:\n             * 下订单->减库存->减余额->改状态\n             * GlobalTransactional seata开启分布式事务,异常时回滚,name保证唯一即可\n             * @param order 订单对象\n             */\n            @Override\n            ///@GlobalTransactional(name = \"fsp-create-order\", rollbackFor = Exception.class)\n            public void create(Order order) {\n                // 1 新建订单\n                log.info(\"----->开始新建订单\");\n                orderDao.create(order);\n        \n                // 2 扣减库存\n                log.info(\"----->订单微服务开始调用库存,做扣减Count\");\n                storageService.decrease(order.getProductId(), order.getCount());\n                log.info(\"----->订单微服务开始调用库存,做扣减End\");\n        \n                // 3 扣减账户\n                log.info(\"----->订单微服务开始调用账户,做扣减Money\");\n                accountService.decrease(order.getUserId(), order.getMoney());\n                log.info(\"----->订单微服务开始调用账户,做扣减End\");\n        \n                // 4 修改订单状态,从0到1,1代表已完成\n                log.info(\"----->修改订单状态开始\");\n                orderDao.update(order.getUserId(), 0);\n        \n                log.info(\"----->下订单结束了,O(∩_∩)O哈哈~\");\n            }\n        }\n        ```\n\n        \n\n         \n\n         \n\n         \n\n         \n\n         \n\n         \n\n    5.   **dao层,也就是接口**\n\n        ```java\n        @Mapper\n        public interface OrderDao {\n            /**\n             * 1 新建订单\n             * @param order\n             * @return\n             */\n            int create(Order order);\n        \n            /**\n             * 2 修改订单状态,从0改为1\n             * @param userId\n             * @param status\n             * @return\n             */\n            int update(@Param(\"userId\") Long userId, @Param(\"status\") Integer status);\n        }\n        ```\n\n         ==在resource下创建mapper文件夹,编写mapper.xml==\n\n        ```xml\n        <?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n        <!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n                \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n        <mapper namespace=\"com.eiletxie.springcloud.alibaba.dao.OrderDao\">\n        \n            <resultMap id=\"BaseResultMap\" type=\"com.eiletxie.springcloud.alibaba.domain.Order\">\n                <id column=\"id\" property=\"id\" jdbcType=\"BIGINT\"></id>\n                <result column=\"user_id\" property=\"userId\" jdbcType=\"BIGINT\"></result>\n                <result column=\"product_id\" property=\"productId\" jdbcType=\"BIGINT\"></result>\n                <result column=\"count\" property=\"count\" jdbcType=\"INTEGER\"></result>\n                <result column=\"money\" property=\"money\" jdbcType=\"DECIMAL\"></result>\n                <result column=\"status\" property=\"status\" jdbcType=\"INTEGER\"></result>\n            </resultMap>\n        \n            <insert id=\"create\" parameterType=\"com.eiletxie.springcloud.alibaba.domain.Order\" useGeneratedKeys=\"true\"\n                    keyProperty=\"id\">\n                insert into t_order(user_id,product_id,count,money,status) values (#{userId},#{productId},#{count},#{money},0);\n            </insert>\n        \n            <update id=\"update\">\n                update t_order set status =1 where user_id =#{userId} and status=#{status};\n           </update>\n        </mapper>\n         \n        ```\n\n    6.   **controller层**\n\n        ```java\n        @RestController\n        public class OrderController {\n            @Resource\n            private OrderService orderService;\n        \n        \n            /**\n             * 创建订单\n             *\n             * @param order\n             * @return\n             */\n            @GetMapping(\"/order/create\")\n            public CommonResult create(Order order) {\n                orderService.create(order);\n                return new CommonResult(200, \"订单创建成功\");\n            }\n        \n        \n        }\n        ```\n\n        \n\n    7.   **entity类(也叫domain类)**\n\n         ```java\n        @Data\n        @AllArgsConstructor\n        @NoArgsConstructor\n        public class CommonResult<T> {\n            private Integer code;\n            private String message;\n            private T data;\n        \n            public CommonResult(Integer code, String message) {\n                this(code, message, null);\n            }\n        }\n         \n        ```\n\n        ![](SpringCloud项目搭建\\seala的12.png)\n\n         \n\n         \n\n        \n\n    8.   config配置类\n\n        ```java\n        @Configuration\n        @MapperScan({\"com.eiletxie.springcloud.alibaba.dao\"})\t\t指定我们的接口的位置\n        public class MyBatisConfig {\n        \n        \n        }\n         \n         \n        \n        ```\n\n        ```java\n        \n        \n        /**\n         * @Author EiletXie\n         * @Since 2020/3/18 21:51\n         * 使用Seata对数据源进行代理\n         */\n        @Configuration\n        public class DataSourceProxyConfig {\n        \n            @Value(\"${mybatis.mapperLocations}\")\n            private String mapperLocations;\n        \n            @Bean\n            @ConfigurationProperties(prefix = \"spring.datasource\")\n            public DataSource druidDataSource() {\n                return new DruidDataSource();\n            }\n        \n            @Bean\n            public DataSourceProxy dataSourceProxy(DataSource druidDataSource) {\n                return new DataSourceProxy(druidDataSource);\n            }\n        \n            @Bean\n            public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception {\n                SqlSessionFactoryBean bean = new SqlSessionFactoryBean();\n                bean.setDataSource(dataSourceProxy);\n                ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();\n                bean.setMapperLocations(resolver.getResources(mapperLocations));\n                return bean.getObject();\n            }\n        }\n         \n         \n        \n        ```\n\n        \n\n    9.   \n\n    10.   \n\n    11.  \n\n      ==库存==,seta-storage-2002\n\n    **==看脑图==**\n\n    1.    pom   \n    2.   配置文件\n    3.   主启动类\n    4.    service层\n    5.    dao层\n    6.    controller层\n    7.   \n    8.   \n\n     \n\n     ==账号==,seta-account-2003\n\n    **==看脑图==**\n\n    1.    pom     \n    2.   配置文件\n    3.   主启动类\n    4.   service层\n    5.    dao层\n    6.   controller层\n    7.   \n    8.   \n\n5.   **全局创建完成后,首先测试不加seata**\n\n     ![](SpringCloud项目搭建\\seala的14.png)\n\n     \n\n     ![](SpringCloud项目搭建\\seala的13.png)\n\n​    \n\n​    \n\n​     \n\n6.   使用seata:\n\n     **在==订单模块==的serviceImpl类中的==create方法==添加启动分布式事务的注解**\n\n     ```java\n    /**\n    \t这里添加开启分布式事务的注解,name指定当前全局事务的名称\n    \trollbackFor表示,发生什么异常需要回滚\n    \tnoRollbackFor:表示,发生什么异常不需要回滚\n    */\n    @GlobalTransactional(name = \"fsp-create-order\",rollbackFor = Exception.class)\n    ///@GlobalTransactional(name = \"fsp-create-order\", rollbackFor = Exception.class)\n    public void create(Order order) {\n        // 1 新建订单\n        log.info(\"----->开始新建订单\");\n        orderDao.create(order);\n    \n        // 2 扣减库存\n        log.info(\"----->订单微服务开始调用库存,做扣减Count\");\n        storageService.decrease(order.getProductId(), order.getCount());\n        log.info(\"----->订单微服务开始调用库存,做扣减End\");\n    \n        // 3 扣减账户\n        log.info(\"----->订单微服务开始调用账户,做扣减Money\");\n        accountService.decrease(order.getUserId(), order.getMoney());\n        log.info(\"----->订单微服务开始调用账户,做扣减End\");\n    \n        // 4 修改订单状态,从0到1,1代表已完成\n        log.info(\"----->修改订单状态开始\");\n        orderDao.update(order.getUserId(), 0);\n    \n        log.info(\"----->下订单结束了,O(∩_∩)O哈哈~\");\n    }\n    \n    ```\n\n     \n\n7.   此时在测试\n\n    发现,发生异常后,直接回滚了,前面的修改操作都回滚了\n\n \n\n\n\n### setat原理:\n\n![](SpringCloud项目搭建\\seala的15.png)\n\n![](SpringCloud项目搭建\\seala的16.png)\n\n\n\n**seata提供了四个模式:**\n\n![](SpringCloud项目搭建\\seala的17.png)\n\n\n\n![](SpringCloud项目搭建\\seala的18.png)\n\n==第一阶段:==\n\n![](SpringCloud项目搭建\\seala的20.png)\n\n​\t![](SpringCloud项目搭建\\seala的19.png)\n\n\n\n\n\n==二阶段之提交==:\n\n![](SpringCloud项目搭建\\seala的21.png)\n\n\n\n==二阶段之回滚:==\n\n![](SpringCloud项目搭建\\seala的22.png)\n\n![](SpringCloud项目搭建\\seala的23.png)\n\n\n\n\n\n\n\n==断点==:\n\n![](SpringCloud项目搭建\\seala的24.png)\n\n**可以看到,他们的xid全局事务id是一样的,证明他们在一个事务下**\n\n\n\n\n\n![](SpringCloud项目搭建\\seala的25.png)\n\n**before 和 after的原理就是**\n\n![](SpringCloud项目搭建\\seala的26.png)\n\n**在更新数据之前,先解析这个更新sql,然后查询要更新的数据,进行保存**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["springcloud"]},{"title":"生产消费者模型","url":"/2020/08/20/JUC/生产消费者模型/","content":"\n\n\n- \n\n\n\n\n\n# 通过上面的题目，思考生产消费者模型是怎么实现的？\n\n### 堵塞队列生消\n\n- 代码(线程去操作资源类，一个消费方法，一个生产方法，搞清楚什么时候生产什么时候消费，其原理也明白了)\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.SynchronousQueue;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 堵塞队列生消\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-23 22:19\n **/\npublic class BlockingQueueDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        //生产一个消费一个\n       // demo1();\n        BlockingQueueResource<String> queueResource = new BlockingQueueResource<>(\n            new SynchronousQueue());\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                queueResource.produce(\"AA\" + i);\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                queueResource.consumer();\n            }\n        }, \"t2\").start();\n\n        //控制生产消费者的中止\n       // TimeUnit.SECONDS.sleep(5);\n        // queueResource.stop();\n    }\n\n\n    private static void demo1() {\n        SynchronousQueue<String> synchronousQueue = new SynchronousQueue<>();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(\"生产一个：\" + Thread.currentThread().getName());\n                    synchronousQueue.put(Thread.currentThread().getName());\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 5; i++) {\n                    System.out.println(Thread.currentThread().getName() + \":sleep 3s\");\n                    TimeUnit.SECONDS.sleep(3);\n                    System.out.println(\n                        Thread.currentThread().getName() + \"消费：\" + synchronousQueue.take());\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t2\").start();\n    }\n\n}\n\nclass BlockingQueueResource<T> {\n\n    private BlockingQueue<T> blockingQueue = null;\n    private volatile boolean FLAG = true;\n\n    public BlockingQueueResource(BlockingQueue blockingQueue) {\n        this.blockingQueue = blockingQueue;\n    }\n\n    public boolean produce(T t) {\n        while (FLAG) {\n            try {\n                TimeUnit.SECONDS.sleep(3);\n                boolean result = blockingQueue.offer(t, 2, TimeUnit.SECONDS);\n                System.out.println(\n                    Thread.currentThread().getName()\n                        + \"：blockingQueue 生产\" + t + \" status:\" + result);\n                return result;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"FLAG :\" + FLAG + \",停止生产\");\n        return false;\n    }\n\n    public T consumer() {\n        while (FLAG) {\n            try {\n                T t = blockingQueue.poll(5, TimeUnit.SECONDS);\n                System.out.println(\n                    Thread.currentThread().getName() + \"：取出结果--->\" + t);\n                if (t == null) {\n                    System.out.println(\"超过5s没有消费，模拟退出\");\n                    FLAG = false;\n                }\n                return t;\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n        System.out.println(\"FLAG :\" + FLAG + \",停止消费\");\n        return null;\n    }\n    public void stop(){\n        this.FLAG=false;\n    }\n\n\n}\n```\n\n- 结果\n\n```java\nt1：blockingQueue 生产AA0 status:true\nt2：取出结果--->AA0\nt1：blockingQueue 生产AA1 status:true\nt2：取出结果--->AA1\nt1：blockingQueue 生产AA2 status:true\nt2：取出结果--->AA2\nt1：blockingQueue 生产AA3 status:true\nt2：取出结果--->AA3\nt1：blockingQueue 生产AA4 status:true\nt2：取出结果--->AA4\n\nProcess finished with exit code 0\n```\n\n","tags":["JUC"]},{"title":"JUC基础","url":"/2020/08/20/JUC/JUC基础/","content":"\n# JUC\n\n- JUC就是指java.util.concurrent在并发编程中使用的工具类\n\n## 进程和线程\n\n- 进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。\n- 线程：通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。\n\n## 线程的状态\n\n- java.lang.Thread.State\n  - new:为开始start的线程\n  - RUNNABLE:在JVM中运行但是正在等待其他资源操作，自身还没得到调用\n  - BLOCKED：blocked状态就是在等待监视器的(释放)锁时阻塞的线程。\n  - WAITING：由于调用了一下方法处于waiting状态\n    - Object#wait() Object.wait} with no timeout\n    - #join() Thread.join} with no timeout\n    - LockSupport#park() LockSupport.park\n  - TIMED_WAITING:\n    - sleep Thread.sleep\n    - Object#wait(long) Object.wait} with timeout\n    - #join(long) Thread.join} with timeout\n    - LockSupport#parkNanos LockSupport.parkNanos\n    - LockSupport#parkUntil LockSupport.parkUntil\n  - TERMINATED:已经完成执行的线程\n\n```java\nThread.State\n \n \n \npublic enum State {\n    /**\n     * Thread state for a thread which has not yet started.\n     */\n    NEW,(新建)\n\n    /**\n     * Thread state for a runnable thread.  A thread in the runnable\n     * state is executing in the Java virtual machine but it may\n     * be waiting for other resources from the operating system\n     * such as processor.\n     */\n    RUNNABLE,（准备就绪）\n\n    /**\n     * Thread state for a thread blocked waiting for a monitor lock.\n     * A thread in the blocked state is waiting for a monitor lock\n     * to enter a synchronized block/method or\n     * reenter a synchronized block/method after calling\n     * {@link Object#wait() Object.wait}.\n     */\n    BLOCKED,（阻塞）\n\n    /**\n     * Thread state for a waiting thread.\n     * A thread is in the waiting state due to calling one of the\n     * following methods:\n     * <ul>\n     *   <li>{@link Object#wait() Object.wait} with no timeout</li>\n     *   <li>{@link #join() Thread.join} with no timeout</li>\n     *   <li>{@link LockSupport#park() LockSupport.park}</li>\n     * </ul>\n     *\n     * <p>A thread in the waiting state is waiting for another thread to\n     * perform a particular action.\n     *\n     * For example, a thread that has called <tt>Object.wait()</tt>\n     * on an object is waiting for another thread to call\n     * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on\n     * that object. A thread that has called <tt>Thread.join()</tt>\n     * is waiting for a specified thread to terminate.\n     */\n    WAITING,（不见不散）\n\n    /**\n     * Thread state for a waiting thread with a specified waiting time.\n     * A thread is in the timed waiting state due to calling one of\n     * the following methods with a specified positive waiting time:\n     * <ul>\n     *   <li>{@link #sleep Thread.sleep}</li>\n     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>\n     *   <li>{@link #join(long) Thread.join} with timeout</li>\n     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>\n     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>\n     * </ul>\n     */\n    TIMED_WAITING,（过时不候）\n\n    /**\n     * Thread state for a terminated thread.\n     * The thread has completed execution.\n     */\n    TERMINATED;(终结)\n}\n```\n\n\n\n![](JUC基础/1.jpg)\n\n\n\n## 线程相关几个方法的比较\n\n1. Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入阻塞，但不释放对象锁，millis后线程自动苏醒进入可运行状态。作用：给其它线程执行机会的最佳方式。\n2. Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的cpu时间片，由运行状态变会可运行状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。\n3. t.join()/t.join(long millis)，当前线程里调用其它线程1的join方法，当前线程阻塞，但不释放对象锁，直到线程1执行完毕或者millis时间到，当前线程进入可运行状态。\n4. obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒或者wait(long timeout)timeout时间到自动唤醒。\n5. obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。\n\n## wait/sleep的区别？\n\n- wait/sleep功能都是当前线程暂停，有什么区别？\n  - wait释放手里的锁，等待xx时间\n  - sleep持有锁，等待xx时间\n\n## 怎么样写一个单例模式\n\n- 为什么要要用双端加锁？防止并发访问不安全\n- 为什么singletonDemo需要加上volatile？防止指令重排\n\n\n\n```java\npackage com.mk.learn.juc;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-19 22:49\n **/\npublic class SingletonDemo {\n\n    private static volatile SingletonDemo singletonDemo = null;\n\n    private SingletonDemo() {}\n\n    //DCL双端加锁机制\n    public SingletonDemo getInstance() {\n        if (singletonDemo == null) {\n            synchronized (SingletonDemo.class) {\n                if (singletonDemo == null) {\n                    singletonDemo = new SingletonDemo();\n                    return singletonDemo;\n                }\n            }\n        }\n        return singletonDemo;\n    }\n\n}\n\n```\n\n\n\n","tags":["JUC"]},{"title":"多线程锁","url":"/2020/08/20/JUC/多线程锁/","content":"\n\n\n# Synchronized\n\n## Synchronized锁的原理\n\n- 通过查看.class文件的字节码，通过命令 javap -verbose SynchronizedObj.class\n  - 可以看到，我们编译出来的子解码中通过**monitorenter和monitorexit**执行加锁和释放锁的\n\n    - ```JAVA\n      \t\t 4: monitorenter//加锁\n               5: iconst_1\n               6: aload_1\n               7: monitorexit//释放锁\n               8: ireturn\n               9: astore_2\n              10: aload_1\n              11: monitorexit//思考为什么会有二次释放锁?\n      ```\n\n    - 为什么会二次释放锁？catch异常，类似finally的作用，保证锁释放\n\n## 锁的粒度\n\nA 一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，\n其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法\n锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法\n\n加个普通方法后发现和同步锁无关\n换成两个对象后，不是同一把锁了，情况立刻变化。\n\nsynchronized实现同步的基础：Java中的每一个对象都可以作为锁。\n具体表现为以下3种形式。\n**对于普通同步方法，锁是当前实例对象。**\n**对于静态同步方法，锁是当前类的Class对象。**\n**对于同步方法块，锁是Synchonized括号里配置的对象**\n\n当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。\n\n也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，\n可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，\n所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。\n\n**所有的静态同步方法用的也是同一把锁——类对象本身，**\n这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。\n但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，\n而不管是同一个实例对象的静态同步方法之间，\n还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！\n\n \n\n- 原文件(内容忽略)\n\n```java\npublic class SynchronizedObj {\n    public int getA() {\n        synchronized (SynchronizedObj.class) {\n            return 1;\n        }\n    }\n}\n```\n\n- javap -verbose SynchronizedObj.class后\n\n```java\nE:\\developProject\\github\\mk_learn\\juc-demo\\target\\classes\\com\\mk\\learn\\juc>javap -verbose SynchronizedObj.class\nClassfile /E:/developProject/github/mk_learn/juc-demo/target/classes/com/mk/learn/juc/SynchronizedObj.class\n  Last modified 2020-8-30; size 482 bytes\n  MD5 checksum 58e3157b30b0053d2519325a88478783\n  Compiled from \"SynchronizedObj.java\"\npublic class com.mk.learn.juc.SynchronizedObj\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #3.#19         // java/lang/Object.\"<init>\":()V\n   #2 = Class              #20            // com/mk/learn/juc/SynchronizedObj\n   #3 = Class              #21            // java/lang/Object\n   #4 = Utf8               <init>\n   #5 = Utf8               ()V\n   #6 = Utf8               Code\n   #7 = Utf8               LineNumberTable\n   #8 = Utf8               LocalVariableTable\n   #9 = Utf8               this\n  #10 = Utf8               Lcom/mk/learn/juc/SynchronizedObj;\n  #11 = Utf8               getA\n  #12 = Utf8               ()I\n  #13 = Utf8               StackMapTable\n  #14 = Class              #20            // com/mk/learn/juc/SynchronizedObj\n  #15 = Class              #21            // java/lang/Object\n  #16 = Class              #22            // java/lang/Throwable\n  #17 = Utf8               SourceFile\n  #18 = Utf8               SynchronizedObj.java\n  #19 = NameAndType        #4:#5          // \"<init>\":()V\n  #20 = Utf8               com/mk/learn/juc/SynchronizedObj\n  #21 = Utf8               java/lang/Object\n  #22 = Utf8               java/lang/Throwable\n{\n  public com.mk.learn.juc.SynchronizedObj();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 9: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lcom/mk/learn/juc/SynchronizedObj;\n\n  public int getA();\n    descriptor: ()I\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=3, args_size=1\n         0: ldc           #2                  // class com/mk/learn/juc/SynchronizedObj\n         2: dup\n         3: astore_1\n         4: monitorenter//加锁\n         5: iconst_1\n         6: aload_1\n         7: monitorexit//释放锁\n         8: ireturn\n         9: astore_2\n        10: aload_1\n        11: monitorexit//思考为什么会有二次释放锁?\n        12: aload_2\n        13: athrow\n      Exception table:\n         from    to  target type\n             5     8     9   any\n             9    12     9   any\n      LineNumberTable:\n        line 12: 0\n        line 13: 5\n        line 14: 9\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      14     0  this   Lcom/mk/learn/juc/SynchronizedObj;\n      StackMapTable: number_of_entries = 1\n        frame_type = 255 /* full_frame */\n          offset_delta = 9\n          locals = [ class com/mk/learn/juc/SynchronizedObj, class java/lang/Object ]\n          stack = [ class java/lang/Throwable ]\n}\nSourceFile: \"SynchronizedObj.java\"  \n```\n\n# Lock接口\n\n## ReentrantLock可重入锁\n\n- 使用：\n\n```java\nclass X {\n   private final ReentrantLock lock = new ReentrantLock();\n   // ...\n \n   public void m() {\n     lock.lock();  // block until condition holds\n     try {\n       // ... method body\n     } finally {\n       lock.unlock()\n     }\n   }\n }\n \n```\n\n\n\n## 创建线程的方法\n\n- 继承Thread\n- 实现Runnable\n- java5以后\n  - 实现callable接口\n  - 使用java的线程池获得\n\n\n\n# synchronized和Condition的用法\n\n## synchronized与Lock的区别 \n\n![](多线程锁/1.bmp)\n\n两者区别：\n1.首先synchronized是java内置关键字，在jvm层面，Lock是个java类；\n2.synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\n3.synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n4.用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\n5.synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\n6.Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n## 题目1\n\n### 题目1：现在两个线程，可以操作初始值为零的一个变量。实现一个线程对该变量加1，一个线程对该变量-1，\n\n- 实现交替，来10轮，变量初始值为0.\n  - 1.高内聚低耦合前提下，线程操作资源类\n  - 2.判断/干活/通知\n  - 3.防止虚假唤醒(判断只能用while，不能用if)\n  - 知识小总结：多线程编程套路+while判断+新版写法\n\n#### 传统写法synchronized\n\n- 通过synchronized加锁，避免并发执行\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\n/**\n * @program: learning-demo\n * @description: 传统的生产消费模式\n * @author: mk_passby\n * @create: 2020-08-30 18:49\n **/\npublic class TraditionnaDemo0 {\n\n    public static void main(String[] args) {\n        Resource0 resource0 = new Resource0();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    resource0.increment();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"AA\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    resource0.decrement();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"BB\").start();\n    }\n\n}\n\nclass Resource0 {\n\n    private int number = 0;\n\n    public synchronized void increment() throws InterruptedException {\n        //1.判断，不等于0，不该我执行\n        while (number != 0) {\n            this.wait();\n        }\n        //2.干活\n        number++;\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n        //3.通知\n        this.notifyAll();\n    }\n\n    public synchronized void decrement() throws InterruptedException {\n        //1.判断，等于0，不该我执行\n        while (number == 0) {\n            this.wait();\n        }\n        //2.干活\n        number--;\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n        //3.通知\n        this.notifyAll();\n    }\n}\n```\n\n- 结果\n\n```java\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\nAA\t1\nBB\t0\n\nProcess finished with exit code 0\n```\n\n#### 新写法Condition\n\n- 代码\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * 生产一个消费一个\n * @program: learning-demo\n * @description: 传统生产消模型\n * @author: mk_passby\n * @create: 2020-07-23 19:56\n **/\npublic class ConditionDemo {\n\n    //交换打印线程\n    public static void main(String[] args) {\n        Resource resource = new Resource();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    resource.increase();\n                }\n\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                for (int i = 0; i < 10; i++) {\n                    resource.decrease();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t2\").start();\n    }\n\n\n}\n\nclass Resource {\n\n    private int number = 0;\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n\n    public void increase() throws InterruptedException {\n        lock.lock();\n        try {\n            //不等于0，不该我执行\n            while (number != 0) {\n                condition.await();\n            }\n            number++;\n            System.out.println(Thread.currentThread().getName() + \":number is \" + number);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n\n    public void decrease() throws InterruptedException {\n        lock.lock();\n        try {\n            //不等于1，不该我执行\n            while (number != 1) {\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName() + \":number is \" + number);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n\n    }\n}\n\n```\n\n- 结果\n\n```java\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\nt1:number is 1\nt2:number is 0\n\nProcess finished with exit code 0\n```\n\n\n\n\n\n## 题目2\n\n### 如题目1所示，如果再加入一个线程，需要三个线程有顺序的交替执行，怎么报错\n\n- 代码\n\n```java\npackage com.mk.learn.juc.produceconsumer;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * @program: learning-demo\n * @description: 多个线程交替执行\n * @author: mk_passby\n * @create: 2020-07-23 20:44\n **/\npublic class ConditionDemo1 {\n\n    public static void main(String[] args) {\n        Resource1 resource1 = new Resource1();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                resource1.printT1(i);\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                resource1.printT2(i);\n            }\n        }, \"t2\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                resource1.printT3(i);\n            }\n        }, \"t3\").start();\n    }\n\n}\n\nclass Resource1 {\n\n    private int num;\n    private Lock lock = new ReentrantLock();\n    private Condition condition = lock.newCondition();\n    private Condition condition1 = lock.newCondition();\n    private Condition condition2 = lock.newCondition();\n\n\n    public void printT1(int i) {\n        lock.lock();\n        try {\n            while (num != 0) {\n\n                condition.await();\n\n            }\n            num = 1;\n            System.out.println(Thread.currentThread().getName() + \"：开始执行\"+i);\n            condition1.signal();\n        } catch (Exception e) {\n            System.out.println(e);\n        } finally {\n            lock.unlock();\n        }\n\n    }\n\n    public void printT2(int i) {\n        lock.lock();\n        try {\n            while (num != 1) {\n\n                condition1.await();\n\n            }\n            num = 2;\n            System.out.println(Thread.currentThread().getName() + \"：开始执行\"+i);\n            condition2.signal();\n        } catch (Exception e) {\n            System.out.println(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void printT3(int i) {\n        lock.lock();\n        try {\n            while (num != 2) {\n                condition2.await();\n            }\n            num = 0;\n            System.out.println(Thread.currentThread().getName() + \"：开始执行\"+i);\n            condition.signal();\n        } catch (Exception e) {\n            System.out.println(e);\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n- 结果\n\n```java\nt1：开始执行0\nt2：开始执行0\nt3：开始执行0\nt1：开始执行1\nt2：开始执行1\nt3：开始执行1\nt1：开始执行2\nt2：开始执行2\nt3：开始执行2\nt1：开始执行3\nt2：开始执行3\nt3：开始执行3\nt1：开始执行4\nt2：开始执行4\nt3：开始执行4\n\nProcess finished with exit code 0\n```\n\n## 题目3\n\n### 多线程之间按顺序调用，实现A->B->C，三个线程启动，要求如下：AA打印5次，BB打印10次，CC打印15次\n\n- 参数题目2，自己思考。实现很简单了已经\n\n\n\n# Q&A\n\n## AQS原理\n\n- ReentrantLock源码分析：https://blog.csdn.net/u010452388/article/details/90485326\n- 什么是AQS，是指什么？AbstractQueuedSynchronizer\n\n\n\n## 多线程之间的虚假唤醒是什么？\n\n- 思考为什么多线程里使用while不使用if\n\n## 自己实现一个CAS的场景\n\n- 代码(AtomicInteger),如果是对象使用AtomicReference。\n- 注意CAS不是compareAndSet的意思，而说\n\n```java\npublic class CasDemo {\n\n    public static void main(String[] args) {\n        AtomicInteger atomicInteger=new AtomicInteger(10);\n        System.out.println(\"compareAndSet result:\"+atomicInteger.compareAndSet(10, 100));\n        System.out.println(\"getAtomicInteger:\"+atomicInteger.get());\n        System.out.println(\"compareAndSet result:\"+atomicInteger.compareAndSet(10, 100));\n        System.out.println(\"getAtomicInteger:\"+atomicInteger.get());\n    }\n\n}\n```\n\n- 结果\n\n```java\ncompareAndSet result:true\ngetAtomicInteger:100\ncompareAndSet result:false\ngetAtomicInteger:100\n\nProcess finished with exit code 0\n```\n\n\n\n## ABA问题是什么，怎么解决？\n\n- ABA问题，由于CAS是比较和替换，在期望值为A的情况下，如果过程中该值从A->B->A，最终去比较的时候还是为A，发现不了其被修改过，可能会导致一些业务场景产生问题\n\n- 怎么解决？\n\n  - 引入版本号。类似乐观锁的概念，通过一个版本号做比对\n\n- ABA问题，演示，\n\n  ```java\n  package com.mk.learn.juc.lock.cas;\n  \n  import java.util.concurrent.TimeUnit;\n  import java.util.concurrent.atomic.AtomicReference;\n  import java.util.concurrent.atomic.AtomicStampedReference;\n  \n  /**\n   * @program: learning-demo\n   * @description:\n   * @author: mk_passby\n   * @create: 2020-07-19 22:54\n   **/\n  public class ABADemo {\n  \n      private static AtomicReference<String> atomicReference = new AtomicReference<>(\"AA\");\n      private static AtomicStampedReference<String> atomicStampedReference =\n          new AtomicStampedReference<>(\"AAA\", 1);\n  \n      public static void main(String[] args) {\n          //ABA问题(AAA线程修改内容为BB,在修改为AA，BBB线程执行的时候感知不到过程有修改)\n          new Thread(() -> {\n              atomicReference.compareAndSet(\"AA\", \"BB\");\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + atomicReference.get());\n              atomicReference.compareAndSet(\"BB\", \"AA\");\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + atomicReference.get());\n          }, \"T1\").start();\n          new Thread(() -> {\n              try {\n                  TimeUnit.SECONDS.sleep(1);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              atomicReference.compareAndSet(\"AA\", \"cc\");\n              System.out.println(Thread.currentThread().getName() + \"\\t\" + atomicReference.get());\n          }, \"T2\").start();\n  \n          //AtomicStampedReference\n          new Thread(() -> {\n              atomicStampedReference.compareAndSet(\n                  \"AAA\",\n                  \"BBB\",\n                  1,\n                  2);\n              System.out.println(Thread.currentThread().getName() + \"\\t\"\n                  + atomicStampedReference.getReference());\n              atomicStampedReference.compareAndSet(\n                  \"BBB\",\n                  \"AAA\",\n                  2,\n                  3);\n              System.out.println(Thread.currentThread().getName() + \"\\t\"\n                  + atomicStampedReference.getReference());\n          }, \"T3\").start();\n          new Thread(() -> {\n              try {\n                  TimeUnit.SECONDS.sleep(1);\n              } catch (InterruptedException e) {\n                  e.printStackTrace();\n              }\n              atomicStampedReference.compareAndSet(\n                  \"AAA\",\n                  \"CCC\",\n                  1,\n                  4);\n              System.out.println(Thread.currentThread().getName() + \"\\t\"\n                  + atomicStampedReference.getReference());\n          }, \"T4\").start();\n      }\n  \n  }\n  \n  ```\n\n  \n  - 结果如下\n    - T1,T2为ABA问题复现\n      - 1 该代码演示了T1线程执行CAS，将AA修改为BB，然后又将BB修改为AA\n      - 2 T2线程进而去修改CAS，发现可以比对上，修改为了CC。\n    - T3,T4线程为解决ABA问题\n      - 引入了版本号的概念，T4在执行CAS修改值的时候，版本号已经无法匹配，即T4线程修改不成功，解决了ABA问题\n\n  ```java\n  T1\tBB\n  T1\tAA\n  T3\tBBB\n  T3\tAAA\n  T2\tcc\n  T4\tAAA\n  \n  Process finished with exit code 0\n  ```\n\n  \n\n\n\n## 怎么证明synchronized，Lock可重入\n\n- 在synchronize修饰的方法中调用synchronize修饰的方法，可以成功，即为可重入\n\n```java\npackage com.mk.learn.juc.lock;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-20 22:18\n **/\npublic class ReetrantLockDemo {\n\n    public static void main(String[] args) {\n        //synchronized可重入\n        Sport sport = new Sport();\n        new Thread(() -> {\n            sport.walk();\n        }, \"T1\").start();\n        new Thread(() -> {\n            sport.walk();\n        }, \"T2\").start();\n    }\n}\nclass Sport {\n\n    public synchronized void walk() {\n        try {\n            TimeUnit.SECONDS.sleep(4);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(Thread.currentThread().getName() + \": walking\");\n        run();\n    }\n\n    public synchronized void run() {\n        System.out.println(Thread.currentThread().getName() + \": running\");\n    }\n}\n```\n\n结果打印：\n\n```java\nT1: walking\nT1: running\nT2: walking\nT2: running\n\nProcess finished with exit code 0\n\n```\n\n\n\n- Lock可重入推荐查看AQS原理中ReentrantLock源码分析，自己思考怎么实现的可重入\n\n\n\n## 写一个死锁的代码\n\n### 怎么定位死锁？\n\n```java\npackage com.mk.learn.juc.lock;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 死锁\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-28 21:12\n **/\npublic class DeadLockDemo {\n\n    public static void main(String[] args) {\n        DeadLock deadLock = new DeadLock();\n\n        new Thread(() -> {\n            deadLock.getA();\n        }, \"A\").start();\n        new Thread(() -> {\n            deadLock.getB();\n        }, \"B\").start();\n\n\n    }\n}\n\nclass DeadLock {\n\n    private Object a = new Object();\n    private Object b = new Object();\n\n    public Object getA() {\n        synchronized (b) {\n            try {\n                System.out.println(Thread.currentThread().getName() + \"\\t持有\" + b + \",想要获得\" + a);\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (a) {\n                System.out.println(Thread.currentThread().getName() + \"\\t持有\" + a);\n            }\n            return a;\n        }\n    }\n\n    public Object getB() {\n        synchronized (a) {\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (b) {\n                System.out.println(Thread.currentThread().getName() + \"\\t持有\" + b);\n            }\n            return b;\n        }\n\n    }\n\n}\n```\n\n\n\n## 手写一个自旋锁\n\n- 什么是自旋锁？怎么理解？\n  - 自己在那里一直循环，知道满足条件为止。\n- 为什么用while不用if？\n  - 并发情况下，都不用if，用while。如果用if判断，当线程执行到if条件判断之后被挂起了，然后等到执行时，if条件已经不满足了。但是判定逻辑已经走过了，这样会继续执行if内的代码，导致数据结果错乱。用while每次被唤醒时都会先检查条件是否满足再继续。\n\n\n```java\npackage com.mk.learn.juc.lock;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * 自旋锁：循环比较获取直到成功为止,没有类似wait的阻塞\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-20 22:34\n **/\npublic class SpinLockDemo {\n\n    AtomicReference<Thread> atomicReference = new AtomicReference<>();\n\n    public void getLock() {\n        System.out.println(Thread.currentThread().getName() + \":try get lock\");\n\n        while (!atomicReference.compareAndSet(null, Thread.currentThread())) {\n        }\n    }\n\n    public void unLock() {\n        System.out.println(Thread.currentThread().getName() + \":release Lock\");\n        while (!atomicReference.compareAndSet(Thread.currentThread(), null)) {\n        }\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        SpinLockDemo demo = new SpinLockDemo();\n        new Thread(() -> {\n            demo.getLock();\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            demo.unLock();\n        }, \"t1\").start();\n        TimeUnit.SECONDS.sleep(1);\n        new Thread(() -> {\n            demo.getLock();\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            demo.unLock();\n        }, \"t2\").start();\n    }\n\n}\n\n```\n\n\n\n\n\n\n\n# 所有代码示例在github均可找到\n\n- 位置：https://github.com/mk-passby/mk_learn/tree/master/juc-demo/src/main/java/com/mk/learn/juc\n\n","tags":["JUC"]},{"title":"jvm常见问题","url":"/2020/08/20/JVM/jvm常见问题总结/","content":"\n#### JVM问题\n\n##### 1.默认内存大小？如何证明？\n\n​\t最小物理内存的1/64，最大物理内存的1/4，\n\n​\t通过指令查看：\n\n- Windows：java -XX:+PrintFlagsFinal -version | findstr  HeapSize\n- Linux：java -XX:+PrintFlagsFinal -version | grep HeapSize\n\n##### 2.堆为什么分新生代/老年代，为什么新生代1/3，老年代2/3？\n\n- 1.方便垃圾回收，新生代会频繁GC。\n- 2.老年代肯定比新生代大，Eden区90%的对象在第一次GC就被\n\n##### 3.为什么新生代老年代比例是1：2\n\n##### 4.为什么新生代要分三个区，且Eden，From，To为什么是8:1:1？\n\n​\t由于对象的生命周期不一样，出现了分代\n\n​\t基于一个经验值，根据统计调查发现Eden区90%~95%的对象在第一次GC就被回收掉，如果eden设置过低，会导致内存浪费\n\n##### 5.新生代的三个区是如何协同工作的？新生代是如何转移到老年代的\n\n- 1.对象首先在Eden中分配，如果eden中没有足够的空间会触发一次MinorGC。当Minor GC结束后，Eden区会被清空，存活的对象放入survivor中，且对象年龄计算器(Age)+1，当survivor中放不下，分配担保进入老年代中。\n\n##### 6.什么样的对象会进入老年代\n\n- 1.大对象，虚拟机提供了一个-XX:PretenureSizeThreshold参数(字节大小可以设分配到新生代对象的大小限制)，大于这个值的参数会直接在老年代分配。-XX:PretenureSizeThreshold默认值是0，即对象的大小超过Eden区的对象，直接进入老年代\n- 2.GC年龄超过15次还存活的对象\n- 3.空间分配担保的对象\n\n","tags":["jvm"]},{"title":"springcloud版本选型","url":"/2020/08/01/框架系列/springcloud/springcloud_1.版本选型/","content":"\n\n\n## Springboot版本选择\n\n- [SPRING-BOOT-git地址](https://github.com/spring-projects/spring-boot/releases/)\n\n- [SPRING-BOOT2.0新特性](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes)\n\n  ```properties\n  Spring Boot 2.0 Release Notes\n  Phillip Webb edited this page on 8 Jun · 1 revision\n  Upgrading from Spring Boot 1.5\n  Since this is a major release of Spring Boot, upgrading existing applications can be a little more involved that usual. We’ve put together a dedicated migration guide to help you upgrade your existing Spring Boot 1.5 applications.\n  \n  If you’re currently running with an earlier version of Spring Boot, we strongly recommend that you upgrade to Spring Boot 1.5 before migrating to Spring Boot 2.0.\n  ```\n\n  \n\n  ​\t**官方已建议springboot从1.5升级到2.0**\n\n## Springcloud版本选择\n\n- [springcloud-git地址](https://github.com/spring-projects/spring-cloud/wiki)\n\n- [springcloud 官网](https://spring.io/projects/spring-cloud)\n\n  ![](springcloud_1.版本选型\\clound官网.png)\n\n选择[Reference Doc.](https://docs.spring.io/spring-cloud/docs/Hoxton.SR7/reference/html/),如下:\n\n![](springcloud_1.版本选型\\cloudversion.png)\n\n\n\n\n\n## 更多查看springboot和springcloud方法\n\n[https://start.spring.io/actuator/info](https://start.spring.io/actuator/info)\n\n结果如下,查询结果是一个json串，如下所示\n\n```json\n{\"git\":{\"branch\":\"58cb6bccc1be3cdbe108a4609797c53010545926\",\"commit\":{\"id\":\"58cb6bc\",\"time\":\"2020-08-21T06:52:21Z\"}},\"build\":{\"version\":\"0.0.1-SNAPSHOT\",\"artifact\":\"start-site\",\"versions\":{\"spring-boot\":\"2.3.3.RELEASE\",\"initializr\":\"0.9.2-SNAPSHOT\"},\"name\":\"start.spring.io website\",\"time\":\"2020-08-21T07:23:55.515Z\",\"group\":\"io.spring.start\"},\"bom-ranges\":{\"azure\":{\"2.0.10\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.RELEASE\",\"2.1.10\":\"Spring Boot >=2.1.0.RELEASE and <2.2.0.M1\",\"2.2.4\":\"Spring Boot >=2.2.0.M1 and <2.3.0.M1\",\"2.3.1\":\"Spring Boot >=2.3.0.M1\"},\"codecentric-spring-boot-admin\":{\"2.0.6\":\"Spring Boot >=2.0.0.M1 and <2.1.0.M1\",\"2.1.6\":\"Spring Boot >=2.1.0.M1 and <2.2.0.M1\",\"2.2.4\":\"Spring Boot >=2.2.0.M1 and <2.3.0.M1\",\"2.3.0\":\"Spring Boot >=2.3.0.M1 and <2.4.0-M1\"},\"solace-spring-boot\":{\"1.0.0\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\",\"1.1.0\":\"Spring Boot >=2.3.0.M1\"},\"solace-spring-cloud\":{\"1.0.0\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\",\"1.1.1\":\"Spring Boot >=2.3.0.M1\"},\"spring-cloud\":{\"Finchley.M2\":\"Spring Boot >=2.0.0.M3 and <2.0.0.M5\",\"Finchley.M3\":\"Spring Boot >=2.0.0.M5 and <=2.0.0.M5\",\"Finchley.M4\":\"Spring Boot >=2.0.0.M6 and <=2.0.0.M6\",\"Finchley.M5\":\"Spring Boot >=2.0.0.M7 and <=2.0.0.M7\",\"Finchley.M6\":\"Spring Boot >=2.0.0.RC1 and <=2.0.0.RC1\",\"Finchley.M7\":\"Spring Boot >=2.0.0.RC2 and <=2.0.0.RC2\",\"Finchley.M9\":\"Spring Boot >=2.0.0.RELEASE and <=2.0.0.RELEASE\",\"Finchley.RC1\":\"Spring Boot >=2.0.1.RELEASE and <2.0.2.RELEASE\",\"Finchley.RC2\":\"Spring Boot >=2.0.2.RELEASE and <2.0.3.RELEASE\",\"Finchley.SR4\":\"Spring Boot >=2.0.3.RELEASE and <2.0.999.BUILD-SNAPSHOT\",\"Finchley.BUILD-SNAPSHOT\":\"Spring Boot >=2.0.999.BUILD-SNAPSHOT and <2.1.0.M3\",\"Greenwich.M1\":\"Spring Boot >=2.1.0.M3 and <2.1.0.RELEASE\",\"Greenwich.SR6\":\"Spring Boot >=2.1.0.RELEASE and <2.1.17.BUILD-SNAPSHOT\",\"Greenwich.BUILD-SNAPSHOT\":\"Spring Boot >=2.1.17.BUILD-SNAPSHOT and <2.2.0.M4\",\"Hoxton.SR7\":\"Spring Boot >=2.2.0.M4 and <2.3.4.BUILD-SNAPSHOT\",\"Hoxton.BUILD-SNAPSHOT\":\"Spring Boot >=2.3.4.BUILD-SNAPSHOT and <2.4.0.M1\",\"2020.0.0-SNAPSHOT\":\"Spring Boot >=2.4.0.M1\"},\"spring-cloud-alibaba\":{\"2.2.1.RELEASE\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\"},\"spring-cloud-services\":{\"2.0.3.RELEASE\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.RELEASE\",\"2.1.7.RELEASE\":\"Spring Boot >=2.1.0.RELEASE and <2.2.0.RELEASE\",\"2.2.3.RELEASE\":\"Spring Boot >=2.2.0.RELEASE and <2.3.0.M1\"},\"spring-statemachine\":{\"2.0.0.M4\":\"Spring Boot >=2.0.0.RC1 and <=2.0.0.RC1\",\"2.0.0.M5\":\"Spring Boot >=2.0.0.RC2 and <=2.0.0.RC2\",\"2.0.1.RELEASE\":\"Spring Boot >=2.0.0.RELEASE\"},\"vaadin\":{\"10.0.17\":\"Spring Boot >=2.0.0.M1 and <2.1.0.M1\",\"14.3.3\":\"Spring Boot >=2.1.0.M1 and <2.4.0-M1\"},\"wavefront\":{\"2.0.0\":\"Spring Boot >=2.1.0.RELEASE\"}},\"dependency-ranges\":{\"okta\":{\"1.2.1\":\"Spring Boot >=2.1.2.RELEASE and <2.2.0.M1\",\"1.4.0\":\"Spring Boot >=2.2.0.M1 and <2.4.0-M1\"},\"mybatis\":{\"2.0.1\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.RELEASE\",\"2.1.3\":\"Spring Boot >=2.1.0.RELEASE and <2.4.0-M1\"},\"geode\":{\"1.2.9.RELEASE\":\"Spring Boot >=2.2.0.M5 and <2.3.0.M1\",\"1.3.3.RELEASE\":\"Spring Boot >=2.3.0.M1 and <2.4.0-M1\",\"1.4.0-M2\":\"Spring Boot >=2.4.0-M1\"},\"camel\":{\"2.22.4\":\"Spring Boot >=2.0.0.M1 and <2.1.0.M1\",\"2.25.2\":\"Spring Boot >=2.1.0.M1 and <2.2.0.M1\",\"3.3.0\":\"Spring Boot >=2.2.0.M1 and <2.3.0.M1\",\"3.4.3\":\"Spring Boot >=2.3.0.M1 and <2.4.0-M1\"},\"open-service-broker\":{\"2.1.3.RELEASE\":\"Spring Boot >=2.0.0.RELEASE and <2.1.0.M1\",\"3.0.4.RELEASE\":\"Spring Boot >=2.1.0.M1 and <2.2.0.M1\",\"3.1.1.RELEASE\":\"Spring Boot >=2.2.0.M1 and <2.4.0-M1\"}}}\n\n```\n\n\n\n\n\n转换工具转换后：\n\n\n\n![转换后](springcloud_1.版本选型\\jsonVersion.png)\n\n\n\n## springcloud组件升级\n\nspringcloud停更，官网说明，不再发布新版本，不再接受合并请求\n\n| 组件    | 组件名  |  替换方案|\n|--------|--------|---------|\n|服务注册中心     | ~~Eureka(停更)~~ | Zookeeper/Consul/Nacos |\n|服务调用 | Ribbon | LoadBalancer |\n|服务调用2 | ~~Feign(停更)~~ | OpenFeign |\n|服务降级 | ~~Hystrix(停更)~~ | sentinel/resilience4j |\n|服务网关 | ~~Zuul(停更)~~ | gateway/Zuul2 |\n|服务配置 | ~~Config(停更)~~ | Nacos |\n|服务总线 | ~~Bus(停更)~~ | Nacos |\n| |  |  |\n\n\n\n## 补充，为避免版本差异所有总结均基于以下版本\n\n| 应用                | 版本          |\n| ------------------- | ------------- |\n| springcloud         | Hoxton.SR1    |\n| springboot          | 2.2.2.RELEASE |\n| springcloud alibaba | 2.1.0.RELEASE |\n| java                | 1.8           |\n| mysql               | 5.7(及以上)   |\n\n","tags":["springcloud"]},{"title":"JUC辅助类讲解","url":"/2020/07/25/JUC/JUC辅助类讲解/","content":"\n## CountDownLatch减少计数\n\n### 原理\n\n- CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。\n\n * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，\n * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。\n\n### 代码演示如下\n\n- t10打印“done”的await()和main方法await()需要等待其他线程执行完成后再打印\n\n```java\npackage com.mk.learn.juc.concureenttools;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-21 21:57\n **/\npublic class CountDownLatchDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch = new CountDownLatch(5);\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \" is running\");\n            try {\n                countDownLatch.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \" done\");\n        }, \"t10\").start();\n        for (int i = 0; i <5 ; i++) {\n            TimeUnit.SECONDS.sleep(2);\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName() + \" is running\");\n                countDownLatch.countDown();\n                System.out.println(Thread.currentThread().getName() + \" done\");\n            }, \"t\"+i).start();\n\n        }\n        countDownLatch.await();\n        System.out.println(\"end-----------------\");\n\n    }\n}\n```\n\n- 结果如下\n\n```java\nt10 is running\nt0 is running\nt0 done\nt1 is running\nt1 done\nt2 is running\nt2 done\nt3 is running\nt3 done\nt4 is running\nt4 done\nt10 done\nend-----------------\n\nProcess finished with exit code 0\n```\n\n## CyclicBarrier循环栅栏\n\n### 原理\n\n * CyclicBarrier\n * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，\n * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，\n * 直到最后一个线程到达屏障时，屏障才会开门，所有\n * 被屏障拦截的线程才会继续干活。\n * 线程进入屏障通过CyclicBarrier的await()方法。\n\n### 代码演示\n\n- 代码\n\n```java\npackage com.mk.learn.juc.concureenttools;\n\nimport java.util.concurrent.BrokenBarrierException;\nimport java.util.concurrent.CyclicBarrier;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 循环屏障，所有的线程都到达后会一起唤醒\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-21 22:44\n **/\npublic class CyclicBarrierDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        CyclicBarrier cyclicBarrier=new CyclicBarrier(5);\n        for (int i = 0; i <10 ; i++) {\n            TimeUnit.SECONDS.sleep(1);\n            new Thread(() -> {\n                System.out.println(Thread.currentThread().getName()+\":come in\");\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName()+\":end\");\n            }, \"t\"+i).start();\n        }\n    }\n\n}\n\n```\n\n\n\n- 结果\n\n```java\nt0:come in\nt1:come in\nt2:come in\nt3:come in\nt4:come in\nt4:end\nt0:end\nt1:end\nt2:end\nt3:end\nt5:come in\nt6:come in\nt7:come in\nt8:come in\nt9:come in\nt9:end\nt5:end\nt6:end\nt7:end\nt8:end\n```\n\n\n\n## Semaphore信号灯\n\n### 原理\n\n 在信号量上我们定义两种操作：\n * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），\n *       要么一直等下去，直到有线程释放信号量，或超时。\n * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。\n * \n * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\n\n\n### 代码演示\n\n- 代码(该例子模拟停车，停一段时间后离开，代码可以通过调整停车的时间(sleep的时间)，这样更能看出semaphore的效果)\n\n```java\npackage com.mk.learn.juc.concureenttools;\n\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * 信号量，表示只能允许多少个线程同时运行(并发线程数的控制)\n *\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-07-21 22:55\n **/\npublic class SemaphoreDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        Semaphore semaphore = new Semaphore(3);\n        for (int i = 0; i < 7; i++) {\n            new Thread(() -> {\n                try {\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName()+\":进入，占用3秒\" );\n                    TimeUnit.SECONDS.sleep(3);\n                    System.out.println(Thread.currentThread().getName() + \":离开\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release();\n                }\n            }, \"t\" + i).start();\n        }\n    }\n}\n\n```\n\n\n\n- 结果\n\n```java\nt0:进入，占用3秒\nt2:进入，占用3秒\nt1:进入，占用3秒\nt0:离开\nt2:离开\nt3:进入，占用3秒\nt1:离开\nt4:进入，占用3秒\nt5:进入，占用3秒\nt3:离开\nt4:离开\nt5:离开\nt6:进入，占用3秒\nt6:离开\n```\n\n## 代码位置\n\n- github:\n\nhttps://github.com/mk-passby/mk_learn/tree/master/juc-demo/src/main/java/com/mk/learn/juc/concureenttools","tags":["JUC"]},{"title":"Callable接口","url":"/2020/07/20/JUC/Callable接口/","content":"\n## Callable是什么\n\n### 获得多线程的方法几种\n\n- 传统的是继承thread类和实现runnable接口\n- java5以后又有实现callable接口和java的线程池获得\n\n```java\npublic class ThreadDemo {\n\n    public static void main(String[] args) {\n        new Thread1().start();\n        new Thread(new Runnable1()).start();\n        FutureTask task = new FutureTask(new Callable1());\n        new Thread(task).start();\n    }\n}\n\nclass Thread1 extends Thread {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread1 start\");\n    }\n}\n\n\nclass Runnable1 implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread2 start\");\n    }\n}\n\nclass Callable1 implements Callable<Integer> {\n\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName() + \"Thread3 start\");\n        return 0;\n    }\n}\n```\n\n- 结果\n\n```java\nThread-0Thread1 start\nThread-1Thread2 start\nThread-2Thread3 start\n\nProcess finished with exit code 0\n```\n\n\n\n### 与runnable对比\n\n       （1）是否有返回值\n       （2）是否抛异常\n       （3）落地方法不一样，一个是run，一个是call\n```java\nclass MyThread2 implements Callable<Integer>{\n @Override\n public Integer call() throws Exception {\n  return 200;\n } \n}\n```\n\n### 如何获得返回值\n\n- FutureTask.get()\n\n```java\n        FutureTask task = new FutureTask(new Callable1());\n        new Thread(task).start();\n        System.out.println(task.get());\n```\n\n## FutureTask\n\n### 原理\n\n- 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，\n  当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。\n\n  一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。\n\n  仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，\n  就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，\n  然后会返回结果或者抛出异常。 \n\n  只计算一次\n  get方法放到最后\n\n### 验证get 方法阻塞 \n\n- 这个验证就很简单了，在线程里阻塞几秒后，在返回结果，即可查看到\n\n```java\npublic class ThreadDemo {\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        new Thread1().start();\n        new Thread(new Runnable1()).start();\n        FutureTask task = new FutureTask(new Callable1());\n        new Thread(task).start();\n        System.out.println(task.get());\n    }\n}\n\nclass Thread1 extends Thread {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread1 start\");\n    }\n}\n\n\nclass Runnable1 implements Runnable {\n\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \"Thread2 start\");\n    }\n}\n\nclass Callable1 implements Callable<Integer> {\n\n    @Override\n    public Integer call() throws Exception {\n        TimeUnit.SECONDS.sleep(5);\n        System.out.println(Thread.currentThread().getName() + \"Thread3 start\");\n        return 0;\n    }\n}\n```\n\n\n\n- 通过控制台可以看到Thread-0Thread1 start和Thread-1Thread2 start很快就打印出来了，但是FutureTask显示sleep了几秒才返回","tags":["JUC"]},{"title":"不安全集合","url":"/2020/07/20/JUC/不安全集合/","content":"\n## 多线程环境下不安全集合类\n\n- 这些集合包括我们常用的ArrayList，HashMap，StringBuilder等等\n\n### 不安全是指什么\n\n- ArrayList在迭代的时候如果同时对其进行修改就会\n  抛出java.util.ConcurrentModificationException异常\n  并发修改异常\n- 代码验证\n\n```java\npackage com.mk.learn.juc.thread;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @program: learning-demo\n * @description:\n * @author: mk_passby\n * @create: 2020-08-30 22:31\n **/\npublic class UnSafeDemo {\n\n    public static void main(String[] args) throws InterruptedException {\n        List<Double> list = new ArrayList<>();\n        //线程不安全\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                list.add(Math.random() * 1000);\n                System.out.println(list);\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n\n```\n\n- 结果\n\n```java\nException in thread \"4\" Exception in thread \"3\" Exception in thread \"2\" Exception in thread \"0\" java.util.ConcurrentModificationException\n\tat java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)\n\tat java.util.ArrayList$Itr.next(ArrayList.java:851)\n\tat java.util.AbstractCollection.toString(AbstractCollection.java:461)\n\tat java.lang.String.valueOf(String.java:2994)\n\tat java.io.PrintStream.println(PrintStream.java:821)\n\tat com.mk.learn.juc.thread.UnSafeDemo.lambda$main$0(UnSafeDemo.java:28)\n\tat java.lang.Thread.run(Thread.java:748)\n\n```\n\n### ArrayList不安全，那么怎么解决呢\n\n#### Vector\n\n- 看Vector的源码，有synchronized修饰线程安全\n\n```java\n   public synchronized boolean add(E e) {\n        modCount++;\n        ensureCapacityHelper(elementCount + 1);\n        elementData[elementCount++] = e;\n        return true;\n    }\n```\n\n#### Collections\n\n```java\nList<String> list = Collections.synchronizedList(new ArrayList<>());\n```\n\nCollections提供了方法synchronizedList保证list是同步线程安全的\n\n```java\n public static <T> List<T> synchronizedList(List<T> list) {\n        return (list instanceof RandomAccess ?\n                new SynchronizedRandomAccessList<>(list) :\n                new SynchronizedList<>(list));\n    }\n```\n\n\n\n#### 写时复制\n\n```java\nList<String> list = new CopyOnWriteArrayList<>();\n```\n\n- CopyOnWriteArrayList是arraylist的一种线程安全变体，\n  其中所有可变操作（add、set等）都是通过生成底层数组的新副本来实现的。\n\n- CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，\n  而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。\n  添加元素后，再将原容器的引用指向新的容器setArray(newElements)。\n  这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。\n- CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。\n\n### 扩展对比\n\n#### SET\n\n- Set<String> set = new HashSet<>();//线程不安全\n\n- Set<String> set = new CopyOnWriteArraySet<>();//线程安全\n\n#### HASHMAP\n\n- Map<String,String> map = new HashMap<>();//线程不安全\n\n- Map<String,String> map = new ConcurrentHashMap<>();//线程安全","tags":["JUC"]},{"title":"常见算法排序","url":"/2020/03/29/算法/常见算法排序/","content":"\n\n[TOC]\n\n\n\n## 一、插入排序\n\n**思路**\n\n对于未排序的数据，从第1位从后往前扫描，取出元素，和前面的元素对比，若当前元素小于前一元素，则将前一元素后移，当前元素继续与前两个位置的元素比较，直到找出大于或等于的元素位置，将该元素插入到对应位置\n\n```java\nprivate static int[] insertSort(int[] a) {\n        for (int i = 1; i < a.length; i++) {\n            int temp = a[i];\n            int tempIndex = i;\n            while (tempIndex > 0 && temp < a[tempIndex-1]) {\n                a[tempIndex] = a[tempIndex-1];\n                tempIndex--;\n            }\n            a[tempIndex] = temp;\n        }\n        return a;\n    }\n```\n\n![插入排序](常见算法排序/插入排序.gif)\n\n\n\n# 个人简介\n\n## 二、希尔(Shell )排序\n\n**思路**\n\n将整个待排序序列分成若干个子序列分别进行直接插入排序\n\n- 选择一个增量Tn，其中Tn>1\n- 按增量序列数n，对序列进行n趟排序\n- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序。仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n![](常见算法排序/shellSort.PNG)\n\n**代码**\n\n```java\n /**\n     * 希尔排序交换法\n     */\n    private static void shellSortByChange(int[] arr) {\n        //遍历步长，按每次除以2遍历\n        for (int gap = arr.length / 2; gap > 0; gap /= 2) {\n            //从第gap个元素开始全部遍历\n            for (int i = gap; i < arr.length; i++) {\n                //当前元素以gap的步长进行遍历\n                //与前面的元素比较，如果当前元素更小，则替换(此处类似冒泡的替换)\n                for (int j = i - gap; j >= 0; j -= gap) {\n                    if (arr[j] > arr[j + gap]) {\n                        int temp = arr[j];\n                        arr[j] = arr[j + gap];\n                        arr[j + gap] = temp;\n                    }\n                }\n            }\n        }\n    }\n\n /**\n     * 希尔排序: 对有序序列在插入时采用移动法\n     */\n    public static void shellSort2(int[] arr) {\n        // 增量gap，并逐步缩小增量\n        for (int gap = arr.length / 2; gap > 0; gap /= 2) {\n            // 从第gap个元素，逐个对其所在组进行直接插入排序操作\n            for (int i = gap; i < arr.length; i++) {\n                int j = i;\n                int temp = arr[j];\n                if (arr[j] < arr[j - gap]) {\n                    while (j - gap >= 0 && temp < arr[j - gap]) {\n                        // 移动法\n                        arr[j] = arr[j - gap];\n                        j -= gap;\n                    }\n                    arr[j] = temp;\n                }\n            }\n        }\n    }\n```\n\n\n\n\n\n**动图**\n\n ![希尔排序](常见算法排序/希尔排序.gif)\n\n\n## 三、选择排序\n\n**思路：**\n\n全部遍历找到最小值与第0个元素交换，再从第一个位置开始往后找到最小的，与第1个元素交换，再从第二个位置开始往后找到最小的与第2个元素交换，直到选到最后一个元素\n\n**代码**\n\n```java\n private static int[] selectedSort(int[] a) {\n        for (int i = 0; i < a.length - 1; i++) {\n            int minIndex = i;\n            for (int j = i + 1; j < a.length; j++) {\n                if (a[minIndex] > a[j]) {\n                    minIndex = j;\n                }\n            }\n            int temp = a[i];\n            a[i] = a[minIndex];\n            a[minIndex] = temp;\n        }\n        return a;\n    }\n```\n\n**动图**\n\n![快速排序](常见算法排序/选择排序.gif)\n\n\n\n## 四、堆排序\n\n**动图**\n\n![快速排序](常见算法排序/堆排序.gif)\n\n## 五、冒泡排序\n\n**思路**\n\n- 相邻的元素比较，将较大的放在后面。那么：\n- 第一次排序遍历后，会把最大的数放到最后面\n- 第二次排序遍历后，会把第二大的数放到倒数第二位\n- 第三次排序遍历后....\n\n**代码实现**\n\n```java\npublic class BubbleDemo {\n\n    /**\n     * 思路：\n     * 第一次排序，把最大的数放到最后面\n     * 第二次排序，把第二大的数放到倒数第二位\n     * ....\n     * @param args\n     */\n    public static void main(String[] args) {\n        int[] arr = {3, 9, -1, 10, 20};\n        bubbleSort(arr);\n        System.out.println(\"冒泡排序后的结果为：\" + Arrays.toString(arr));\n\n    }\n\n    private static void bubbleSort(int[] arr) {\n        int temp=0;\n        for (int i = 0; i < arr.length-1; i++) {\n            //第一次需要遍历arr.length-0-1次\n            //第二次需要遍历arr.length-1-1次，因为最后一位已经有序\n            //第二次需要遍历arr.length-2-1次，因为最后两位已经有序\n            for (int j = 0; j < arr.length-i-1; j++) {\n                //如果前面比后面大，就交换\n                if (arr[j]>arr[j+1]) {\n                    temp=arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=temp;\n                }\n            }\n        }\n    }\n}\n```\n\n\n**动图**\n\n![快速排序](常见算法排序/冒泡排序.gif)\n\n\n## 六、快速排序\n\n- 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列\n\n![](常见算法排序/quickSort.jpg)\n\n**代码**\n\n```java\nprivate static void quickSort(int[] arr, int left, int right) {\n        int l = left;\n        int r = right;\n        //中轴值\n        int pivot = arr[(left + right) / 2];\n        int temp;\n        //比pivot大的放右边，小的放左边\n        while (l < r) {\n            while (arr[l] < pivot) {\n                ++l;\n            }\n            while (arr[r] > pivot) {\n                --r;\n            }\n            //if (l>=r)说明左边全部小于，右边全部大于，已经满足了\n            if (l >= r) {\n                break;\n            }\n            temp = arr[l];\n            arr[l] = arr[r];\n            arr[r] = temp;\n            // 如果交换后，发现这个值和pivot相等，可以r--,前移一步\n            if (arr[l] == pivot) {\n                r -= 1;\n            }\n            // 如果交换后，发现这个值和pivot相等，可以l--,后移一步\n            if (arr[r] == pivot) {\n                l += 1;\n            }\n\n        }\n// 如果 l==r 还可以让 l++， r--下.\n        if (l == r) {\n            l += 1;\n            r -= 1;\n        }\n        // 向左递归\n        if (left < r) {\n            quickSort(arr, left, r);\n        }\n        // 向右递归\n        if (right > l) {\n            quickSort(arr, l, right);\n        }\n    }\n```\n\n\n\n**动图**\n\n![快速排序](常见算法排序/快速排序.gif)\n\n\n## 七、归并排序\n\n可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程\n\n再来看看**治**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤\n\n![](常见算法排序/分治.png)\n\n**代码**\n\n```java\npublic class MergeSortDemo {\n\n    public static void main(String[] args) {\n        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2, 1};\n        //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间\n        int[] temp = new int[arr.length];\n        mergeSort(arr, 0, arr.length - 1, temp);\n\n        System.out.println(Arrays.toString(temp));\n\n\n    }\n\n    public static void mergeSort(int[] arr, int left, int right, int[] temp) {\n        if (left < right) {\n            int mid = (left + right) / 2;\n            mergeSort(arr, left, mid, temp);// 左边归并排序，使得左子序列有序\n            mergeSort(arr, mid + 1, right, temp);// 右边归并排序，使得右子序列有序\n            merge(arr, left, mid, right, temp);// 将两个有序子数组合并操作\n        }\n    }\n\n    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {\n        int i = left; //左序列指针/索引\n        int j = mid + 1;//右序列指针\n        int t = 0; //临时数组指针\n        while (i <= mid && j <= right) {\n            if (arr[i] <= arr[j]) {\n                temp[t] = arr[i];\n                t += 1;\n                i += 1;\n            } else {\n\n                temp[t] = arr[j];\n                t += 1;\n                j += 1;\n            }\n        }\n        while (i <= mid) {//将左边剩余元素填充进temp中\n            temp[t] = arr[i];\n            t += 1;\n            i += 1;\n        }\n        while (j <= right) {//将右序列剩余元素填充进temp中\n\n            temp[t] = arr[j];\n            t += 1;\n            j += 1;\n        }\n        t = 0;\n        //将temp中的元素全部拷贝到原数组中\n        //因为left 是val 因此使用一个临时变量\n        int tempLeft = left;\n        while (tempLeft <= right) {\n            arr[tempLeft] = temp[t];\n            t += 1;\n            tempLeft += 1;\n        }\n    }\n\n}\n\n```\n\n\n\n**动图**\n\n![快速排序](常见算法排序/归并排序.gif)\n\n## 八、计数排序\n\n\n**动图**\n\n![快速排序](常见算法排序/计数排序.gif)\n## 九、桶排序\n\n- 见基数排序\n\n\n\n**动图**\n\n![快速排序](常见算法排序/桶排序.png)\n\n## 十、基数排序\n\n- 基数排序是桶排序的扩展，所以桶排序不在做过多介绍\n\n- 基数排序：将整数按位数切割成不同的数字，然后按每个位数分别比较。\n- 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n\n- 桶排序是典型的空间换时间，使用过程中需注意内存溢出的风险\n\n**代码**\n\n```java\n/**\n     * 基数排序\n     */\n    public static void radixSort(int[] arr) {\n        // 假定arr[0] 是最大数\n        // 1. 通过遍历arr, 找到数组中真正最大值\n        // 2. 目的是确定要进行多少轮排序\n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        // 计算最大数字是几位数\n        int maxLength = (max + \"\").length();\n        // 定义一个二维数组， 就是10个桶\n        // 1. 该二维数组有10个一维数组 0-9\n        // 2. 为了防止溢出，每个一维数组(桶)，大小定为 arr.length\n        // 3. 很明确, 基数排序是空间换时间\n        int[][] bucket = new int[10][arr.length];\n        // 用于记录在每个桶中，实际存放了多少个数据,这样才能正确的取出\n        int[] bucketElementCounts = new int[10];\n        // 根据最大长度的数决定比较的次数\n        // 1. 大循环的次数就是 最大数有多少位,前面分析过\n        // 2. n = 1, n *= 10 是为了每轮循环排序时，分别求出各个元素的 个位，十位，百位，千位 ...\n        //    就是一个小算法\n        // 3. 这个基础排序，完全可以使用 冒泡分步写代码来完成，比较简单!!\n        for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {\n            // 把每一个数字分别计算本轮循环的位数的值,比如第1轮是个位...\n            for (int j = 0; j < arr.length; j++) {\n                // 计算\n                int digitOfElement = arr[j] / n % 10;\n                // 把当前遍历的数据放入指定的数组中\n                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];\n                // 记录数量\n                bucketElementCounts[digitOfElement]++;\n            }\n            // 记录取的元素需要放的位置\n            int index = 0;\n            // 把各个桶中(10个桶)存放的数字取出来, 放入到arr中\n            for (int k = 0; k < bucketElementCounts.length; k++) {\n                // 如果这个桶中，有数据才取，没有数据就不取了\n                if (bucketElementCounts[k] != 0) {\n                    // 循环取出元素\n                    for (int l = 0; l < bucketElementCounts[k]; l++) {\n                        // 取出元素\n                        arr[index++] = bucket[k][l];\n                    }\n                    // 把这个桶的对应的记录的数据个数置为0,注意,桶本身数据(前面存的数据还在)\n                    bucketElementCounts[k] = 0; //\n                }\n            }\n        }\n    }\n```\n\n\n\n**动图**\n\n![快速排序](常见算法排序/基数排序.gif)\n","tags":["数据结构和算法"]},{"title":"算法复杂度","url":"/2020/03/29/算法/算法复杂度/","content":"\n\n\n# 算法复杂度\n\n## 1.怎么分析算法复杂度\n\n#### 一、时间复杂度\n\n所有代码的**执行时间 T(n)** 与每行代码的**执行次数 n** 成正比.\n\n\n```math\nT(n)=O(f(n))\n```\n\n\n- T(n)：所有代码执行的总时间\n- n：数据规模大小\n- f(n)：每行代码执行的次数总和\n\n\n\n##### 常量阶O(1)\n\n无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)\n\n```java\n  \t\tint i=6;\n        int j=5;\n        ++i;\n        j++;\n        int x=i+j;\n```\n\n代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。\n\n\n\n##### 对数阶O(log~2~n)\n\n- 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log~2~n也就是说当循环 log~2~n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log~2~n)  。 O(log~2~n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log~3~n) .\n\n```java\n \t   int i=1;\n       while (i<n){\n           i=i*2;\n       }\n```\n\n##### 线性阶O(n)\n\n- for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度\n\n```java\n \t\tint i=1;\n        for (int j = 0; j < n; j++) {\n            i++;\n        }\n```\n\n##### 线性对数阶O(nlog~2~N)\n\nO(log~2~n)的代码执行n次，即是nlog~2~N。原理就是一个嵌套循环\n\n```java\n\t\tint i;\n        for (int m=1; m < n; m++) {\n            i=1;\n            while (i<n){\n                i=i*2;\n            }\n        }\n```\n\n\n\n##### 平方阶O(n²)\n\n嵌套for循环，单层for循环是O(n)，嵌套为O(n^2^)\n\n```java\n   for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                a++;\n            }\n        }\n```\n\n\n\n##### 其他\n\n立方阶O(n³)、K次方阶O(n^k^)类似，也只是一堆基础的嵌套而已\n\n\n\n----\n\n**时间复杂度分析**\n\n- 关注循环次数最多的一段代码\n  - 通常会忽略常熟，系数等，只记录最大的一个量级即可\n  - 只关注执行次数最多的一段代码即可\n  \n- 加法法则：总的时间复杂度等于量级最大的代码的时间复杂度\n  \n  - 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))\n  \n- 乘法法则：嵌套代码的复杂度等于嵌套代码内外复杂度的乘积\n  \n  - 如果 T1(n)=O(f(n)), T2(n)=O(g(n))，那么 T1(n)*T2(n)=O(f(n)) * O(g(n))=O(f(n)*g(n)) 也就是说，假设T1(n)=O(n),T2(n)=O(n^2)，则有T1(n) * T2(n)=O(n^3)\n  \n  \n  **例:**\n  \n  ```java\n   public int getSum(int n){\n          int sum=0;\n          for (int i = 1; i <= n; i++) {\n              sum+=i;\n          }\n          return sum;\n          \n      }\n  ```\n  \n  结论：常量级第二行不考虑，执行次数最多的是for循环，所以时间复杂度为O(n)\n  \n#### 二、空间复杂度\n\n\n- 空间复杂度：表示算法的**存储空间**与**数据规模**之间的增长关系\n\n**例：**\n\n```java\n public int getSum(int n){\n        int sum=0;\n        int[] a=new int[n];\n        for (int i = 1; i <= a.length; i++) {\n            sum+=i;\n        }\n        return sum;\n\n    }\n```\n\n结论：int sum=0为常量阶，可以忽略，其余的仅int[] a=new int[n]申请了内存，所以空间复杂度为O(n)\n\n#### 3）算法稳定性\n\n假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的\n\n## 2.最好，最坏，平均，均摊时间复杂度\n\n- 最好时间复杂度：最好情况的时间复杂度\n- 最坏时间复杂度：最坏情况的时间复杂度\n- 平均时间复杂度：将所有情况用加权平均值表示，通常没说权值默认是均分，即除以情况种数\n- 均摊时间复杂度：在代码执行的所有复杂度情况中，大部分情况下时间复杂度都很低，只有极个别情况下的时间复杂度比较高，而且发生具有**前后连贯的时序关系**时，可以将个别高级别复杂度均摊到低级别复杂度上。均摊结果一般都等于**低级别复杂度**\n\n# 3.常见的时间复杂度\n\n![时间复杂度](算法复杂度/1.png)\n\n# 4.算法复杂度的比较\n\n1)常数阶O(1)\n\n2)对数阶O(log~2~n)\n\n3)线性阶O(n)\n\n4)线性对数阶O(nlog~2~n)\n\n5)平方阶O(n^2^)   \n\n6)立方阶O(n^3^)\n\n7)k次方阶O(n^k^)\n\n8)指数阶O(2^n^)\n\n![](算法复杂度/2.png)\n\n\n\n\n\n\n\n- 常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log~2~n)＜Ο(n)＜Ο(nlog~2~n)＜Ο(n^2^)＜Ο(n^3^)＜ Ο(n^k^) ＜Ο(2^n^) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低\n- 从图中可见，我们应该尽可能**避免使用指数阶的算法**","tags":["数据结构和算法"]},{"title":"springmvc分析","url":"/2020/03/27/框架系列/springMVC/springMVC/","content":"\n# 官网文档\n\nhttps://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html\n\nspring所有官方文档均可以通过此方式找到\n\n# 架构图\n\n![1587994841538](springMVC\\springMVC架构图1.png)\n\n\n\n- 由图中可以看到，DispatcherServlet中又分了Servlet WebApplicationContext和Root WebApplicationContext，且Servlet WebApplicationContext属于上层，if no bean found，才去找root。\n\n  - **Root WebApplicationContext**对应ContextLoaderListener(extends ServletContextListener)创建，对应**spring应用**\n\n  **源码ContextLoaderListener.java**\n\n  ```java\n  \n  public void contextInitialized(ServletContextEvent event) {\n          this.initWebApplicationContext(event.getServletContext());\n      }\n  ```\n\n  ```java\n   public WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n          if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n              throw new IllegalStateException(\"Cannot initialize context because there is already a root application context present - check whether you have multiple ContextLoader* definitions in your web.xml!\");\n          } else {\n              .....\n          }\n      }\n  ```\n\n  \n\n  - **Servlet WebApplicationContext**对应为DispatcherServlet，对应**springmvc应用**\n\n    源码如下RequestContextUtils.java\n\n    ```java\n    public static WebApplicationContext findWebApplicationContext(\n    \t\t\tHttpServletRequest request, @Nullable ServletContext servletContext) {\n    \n    \t\tWebApplicationContext webApplicationContext = (WebApplicationContext) request.getAttribute(\n    \t\t\t\tDispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);\n    \t\tif (webApplicationContext == null) {\n    \t\t\tif (servletContext != null) {\n    \t\t\t\twebApplicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);\n    \t\t\t}\n    \t\t\tif (webApplicationContext == null) {\n    \t\t\t\twebApplicationContext = ContextLoader.getCurrentWebApplicationContext();\n    \t\t\t}\n    \t\t}\n    \t\treturn webApplicationContext;\n    \t}\n    ```\n\n    \n\n\n\n![](springMVC\\springMVC架构图.png)\n\n\n\n## 关键类\n\norg.springframework.web.servlet.DispatcherServlet类关系图\n\n![sss](springMVC\\DispatcherServlet.png)\n\n\n\norg.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration自动装配\n\norg.springframework.boot.autoconfigure.web.servlet.WebMvcProperties配置类(springboot中可以通过这些参数设置springpropoties文件中)\n\n\n\n\n\n### 基于javaconfig\n\nBelow is an example of the Java configuration that registers and initializes the `DispatcherServlet`. This class is auto-detected by the Servlet container (see [Code-based, Servlet container initialization](https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-container-config)):\n\n```\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n  @Override\n  public void onStartup(ServletContext servletCxt) {\n\n    // Load Spring web application configuration\n    AnnotationConfigWebApplicationContext cxt = new AnnotationConfigWebApplicationContext();\n    cxt.register(AppConfig.class);\n    cxt.refresh();\n\n    // Create DispatcherServlet\n    DispatcherServlet servlet = new DispatcherServlet(cxt);\n\n    // Register and map the Servlet\n    ServletRegistration.Dynamic registration = servletCxt.addServlet(\"app\", servlet);\n    registration.setLoadOnStartup(1);\n    registration.addMapping(\"/app/*\");\n  }\n\n}\n```\n\n### 基于web.xml\n\nBelow is an example of `web.xml` configuration to register and initialize the `DispatcherServlet`:\n\n```\n<web-app>\n\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>/WEB-INF/app-context.xml</param-value>\n  </context-param>\n\n  <servlet>\n    <servlet-name>app</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value></param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n\n  <servlet-mapping>\n    <servlet-name>app</servlet-name>\n    <url-pattern>/app/*</url-pattern>\n  </servlet-mapping>\n\n</web-app>\n```\n\n\n\n\n\n## 整体流程\n\nrequest--》Handler--》结果--》返回--》文本\n\n根据请求的 URL，寻找匹配的Handler，处理数据，返回结果\n\nRequestUrl=servletContext+requestMapping\n\n#### 请求处理映射\n\nRequestMappingHandlerMapping.java类处理\n\n```java\nMap<RequestMappingInfo, HandlerMethod> handlerMethods =requestMappingHandlerMapping.getHandlerMethods();\n```\n\n这个方法可以获取所有类中被@RequestMapping标注过的方法的对象\n\n#### 拦截器\n\n- 实现HandlerInterceptor接口\n\n- 继承`HandlerInterceptorAdapter` \n\nspring官网如下解释，更推荐使用`HandlerInterceptorAdapter` \n\n```\nAs you can see, the Spring adapter class HandlerInterceptorAdapter makes it easier to extend the HandlerInterceptor interface.\n```\n\n\n\n This is shown in the example below:\n\n```xml\n<beans>\n        <bean id=\"handlerMapping\"\n                        class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\">\n                <property name=\"interceptors\">\n                        <list>\n                                <ref bean=\"officeHoursInterceptor\"/>\n                        </list>\n                </property>\n        </bean>\n\n        <bean id=\"officeHoursInterceptor\"\n                        class=\"samples.TimeBasedAccessInterceptor\">\n                <property name=\"openingTime\" value=\"9\"/>\n                <property name=\"closingTime\" value=\"18\"/>\n        </bean>\n</beans>\n```\n\n\n\n\n\n```java\npackage samples;\n\npublic class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {\n\n        private int openingTime;\n        private int closingTime;\n\n        public void setOpeningTime(int openingTime) {\n                this.openingTime = openingTime;\n        }\n\n        public void setClosingTime(int closingTime) {\n                this.closingTime = closingTime;\n        }\n\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response,\n                        Object handler) throws Exception {\n                Calendar cal = Calendar.getInstance();\n                int hour = cal.get(HOUR_OF_DAY);\n                if (openingTime <= hour && hour < closingTime) {\n                        return true;\n                }\n                response.sendRedirect(\"http://host.com/outsideOfficeHours.html\");\n                return false;\n        }\n}\n```\n\n\n\n\n\n","tags":["springmvc"]},{"title":"序列化","url":"/2019/07/20/开发相关/序列化/","content":"\n\n## 实现一个序列化\n\n1.实现Serializable接口\n\n2.ObjectInputStream、ObjectOutputSream\n\n\n\n- 深拷贝：复制对应的所有变量和引用对应的实例，即引用对象为一个新对象而不是原来的对象\n\n  - 实现Cloneable接口，且重写clone()方法，将对象的引用克隆一次，传值\n\n    ```JAVA\n     \t@Override\n        public Object clone() throws CloneNotSupportedException {  \t\t\n    \t\t// 调用父类clone接口复制变量：\n            Student3 student = (Student3) super.clone();\n            // 本来是浅复制，现在将Teacher对象复制一份并重新set进来\n            student.setTeacher((Teacher2) student.getTeacher().clone());\n            return student;\n        }\n    \n    ```\n\n  - 序列化实现深克隆\n\n    ```java\n    public Object deepClone() throws IOException, ClassNotFoundException {\n            //序列化\n            ByteArrayOutputStream baos=new ByteArrayOutputStream();\n            ObjectOutputStream oos=new ObjectOutputStream(baos);\n    \n            oos.writeObject(this);\n    \n            //反序列化\n            ByteArrayInputStream bais=new \t\t\t\t\t\tByteArrayInputStream(baos.toByteArray());\n            ObjectInputStream ois=new ObjectInputStream(bais);\n            return ois.readObject();\n        }\n    ```\n\n    \n\n- 浅拷贝：复制对象的所有变量，但是引用的对象还是以前的对象。\n  \n  - 实现Cloneable接口，直接调用clone()方法\n\n## 序列化技术：\n\n- JACKSON\n\n\n```XML\n\t\t<dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-mapper-asl</artifactId>\n            <version>1.9.13</version>\n        </dependency>\n```\n\n  ```JAVA\nObjectMapper mapper=new ObjectMapper();\n          byte[] writeBytes=null;\n          Long start=System.currentTimeMillis();\n          writeBytes=mapper.writeValueAsBytes(person);//序列化\n          Person person1=mapper.readValue(writeBytes,Person.class);//反序列化\n          System.out.println(person1);\n  ```\n\n  - FastJson\n\n```XML\n        <dependency>\n            <groupId>com.alibaba</groupId>\n            <artifactId>fastjson</artifactId>\n            <version>1.2.31</version>\n        </dependency>\n```\n\n```JAVA\nString result=JSON.toJSONString(person);//序列化\nPerson person=JSON.parseObject(text,Person.class);//反序列化\n```\n\n  - ProtoBuf\n\n```java\npublic class Person implements Serializable{\n\tprivate static final long serialVersionUID = 5711515415445643416L;\n    @Protobuf(fieldType = FieldType.STRING,order = 1)\n    private String name;\n\n    @Protobuf(fieldType = FieldType.INT32,order = 2)\n    private int age;\n```\n\n```xml\n        <dependency>\n            <groupId>com.baidu</groupId>\n            <artifactId>jprotobuf</artifactId>\n            <version>2.1.2</version>\n        </dependency>\n```\n\n```JAVA\nCodec<Person> personCodec= ProtobufProxy.create(Person.class,false);//此处较耗时\nbyte[] bytes=personCodec.encode(person);//序列化\nPerson person1=personCodec.decode(bytes);//反序列化\n```\n\n  - Hession\n\n```XML\n        <dependency>\n            <groupId>com.caucho</groupId>\n            <artifactId>hessian</artifactId>\n            <version>4.0.38</version>\n        </dependency>\n```\n\n```java\nByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\nHessianOutput ho=new HessianOutput(byteArrayOutputStream);\nho.writeObject(person);//序列化\n\nHessianInput hi=new HessianInput(new ByteArrayInputStream(byteArrayOutputStream.toByteArray()));\nPerson person=(Person)hi.readObject();//反序列化\n\n```\n\n\n\n","tags":["序列化"]},{"title":"rmi和webservice","url":"/2019/07/20/开发相关/rmi和webserice/","content":"\n\n\n# RMI\n\n\n\n## 实现一个RMI程序\n\n- 编写服务端程序，暴露端口监听（LocateRegistry.createRegistry(8888);）\n- 绑定对象到对应接口(Naming.bind(\"rmi://localhost:8888/test\",hello);)\n- 客户端寻找接口(Hello hello=(Hello) Naming.lookup(\"rmi://localhost:8888/test\");)\n\n注意：\n\n- 接口hello必须继承java.rmi.Remote(接口方法抛出REMOTEEXCEPTION)\n- 实现类继承java.rmi.server.UnicastRemoteObject对象\n\n","tags":["RMI,WEBSERVICE"]},{"title":"socket连接","url":"/2019/07/17/开发相关/Socket/","content":"\n\n# TCP/IP\n\nTCP/IP（Transmission Control Protocol/Internet Protocol）是一种可靠的网络数据传输控制协议。定义了主机如何连入因特网以及数据如何在他们之间传输的标准\n\n五层/七层模型：应用(表示，会话)，传输，网络，链路，物理传输\n\n![001](socket/001.png)\n\n- 三次握手\n\n  （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。\n\n  （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。\n\n  （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。\n\n- 四次挥手协议\n\n  （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。\n\n  （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。\n\n  （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。\n\n  （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。\n\n  \n\n  # Socket链接\n\n  \n\n  ## 1v1链接\n  - 客户端\n\n```java\npublic class SocketClient {\n\n  public static void main(String[] args) {\n    try {\n      Socket socket = new Socket(\"localhost\", 8888);\n      PrintWriter printWriter = new PrintWriter(socket.getOutputStream(), true);\n      printWriter.println(\"hello server\");\n      BufferedReader bufferedReader = new BufferedReader(\n          new InputStreamReader(socket.getInputStream()));\n      while (true) {\n        String serverData = bufferedReader.readLine();\n        if (serverData == null) {\n          break;\n        }\n        System.out.println(\"客户端消息：\" + serverData);\n      }\n      printWriter.close();\n      socket.close();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n```\n\n  - 服务端\n\n```java\n\npublic class SocketServer {\n\n  public static void main(String[] args) throws IOException {\n    ServerSocket serverSocket = null;\n    try {\n      serverSocket = new ServerSocket(8888);\n      while (true) {\n        Socket socket = serverSocket.accept();\n        new Thread(() -> {\n          try {\n            BufferedReader reader = new BufferedReader(\n                new InputStreamReader(socket.getInputStream()));\n            PrintWriter printWriter = new PrintWriter(\n                new OutputStreamWriter(socket.getOutputStream()));\n            while (true) {\n              String clientData = reader.readLine();\n              if (clientData == null) {\n                break;\n              }\n              System.out.println(\"服务端消息：\" + clientData);\n              printWriter.println(\"hello.mike\");\n              printWriter.flush();\n            }\n\n          } catch (IOException e) {\n            e.printStackTrace();\n          }\n        }).start();\n      }\n    } catch (IOException e) {\n    } finally {\n      if (serverSocket != null) {\n        serverSocket.close();\n      }\n    }\n  }\n\n}\n```\n\n## 组播\n\n```java\npublic class MulticastServer {\n\n  public static void main(String[] args) {\n    //地址段：224.0.0.0-239.255.255.255\n    try {\n      InetAddress group=InetAddress.getByName(\"224.1.2.3\");\n      MulticastSocket multicastSocket=new MulticastSocket();\n      for (int i = 0; i <10 ; i++) {\n        String data=\"hello,index\"+i;\n        byte[] bytes=data.getBytes();\n        multicastSocket.send(new DatagramPacket(bytes,bytes.length,group,8888));\n        TimeUnit.SECONDS.sleep(2);\n      }\n\n    } catch (UnknownHostException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n\n\n}\n\n\n```\n\n\n\n\n\n```java\npublic class MulticastClient {\n\n  public static void main(String[] args) {\n\n    try {\n      InetAddress group=InetAddress.getByName(\"224.1.2.3\");\n      MulticastSocket multicastSocket=new MulticastSocket(8888);\n      multicastSocket.joinGroup(group);\n      byte[] bytes=new byte[1024];\n      while (true){\n        DatagramPacket datagramPacket=new DatagramPacket(bytes,bytes.length);\n        multicastSocket.receive(datagramPacket);\n        String msg=new String(datagramPacket.getData());\n        System.out.println(\"接受到msg：\"+msg);\n      }\n    } catch (UnknownHostException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n}\n\n\n```\n\n","tags":["网络通讯"]},{"title":"springboot源码分析","url":"/2019/06/22/框架系列/springboot/springboot源码分析/","content":"\n\n\n# springboot项目的创建\n\n- idea创建：File->New->Project...->Spring Initializr->Default:https://start.spring.io\n- web创建：登录https://start.spring.io/  ，选择对应springboot版本，设置group和artifact下载就行\\、\n\n注：springboot项目默认没有加载web，需要自己导入maven依赖\n\n```xml\n    <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n```\n\n\n\n# springboot启动\n\n这里采用的是web下载方式，打开后，找到springboot启动类\n\n\n\n```java\npackage com.mkpassby.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringbootApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootApplication.class, args);\n\t}\n\n}\n\n```\n\n\n\n## springboot注解分析\n\n### @SpringBootApplication\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n...\n}\n```\n\n主要看有\n\n- @SpringBootConfiguration：声明配置类\n- @EnableAutoConfiguration：自动化配置\n- @ComponentScan：包扫描\n\n\n\n这里@EnableAutoConfiguration是通过将@Import导入AutoConfigurationImportSelector.class注入bean容器中\n\nspringboot中大量使用了@import注解：\n\n### @Import注解介绍\n\n@Import支持三种方式的导入：\n\n1. 直接导入一个配置类或者Bean\n2. 导入ImportSelector的实现类\n3. 导入ImportBeanDefinitionRegistrar的实现类\n\n\n\n```java\npublic class User {\n    private String name=\"aaa\";\n    public String getName() {\n        return name;  }  \n    public void setName(String name) {\n        this.name = name;  }}\n```\n\n```java\n@Import(User.class)\npublic class App {\n\n  public static void main(String[] args) {\n    ConfigurableApplicationContext configurableApplicationContext= SpringApplication.run(App.class,args);\n    System.out.println(configurableApplicationContext.getBean(User.class));\n    System.out.println(configurableApplicationContext.getBean(User.class).getName());\n    configurableApplicationContext.close();\n  }\n}\n```\n\nImportSelector方法的实现，return new String[]｛“com.mkpassby.demo.User”｝\n\n```java\npublic interface ImportSelector {\n  String[] selectImports(AnnotationMetadata var1);\n}\n\n```\n\n\n\nImportBeanDefinitionRegistrar和ImportSelector类似，注册额外的bean\n\n```JAVA\npublic class UserImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {\n\n  @Override\n  public void registerBeanDefinitions(AnnotationMetadata annotationMetadata,\n      BeanDefinitionRegistry beanDefinitionRegistry) {\n\n    beanDefinitionRegistry.registerBeanDefinition(\"User\",new RootBeanDefinition(User.class));\n  }\n}\n```\n\n \n\n\n\n## springboot启动分析\n\nSpringBoot启动由一个main方法调入，由静态run方法启动\n\n```java\n@SpringBootApplication\npublic class SpringbootApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SpringbootApplication.class, args);\n\t}\n}\n```\n\nrun方法中new SpringApplication(),在构造器调用WebApplicationType.deduceFromClasspath()，判定当前应用类型，我这里用的是2.1.6.RELEASE的版本，这里可以看到有一个WebApplicationType.REACTIVE，这个是对webflux非阻塞web框架的支持。\n\n```java\nstatic WebApplicationType deduceFromClasspath() {\n\t\tif (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) && !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)\n\t\t\t\t&& !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {\n\t\t\treturn WebApplicationType.REACTIVE;\n\t\t}\n\t\tfor (String className : SERVLET_INDICATOR_CLASSES) {\n\t\t\tif (!ClassUtils.isPresent(className, null)) {\n\t\t\t\treturn WebApplicationType.NONE;\n\t\t\t}\n\t\t}\n\t\treturn WebApplicationType.SERVLET;\n\t}\n```\n\n且在构造器中对所有包下的META-INF/spring.factories中配置的ApplicationContextInitializer和ApplicationListener实例化\n\n```java\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n\t\tthis.resourceLoader = resourceLoader;\n\t\tAssert.notNull(primarySources, \"PrimarySources must not be null\");\n\t\tthis.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n\t\tthis.webApplicationType = WebApplicationType.deduceFromClasspath();\n\t\tsetInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));\n\t\tsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n\t\tthis.mainApplicationClass = deduceMainApplicationClass();\n\t}\n```\n\n\n\n\n\n实例化SpringApplication完成后，调用run方法，实例化SpringApplicationRunListener，开启监听，准备数据等，其中核心在refreshContext(context)方法。在invokeBeanFactoryPostProcessors()方法中。该方法调用了PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors())方法，此处第二个传参getBeanFactoryPostProcessors()传过来的是\n\n```properties\n0 = {SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor@3037} \n1 = {ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor@3038} \n2 = {ConfigurationClassPostProcessor@3787} \n```\n\n\n\n，这里是通过监听add到list中，此处具体实现需要进一步探究，最终通过postProcessBeanDefinitionRegistry进行BeanDefinition注册的处理。\n\n\n\n```java\n/**\n\t * Build and validate a configuration model based on the registry of\n\t * {@link Configuration} classes.\n\t */\n\tpublic void processConfigBeanDefinitions(BeanDefinitionRegistry registry) {\n\t\tList<BeanDefinitionHolder> configCandidates = new ArrayList<>();\n\t\tString[] candidateNames = registry.getBeanDefinitionNames();\n\n\t\tfor (String beanName : candidateNames) {\n\t\t\tBeanDefinition beanDef = registry.getBeanDefinition(beanName);\n\t\t\tif (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||\n\t\t\t\t\tConfigurationClassUtils.isLiteConfigurationClass(beanDef)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Bean definition has already been processed as a configuration class: \" + beanDef);\n\t\t\t\t}\n\t\t\t}\n            //获取所有标记了@Configuration注解类，封装成BeanDefinitionHolder集合\n\t\t\telse if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) {\n\t\t\t\tconfigCandidates.add(new BeanDefinitionHolder(beanDef, beanName));\n\t\t\t}\n\t\t}\n\n\t\t// 没有 @Configuration 返回\n\t\tif (configCandidates.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// 根据@configuration中@Order排序\n\t\tconfigCandidates.sort((bd1, bd2) -> {\n\t\t\tint i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());\n\t\t\tint i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\n\t\t// Detect any custom bean name generation strategy supplied through the enclosing application context\n\t\tSingletonBeanRegistry sbr = null;\n\t\tif (registry instanceof SingletonBeanRegistry) {\n\t\t\tsbr = (SingletonBeanRegistry) registry;\n\t\t\tif (!this.localBeanNameGeneratorSet) {\n\t\t\t\tBeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);\n\t\t\t\tif (generator != null) {\n\t\t\t\t\tthis.componentScanBeanNameGenerator = generator;\n\t\t\t\t\tthis.importBeanNameGenerator = generator;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.environment == null) {\n\t\t\tthis.environment = new StandardEnvironment();\n\t\t}\n\n\t\t// Parse each @Configuration class\n\t\tConfigurationClassParser parser = new ConfigurationClassParser(\n\t\t\t\tthis.metadataReaderFactory, this.problemReporter, this.environment,\n\t\t\t\tthis.resourceLoader, this.componentScanBeanNameGenerator, registry);\n\n\t\tSet<BeanDefinitionHolder> candidates = new LinkedHashSet<>(configCandidates);\n\t\tSet<ConfigurationClass> alreadyParsed = new HashSet<>(configCandidates.size());\n\t\tdo {\n\t\t\tparser.parse(candidates);\n\t\t\tparser.validate();\n\n\t\t\tSet<ConfigurationClass> configClasses = new LinkedHashSet<>(parser.getConfigurationClasses());\n\t\t\tconfigClasses.removeAll(alreadyParsed);\n\n\t\t\t// Read the model and create bean definitions based on its content\n\t\t\tif (this.reader == null) {\n\t\t\t\tthis.reader = new ConfigurationClassBeanDefinitionReader(\n\t\t\t\t\t\tregistry, this.sourceExtractor, this.resourceLoader, this.environment,\n\t\t\t\t\t\tthis.importBeanNameGenerator, parser.getImportRegistry());\n\t\t\t}\n\t\t\tthis.reader.loadBeanDefinitions(configClasses);\n\t\t\talreadyParsed.addAll(configClasses);\n\n\t\t\tcandidates.clear();\n\t\t\tif (registry.getBeanDefinitionCount() > candidateNames.length) {\n\t\t\t\tString[] newCandidateNames = registry.getBeanDefinitionNames();\n\t\t\t\tSet<String> oldCandidateNames = new HashSet<>(Arrays.asList(candidateNames));\n\t\t\t\tSet<String> alreadyParsedClasses = new HashSet<>();\n\t\t\t\tfor (ConfigurationClass configurationClass : alreadyParsed) {\n\t\t\t\t\talreadyParsedClasses.add(configurationClass.getMetadata().getClassName());\n\t\t\t\t}\n\t\t\t\tfor (String candidateName : newCandidateNames) {\n\t\t\t\t\tif (!oldCandidateNames.contains(candidateName)) {\n\t\t\t\t\t\tBeanDefinition bd = registry.getBeanDefinition(candidateName);\n\t\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &&\n\t\t\t\t\t\t\t\t!alreadyParsedClasses.contains(bd.getBeanClassName())) {\n\t\t\t\t\t\t\tcandidates.add(new BeanDefinitionHolder(bd, candidateName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcandidateNames = newCandidateNames;\n\t\t\t}\n\t\t}\n\t\twhile (!candidates.isEmpty());\n\n\t\t// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes\n\t\tif (sbr != null && !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) {\n\t\t\tsbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());\n\t\t}\n\n\t\tif (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) {\n\t\t\t// Clear cache in externally provided MetadataReaderFactory; this is a no-op\n\t\t\t// for a shared cache since it'll be cleared by the ApplicationContext.\n\t\t\t((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache();\n\t\t}\n\t}\n```\n\n\n\n\n\n继续跟进postProcessBeanDefinitionRegistry方法，后面调用了org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass方法,这里对@Configuration类进行了解析，包括@PropertySource，@ComponentScan，@Import，@ImportResource等。\n\n```java\nprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n\t\t\tthrows IOException {\n\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass);\n\t\t}\n\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\n\t\t// Process any @ComponentScan annotations\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}\n```\n\n后续就是实例化所有的bean(Instantiate all remaining (non-lazy-init) singletons.),这里由于引入了spring-boot-starter-web依赖，特别说明下RequestMappingHandlerAdapter实例化。\n\n## RequestMappingHandlerAdapter实例化\n\n在实例化RequestMappingHandlerAdapter时会调用org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#requestMappingHandlerAdapter\n\n```java\n@Bean\n\tpublic RequestMappingHandlerAdapter requestMappingHandlerAdapter() {\n\t\tRequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter();\n\t\tadapter.setContentNegotiationManager(mvcContentNegotiationManager());\n\t\tadapter.setMessageConverters(getMessageConverters());\n\t\tadapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());\n\t\tadapter.setCustomArgumentResolvers(getArgumentResolvers());\n\t\tadapter.setCustomReturnValueHandlers(getReturnValueHandlers());\n\n\t\tif (jackson2Present) {\n\t\t\tadapter.setRequestBodyAdvice(Collections.singletonList(new JsonViewRequestBodyAdvice()));\n\t\t\tadapter.setResponseBodyAdvice(Collections.singletonList(new JsonViewResponseBodyAdvice()));\n\t\t}\n\n\t\tAsyncSupportConfigurer configurer = new AsyncSupportConfigurer();\n\t\tconfigureAsyncSupport(configurer);\n\t\tif (configurer.getTaskExecutor() != null) {\n\t\t\tadapter.setTaskExecutor(configurer.getTaskExecutor());\n\t\t}\n\t\tif (configurer.getTimeout() != null) {\n\t\t\tadapter.setAsyncRequestTimeout(configurer.getTimeout());\n\t\t}\n\t\tadapter.setCallableInterceptors(configurer.getCallableInterceptors());\n\t\tadapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());\n\n\t\treturn adapter;\n\t}\n```\n进入getMessageConverters方法中，这里注意会由configureMessageConverters()方法进入org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport#getMessageConverters\n\n```java\n@Override\n\tpublic void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t\tfor (WebMvcConfigurer delegate : this.delegates) {\n\t\t\tdelegate.configureMessageConverters(converters);\n\t\t}\n\t}\n```\n\n\n\n\n\ngetMessageConverters方法，这里主要是从configureMessageConverters初始化messageConverters，以后后面的extendMessageConverters扩展messageCoverters。\n\n```java\nprotected final List<HttpMessageConverter<?>> getMessageConverters() {\n\t\tif (this.messageConverters == null) {\n\t\t\tthis.messageConverters = new ArrayList<>();\n\t\t\tconfigureMessageConverters(this.messageConverters);\n\t\t\tif (this.messageConverters.isEmpty()) {\n\t\t\t\taddDefaultHttpMessageConverters(this.messageConverters);\n\t\t\t}\n\t\t\textendMessageConverters(this.messageConverters);\n\t\t}\n\t\treturn this.messageConverters;\n\t}\n\n```\n\n这里如果需要扩展Http的请求扩展则可以查看类WebMvcConfigurer接口的注解说明，这里\n\n主要看\n\n``` JAVA\n\t/**\n\t * Configure the {@link HttpMessageConverter HttpMessageConverters} to use for reading or writing\n\t * to the body of the request or response. If no converters are added, a\n\t * default list of converters is registered.\n\t * <p><strong>Note</strong> that adding converters to the list, turns off\n\t * default converter registration. To simply add a converter without impacting\n\t * default registration, consider using the method\n\t * {@link #extendMessageConverters(java.util.List)} instead.\n\t * @param converters initially an empty list of converters\n\t */\n\tdefault void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}\n\n\t/**\n\t * A hook for extending or modifying the list of converters after it has been\n\t * configured. This may be useful for example to allow default converters to\n\t * be registered and then insert a custom converter through this method.\n\t * @param converters the list of configured converters to extend.\n\t * @since 4.1.3\n\t */\n\tdefault void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n\t}\n```\n\n## 扩展\n\n这里贴出一段测试代码，可调整PostMapping中的produces和consumes查看变化\n\n\n\n通过对HttpConvert的修改，我们的代码可以适配成我们想要的入参或者出参，当然，应用场景多用json格式，可以考虑自己封装json对应的转换器，去除掉springboot中默认的json转换器\n\n```java\n@Configuration\npublic class MyWebMvcConfig implements WebMvcConfigurer {\n  @Override\n  public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n    converters.add(new PropertiesToUserConverter());\n\n  }\n  @Override\n  public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {\n    converters.add(new PropertiesToUserConverter());\n\n  }\n\n}\n```\n\n```java\n/**\n * @program: springboot\n * @description:\n * @author: mk_passby\n * @create: 2019-06-25 22:19\n **/\npublic class PropertiesToUserConverter extends AbstractHttpMessageConverter<User> {\n\n  public PropertiesToUserConverter() {\n    super(MediaType.valueOf(\"application/properties+person\"));\n    setDefaultCharset(Charset.forName(\"UTF-8\"));\n  }\n\n  @Override\n  protected boolean supports(Class<?> aClass) {\n    return aClass.isAssignableFrom(User.class);\n  }\n\n  //转换入参\n  @Override\n  protected User readInternal(Class<? extends User> aClass, HttpInputMessage httpInputMessage)\n      throws IOException, HttpMessageNotReadableException {\n    InputStream inputStream=httpInputMessage.getBody();\n    Properties properties=new Properties();\n    //请求内容properties转换为User对象\n    properties.load(inputStream);\n    User user=new User();\n    user.setName(properties.getProperty(\"user.name\"));\n    return user;\n  }\n\n  /***\n   * @param user\n   * @param httpOutputMessage\n   * @throws IOException\n   * @throws HttpMessageNotWritableException\n   */\n  //用properties格式写出去\n  @Override\n  protected void writeInternal(User user, HttpOutputMessage httpOutputMessage)\n      throws IOException, HttpMessageNotWritableException {\n    OutputStream outputStream=httpOutputMessage.getBody();\n    Properties properties=new Properties();\n    properties.setProperty(\"user.name\",user.getName());\n    properties.store(new OutputStreamWriter(outputStream,getDefaultCharset()),\"from web server\");\n  }\n}\n```\n\n```JAVA\n@RestController\npublic class RestControllerDemo {\n\n  @PostMapping(\n      value = \"user/properties/to/json\",\n      produces = \"application/properties+person\",//出参类型Accept\n      consumes = \"application/properties+person\"//入参类型Content-Type\n  )\n  public User userToProperties(@RequestBody User user) {\n    return user;\n  }\n}\n```\n\n用postman模拟请求，结果如下\n\n![1562769528306](springboot请求响应分析\\1562769528306.png)\n\n![1562769550293](springboot请求响应分析\\1562769550293.png)\n\n# springboot事件机制\n\n### 设计模式\n\n- 观察者模式\n\n  - `java.util.Observable`发布者\n\n  - `java.util.Observer`订阅者\n\n    ```java\n    package com.mk.demo;\n    \n    import java.util.Observable;\n    import java.util.Observer;\n    \n    /**\n     * @program: springcloud-demo\n     * @description: 观察值demo\n     * @author: mk_passby\n     * @create: 2020-05-25 22:34\n     **/\n    public class ObserverDemo {\n    \n        public static void main(String[] args) {\n            ObservableTest observable = new ObservableTest();\n            observable.setChanged();\n            observable.addObserver(new Observer() {\n                @Override\n                public void update(Observable o, Object arg) {\n                    System.out.println(arg);\n                }\n            });\n            observable.notifyObservers(\"Hello world\");\n        }\n    \n        public static class ObservableTest extends Observable {\n    \n            @Override\n            public synchronized void setChanged() {\n                super.setChanged();\n            }\n        }\n    }\n    \n    ```\n\n    \n\n- 事件监听模式\n\n\n\n### spring核心事件\n\n- ApplictionEvent：应用事件\n- ApplicationListener：应用监听器\n\n```java\npackage com.mk.demo;\n\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\n/**\n * @program: springcloud-demo\n * @description: spring事件监听demo\n * @author: mk_passby\n * @create: 2020-05-25 22:49\n **/\npublic class SpringEvenListenDemo {\n\n    public static void main(String[] args) {\n        //Annotation驱动的spring\n        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();\n        //注册监听\n        context.addApplicationListener(new ApplicationListener<ApplicationEventTest>() {\n            @Override\n            public void onApplicationEvent(ApplicationEventTest event) {\n                System.out.println(\"onApplicationEvent:\" + event.getSource());\n            }\n        });\n        //发布事件\n        context.refresh();\n        context.publishEvent(new ApplicationEventTest(\"HELLO WORLD\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 1\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 2\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 3\"));\n        context.publishEvent(new ApplicationEventTest(\"HELLO 4\"));\n\n    }\n\n    private static class ApplicationEventTest extends ApplicationEvent {\n\n        /**\n         * Create a new ApplicationEvent.\n         *\n         * @param source the object on which the event initially occurred (never {@code null})\n         */\n        public ApplicationEventTest(Object source) {\n            super(source);\n        }\n    }\n}\n\n```\n\n### Springboot核心事件\n\n- ApplicationEnvironmentPreparedEvent\n- ApplicationPreparedEvent\n- ApplicationStartedEvent\n- ApplicationReadyEvent\n- ApplicationFailedEvent\n\n","tags":["springcloud"]},{"title":"hexo搭建博客","url":"/2019/06/20/开发相关/hexo博客搭建/","content":"\n这里主要贴出几个搭建过程中用到链接，自行参考，感谢感谢\n\n- [使用Hexo+Github一步步搭建属于自己的博客（基础）](https://www.cnblogs.com/fengxiongZz/p/7707219.html)\n- [使用Hexo+Github一步步搭建属于自己的博客（进阶）](https://www.cnblogs.com/fengxiongZz/p/7707568.html)\n- [hexo主题](https://hexo.io/themes/)\n- [Hexo-Aircloud-Blog主题安装教程](https://github.com/aircloud/hexo-aircloud-blog)\n\n\n\n| Hexo常用命令  | 作用                                           |\n| ------------- | ---------------------------------------------- |\n| hexo s(erver) | 启动本地服务器                                 |\n| hexo new \"AA\" | 新建\"AA\"文章                                   |\n| hexo d        | 部署到设定的仓库                               |\n| hexo clean    | 清除缓存文件 db.json 和已生成的静态文件 public |\n| hexo g        | 生成网站静态文件                               |\n\n"},{"title":"无法访问github或者hexo网页","url":"/2019/06/20/开发相关/无法访问github或者hexo网页/","content":"\n\n\n\n\n## 无法访问github\n\n- 测试是否无法访问\n\n  - ping github.com超时\n\n- 怎么解决？\n\n  - https://tools.ipip.net/dns.php查询可访问的ip，输入github.com，可以看到解析的ip。\n\n  - 添加到hosts文件中`C:\\Windows\\System32\\drivers\\etc\\hosts`\n\n    ```markdown\n    #\t127.0.0.1       localhost\n    13.250.177.223 github.com\n    ```\n\n    \n\n## 无法访问hexo\n\n站长之家查询博客的IP地址\nhttp://tool.chinaz.com/dns\n\n修改hosts文件。\n\n如搜索`mk-passby.github.io`\n\n","tags":["hexo"]},{"title":"maven插件","url":"/2019/06/15/开发相关/maven/maven插件/","content":"\n## maven插件\n\n#### 插件网址\n\n * [maven官网](https://maven.apache.org/plugins/,\"MAVEN-PLUGIN\")\n * [MojoHaus官网](http://www.mojohaus.org/plugins.html,\"MojoHous-Plugin\")\n\n#### 常用插件\n * [tomcat](https://tomcat.apache.org/maven-plugin-trunk/)\n\n\n```xml\n        <pluginManagement>\n          <plugins>\n            <plugin>\n              <groupId>org.apache.tomcat.maven</groupId>\n              <artifactId>tomcat6-maven-plugin</artifactId>\n              <version>2.3-SNAPSHOT</version>\n            </plugin>\n            <plugin>\n              <groupId>org.apache.tomcat.maven</groupId>\n              <artifactId>tomcat7-maven-plugin</artifactId>\n              <version>2.3-SNAPSHOT</version>\n            </plugin>\n          </plugins>\n        </pluginManagement>\n```\n* [assembly](https://maven.apache.org/plugins/maven-assembly-plugin/index.html)（打包）\n * zip\n * tar\n * tar.gz (or tgz)\n * tar.bz2 (or tbz2)\n * tar.snappy\n * tar.xz (or txz)\n * jar\n * dir\n * war\n* versions 统一升级版本号\n`mvn versions:set -DnewVersion=1.1`\n\n#### 自定义插件\n* [自定义Mojo](https://maven.apache.org/guides/plugin/guide-java-plugin-development.html)\n\n\n1.extends AbstractMojo\n```java\n    package sample.plugin;\n     \n    import org.apache.maven.plugin.AbstractMojo;\n    import org.apache.maven.plugin.MojoExecutionException;\n    import org.apache.maven.plugins.annotations.Mojo;\n     \n    /**\n     * Says \"Hi\" to the user.\n     *\n     */\n    @Mojo( name = \"sayhi\")\n    public class GreetingMojo extends AbstractMojo\n    {\n        public void execute() throws MojoExecutionException\n        {\n            getLog().info( \"Hello, world.\" );\n        }\n    }\n```\n2.pom参数\n\n```xml\n    <project>\n      <modelVersion>4.0.0</modelVersion>\n     \n      <groupId>sample.plugin</groupId>\n      <artifactId>hello-maven-plugin</artifactId>\n      <version>1.0-SNAPSHOT</version>\n      <packaging>maven-plugin</packaging>\n     \n      <name>Sample Parameter-less Maven Plugin</name>\n     \n      <dependencies>\n        <dependency>\n          <groupId>org.apache.maven</groupId>\n          <artifactId>maven-plugin-api</artifactId>\n          <version>3.0</version>\n        </dependency>\n     \n        <!-- dependencies to annotations -->\n        <dependency>\n          <groupId>org.apache.maven.plugin-tools</groupId>\n          <artifactId>maven-plugin-annotations</artifactId>\n          <version>3.4</version>\n          <scope>provided</scope>\n        </dependency>\n      </dependencies>\n    </project>\n```\n3.引用插件\n\n```xml\n    ...\n      <build>\n        <plugins>\n          <plugin>\n            <groupId>sample.plugin</groupId>\n            <artifactId>hello-maven-plugin</artifactId>\n            <version>1.0-SNAPSHOT</version>\n          </plugin>\n        </plugins>\n      </build>\n    ...\n```\n","tags":["maven"]},{"title":"maven基础","url":"/2019/05/19/开发相关/maven/maven基础/","content":"\n\n## maven基础\n#### 优势\n- 相比传统项目，减少了手动导入工序，更加简便\n- 插件丰富\n- 构建简单\n\n\n#### 安装\n1. [maven下载地址](https://maven.apache.org/download.cgi，\"点击跳转\")\n2. 配置MVN_HOME，如JAVA_HOME类似\n3. 配置完成后，cmd输入`mvn-version` 检测是否配置成功\n4. 配置setting.xml，路径在maven安装目录conf目录下，打开setting.xml配置一个aliyun的仓库(默认仓库下载速度，以前也可以配置oschina打仓库，现在关闭了)\n\n\n```xml\n      <mirrors>\n      <!--aliyun仓库-->\n    \t<mirror>\n    \t  <id>alimaven</id>\n    \t  <name>aliyun maven</name>\n    \t  <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    \t  <mirrorOf>central</mirrorOf>\n    \t</mirror>\n    \t<!-- 中央仓库1 -->\n        <mirror>\n            <id>repo1</id>\n            <mirrorOf>central</mirrorOf>\n            <name>Human Readable Name for this Mirror.</name>\n            <url>http://repo1.maven.org/maven2/</url>\n        </mirror>\n    \n        <!-- 中央仓库2 -->\n        <mirror>\n            <id>repo2</id>\n            <mirrorOf>central</mirrorOf>\n            <name>Human Readable Name for this Mirror.</name>\n            <url>http://repo2.maven.org/maven2/</url>\n        </mirror>\n        <!-- mirror\n         | Specifies a repository mirror site to use instead of a given repository. The repository that\n         | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used\n         | for inheritance and direct lookup purposes, and must be unique across the set of mirrors.\n         |\n        <mirror>\n          <id>mirrorId</id>\n          <mirrorOf>repositoryId</mirrorOf>\n          <name>Human Readable Name for this Mirror.</name>\n          <url>http://my.repository.com/repo/path</url>\n        </mirror>\n         -->\n      </mirrors>\n```\n#### maven加载顺序\n首先是到用户目录下打.m2目录下setting中去找jar包，再去conf下的setting中找的\nmaven->/.m2/setting.xml->conf/settiong.xml\n\n\n#### pom.xml文件说明\n新建maven此处不做说明\n- groupid：公司名(网址）\n- artifactId：模块功能名(common，web，model，dao)\n- version：版本号\n- pachaging：打包方式，默认jar\n- dependencyManagemanet：依赖管理，统一版本号\n- Dependency：依赖\n * Type：默认jar\n * scope：\n   * complile：编译\n   * test：测试\n   * provided：已经提供了，不需要打进包\n   * runtime：运行时需要\n   * system：本地依赖的jar包 \n * exclusions：剔除不需要的jar包，多用于jar包冲突\n\n\n#### 基本的命令\n- compile:编译(mvn clean:compile)\n- test：运行test\n- package：打包\n- install：install到本地仓库\n- deploy：发布到远程仓库\n\n","tags":["maven"]},{"title":"代理模式","url":"/2018/07/15/设计模式/代理模式/","content":"\n\n\n代理模式就是新增加一个代理类，然后通过代理类来调用我们的实现。\n\n应用场景可以参考中介。\n\n# 1.未使用代理类场景\n\n        未使用代理类，即接口直接通过实现类实现功能\n\n![](代理模式\\1.jpg)\n\n接口：\n\n```java\npublic interface UserDao {\n    public void updateUser();\n    public void delUser();\n}\n```\n\n实现类：\n\n```java\npublic class UserDaoImpl implements UserDao{\n    @Override\n    public void updateUser() {\n        System.out.println(\"更新用户成功\");\n    }\n\n    @Override\n    public void delUser() {\n        System.out.println(\"删除用户成功\");\n    }\n}\n```\n\n测试类：\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        UserDao userDao=new UserDaoImpl();\n        userDao.delUser();\n        userDao.updateUser();\n    }\n}\n\n```\n\n![](代理模式\\2.jpg)\n\n# 2.使用代理类\n\n## 2.1静态代理类\n\n即新增一个代理类，来管理我们的实现类，我们可以在代理类中添加一些动作\n\n![](代理模式\\3.jpg)\n\n将具体的实现通过构造器注入，然后代理类中调用我们对应的实现类的方法，\n\n新增的代理类如下：\n\n```java\npublic class StaticProxy implements UserDao{\n    private UserDao userDao;\n    public StaticProxy(UserDao userDao1)\n    {\n        this.userDao=userDao1;\n    }\n\n\n    @Override\n    public void updateUser() {\n        System.out.println(\"begin\");\n        userDao.updateUser();\n        System.out.println(\"end \");\n    }\n\n    @Override\n    public void delUser() {\n        System.out.println(\"begin\");\n        userDao.delUser();\n        System.out.println(\"end\");\n    }\n}\n```\n\n测试类\n\n```java\npublic class ProxyTest {\n    public static void main(String[] args) {\n        UserDao userDaoProxy=new StaticProxy(new UserDaoImpl());\n        userDaoProxy.delUser();\n        userDaoProxy.updateUser();\n    }\n}\n```\n\n结果如下\n\n![](代理模式\\4.jpg)\n\n## 2.2由静态代理类引出动态代理类\n\n- 可以看见，我们的静态代理类也实现了UserDao接口，当接口新增内容时，如新增一个query()方法，此时，我们的UserDaoImpl和StaticProxy类都要改变。-\n- 这是我们不想看见的，我们希望代理类可以不做修改，只需要修改我们的实现类的内容。由此引出了动态代理类(由此动态代理类的作用也显而易见) \n\n## 2.3动态代理类\n\n**定义动态代理工具类**\n\n返回指定的接口，将方法调用指定的调用处理程序的代理类的一个实例![](代理模式\\5.jpg)\n\n三个参数可以查阅JDK明细，主要需要实现`InvocationHandler`接口，实现`invoke`方法，通过反射实现对抽象接口方法的调用`method.invoke(target, args),`调其中target就是我们真正的实现类\n\n\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\n\n```java\npublic class DynamicProxy {\n    public static void main(String[] args) {\n        UserDao userDao = (UserDao) Proxy.newProxyInstance(\n                UserDao.class.getClassLoader(),\n                new Class[]{UserDao.class},\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        System.out.println(\"proxy begin\");\n                        Object result = method.invoke(new UserDaoImpl(), args);\n                        System.out.println(\"proxy end\");\n                        return result;\n                    }\n                }\n        );\n        userDao.delUser();\n    }，\n```\n\n\n\n# 3.总结\n\n- 核心在于ProxyGenerator.generateProxyClass，返回的byte[]为对象字节数组，生成代理对象。\n\n- 代理模式强调一些通用功能的扩展，在方法执行前，执行后添加点什么东西(LOG)，静态即单一的扩展，动态为多个类扩展，但是都引入新的代理类，从性能上讲，新的代理类会导致性能有所下降.","tags":["设计模式"]},{"title":"抽象工厂模式","url":"/2018/03/26/设计模式/抽象工厂模式/","content":"\n# 1.比较工厂方法模式\n\n## 工厂方法模式：\n\n-   一个抽象产品类，可以派生出多个具体产品类。\n-   一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。\n-   工厂方法模式只有一个抽象产品类(只能创建一个具体产品类的实例)\n\n## 抽象工厂模式：\n\n-   多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。\n-   一个抽象工厂类，可以派生出多个具体工厂类。\n-   抽象工厂模式有多个产品类(抽象工厂模式可以创建多个)\n\n# 2.抽象工厂模式举例\n\n比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。 这样A和B就是工厂，对应于抽象工厂；每个工厂生产的鼠标和键盘就是产品，对应于工厂方法；用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法） 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线\n\n# 3.总结\n\n1.  抽象工厂模式并不是指抽象类(不要混淆)，这里注意区分。\n2.  工厂方法模式更注重的是工厂方法的更改，更细微一点，如替换键盘由微软的生产方法替换到罗技的生产方法。而抽象工厂模式更注重的是工厂的替换，工厂方法的更改是工厂替换后考虑的点。\n3.  工厂方法模式可以看做是生产一个东西，抽象工厂模式看作生产一堆东西，只是对应的厂商不同(实现类)。如果工厂方法模式中Factory生产多个东西就是抽象工厂模式（个人理解）","tags":["设计模式"]},{"title":"工厂方法模式","url":"/2018/03/26/设计模式/工厂方法模式/","content":"\n# 1.普通简单工厂\n\n​        工厂类负责对实现同一接口的类进行实例创建,\n\n## 关系图如下\n\n![img](工厂方法模式\\1.png)\n\n## 代码如下：\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic Sender produce(String type) {\n\t\tif (\"mail\".equals(type)) {\n\t\t\treturn new MailSender();\n\t\t} else if (\"msg\".equals(type)) {\n\t\t\treturn new MsgSender();\n\t\t} else {\n\t\t\tSystem.out.println(\"请输入正确的类型\");\n\t\t\treturn null;\n\t\t}\n\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic interface Sender {\n\tpublic void send();\n\t\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class MailSender implements Sender{\n\n\t@Override\n\tpublic void send() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"this is a mailSender\");\n\t}\n\t\n\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class MsgSender implements Sender{\n\n\t@Override\n\tpublic void send() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"this is a msgSender\");\n\t}\n\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=new SendFactory().produce(\"msg\");\n\t\tsend.send();\n\t}\n}\n```\n\n运行结果：\n\n![img](工厂方法模式\\2.png)\n\n\n\n# 2.多方法简单工厂\n\n​        普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，多方法简单工厂为工厂提供创建每个实例的方法，避免这种问题。\n\n## 关系图如下\n\n![img](工厂方法模式\\3.png)\n\n## 代码如下：\n\n​        对比这里只有SenderFactory做了改变，这里仅贴出**SenderFactory**和**Test**的代码\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic Sender produceMail() {\n\t\treturn new MailSender();\n\t}\n\tpublic Sender produceMsg(){\n\t\treturn new MsgSender();\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=new SendFactory().produceMail();\n\t\tsend.send();\n\t}\n}\n```\n## 结果如下：\n\n![img](工厂方法模式\\4.png)\n\n\n\n# 3.静态方法简单工厂\n\n​        将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用\n\n​        即将SenderFactory中的produceMail()和produceMsg()改为静态方法。其他文件同样不变\n\n## 代码如下：\n\n```java\npackage com.designer.factory;\n\npublic class SendFactory {\n\tpublic static Sender produceMail() {\n\t\treturn new MailSender();\n\t}\n\tpublic static Sender produceMsg(){\n\t\treturn new MsgSender();\n\t}\n}\n```\n\n```java\npackage com.designer.factory;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSender send=SendFactory.produceMail();\n\t\tsend.send();\n\t}\n}\n```\n\n# 4.总结\n\n## 工厂模式的使用场景：\n\n​        当几个实现类都有相同的接口，可用工厂模式，易于扩展和修改。\n\n## 工厂模式选择：\n\n​        以上三种模式，第一种字符串有误会导致异常，第三种由于是静态方法，不需要重复创建对象，所以一般选择第三种——静态工厂方法\n\n\n\n# 5.工厂方法模式\n\n​        简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改。\n\n​        用工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码\n\n## 关系图如下：\n\n![img](工厂方法模式\\5.png)\n\n具体的实现这里就不再写出来了，只是给MailSenderFactory和MsgSenderFactory提供一格接口，让工厂类也易于扩展。\n\n\n\n## 这个模式的好处\n\n如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！","tags":["设计模式"]},{"title":"ssm项目搭建","url":"/2018/03/22/框架系列/ssm项目搭建/","content":"\n# 基于xml配置\n\n## 1.所需架包\n\n```xml\n<dependencies>\n     \n        <dependency>\n              <groupId>javax.websocket</groupId>\n              <artifactId>javax.websocket-api</artifactId>\n              <version>1.1</version>\n        </dependency>\n        <dependency>\n              <groupId>org.springframework</groupId>\n              <artifactId>spring-websocket</artifactId>\n              <version>4.0.5.RELEASE</version>\n         </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>3.8.1</version>\n            <scope>test</scope>\n        </dependency>\n \n        <dependency>\n            <groupId>jstl</groupId>\n            <artifactId>jstl</artifactId>\n            <version>1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>com.fasterxml.jackson.core</groupId>\n            <artifactId>jackson-databind</artifactId>\n            <version>2.2.3</version>\n        </dependency>\n        <dependency>\n            <groupId>com.google.code.gson</groupId>\n            <artifactId>gson</artifactId>\n            <version>2.2.4</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/net.sf.ezmorph/ezmorph -->\n        <dependency>\n            <groupId>net.sf.ezmorph</groupId>\n            <artifactId>ezmorph</artifactId>\n            <version>1.0.4</version>\n        </dependency>\n        <!-- https://mvnrepository.com/artifact/commons-beanutils/commons-beanutils -->\n        <dependency>\n            <groupId>commons-beanutils</groupId>\n            <artifactId>commons-beanutils</artifactId>\n            <version>1.7.0</version>\n        </dependency>\n \n        <dependency>\n            <groupId>commons-collections</groupId>\n            <artifactId>commons-collections</artifactId>\n            <version>3.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib-ext-spring</artifactId>\n            <version>1.0.2</version>\n        </dependency>\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-lang</groupId>\n            <artifactId>commons-lang</artifactId>\n            <version>2.6</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-io</groupId>\n            <artifactId>commons-io</artifactId>\n            <version>2.0.1</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-fileupload</groupId>\n            <artifactId>commons-fileupload</artifactId>\n            <version>1.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis-spring</artifactId>\n            <version>1.2.0</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-dbcp</groupId>\n            <artifactId>commons-dbcp</artifactId>\n            <version>1.4</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-pool</groupId>\n            <artifactId>commons-pool</artifactId>\n            <version>1.5.6</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.6.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator</artifactId>\n            <version>1.3.5</version>\n            <type>pom</type>\n        </dependency>\n        <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator-core</artifactId>\n            <version>1.3.5</version>\n        </dependency>\n        <dependency>\n            <groupId>commons-logging</groupId>\n            <artifactId>commons-logging</artifactId>\n            <version>1.1.2</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet.jsp</groupId>\n            <artifactId>jsp-api</artifactId>\n            <version>2.2</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>servlet-api</artifactId>\n            <version>2.5</version>\n        </dependency>\n        <!-- ============================================== -->\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aspects</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context-support</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-core</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-expression</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-jdbc</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-tx</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-web</artifactId>\n            <version>3.2.2.RELEASE</version>\n        </dependency>\n        <!-- ============================================== -->\n        <dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-core-asl</artifactId>\n            <version>1.9.11</version>\n        </dependency>\n        <dependency>\n            <groupId>org.codehaus.jackson</groupId>\n            <artifactId>jackson-mapper-asl</artifactId>\n            <version>1.9.11</version>\n        </dependency>\n        <dependency>\n            <groupId>net.sf.json-lib</groupId>\n            <artifactId>json-lib</artifactId>\n            <version>2.3</version>\n            <classifier>jdk15</classifier>\n        </dependency>\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.25</version>\n        </dependency>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n \n        <dependency>\n            <groupId>javax.mail</groupId>\n            <artifactId>mail</artifactId>\n            <version>1.4.3</version>\n        </dependency>\n \n       \n \n    </dependencies>\n```\n\n## 2.框架搭建\n\n### 2.1.html--->springMVC\n\n        将html页面的请求转发到springMVC，即转换servlet到springMVC，在WebRoot下的WEB-INF配置web.xml\n\n```xml\n<!-- springmvc前端控制器 -->\n    <servlet>\n        <servlet-name>springmvc</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet\n        </servlet-class>\n        <!--\n            contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等）\n            如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml）\n        -->\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring/springmvc.xml</param-value>\n        </init-param>\n    </servlet>\n \n    <servlet-mapping>\n        <servlet-name>springmvc</servlet-name>\n        <!--\n            第一种：*.action，访问以.action结尾 由DispatcherServlet进行解析\n            第二种：/，所以访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析\n            使用此种方式可以实现 RESTful风格的url 第三种：/*，这样配置不对，使用这种配置，最终要转发到一个jsp页面时，\n            仍然会由DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错。\n        -->\n        <url-pattern>*.action</url-pattern>\n    </servlet-mapping>\n```\n\n处理页面乱码，过滤乱码问题\n\n```xml\n<!-- post乱码过虑器 -->\n    <filter>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter\n        </filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>utf-8</param-value>\n        </init-param>\n        <init-param>\n            <param-name>forceEncoding</param-name>\n            <param-value>true</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>CharacterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n```\n\n在web.xml中加载spring容器\n\n```xml\n<!-- 加载spring容器 -->\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/classes/spring/applicationContext-*.xml\n        </param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n```\n\n部分errorpage的配置\n\n```xml\n<!-- 404 页面不存在错误 -->\n    <error-page>\n        <error-code>404</error-code>\n        <location>/error404.jsp</location>\n    </error-page>\n \n    <!-- 500 系统错误 -->\n    <error-page>\n        <error-code>500</error-code>\n        <location>/error500.jsp</location>\n    </error-page>\n \n    <!-- 405 页面不存在错误 -->\n    <error-page>\n        <error-code>405</error-code>\n        <location>/error405.jsp</location>\n    </error-page>\n \n    <!-- 400 提交数据异常错误 -->\n    <error-page>\n        <error-code>400</error-code>\n        <location>/error400.jsp</location>\n    </error-page>\n```\n\n至此，web.xml的配置已经完成\n\n### springMVC的处理：\n\n此处转发的请求是到classpath:spring/springmvc.xml中\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n \n    <!-- 对于注解的Handler可以单个配置\n    实际开发中建议使用组件扫描\n     -->\n    <!-- <bean class=\"cn.itcast.ssm.controller.ItemsController3\" /> -->\n    <!-- 可以扫描controller、service、...\n    这里让扫描controller，指定controller的包\n     -->\n    <context:component-scan base-package=\"com.learn.controller\"></context:component-scan>\n     \n     \n    <!-- 处理器映射器 将bean的name作为url进行查找 ，需要在配置Handler时指定beanname（就是url） \n    所有的映射器都实现 HandlerMapping接口。\n    -->\n    <bean\n        class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\" />\n         \n    <!--注解映射器 -->\n    <!--<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\"/>-->\n    <!--注解适配器 -->\n    <!--<bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"/>-->\n     \n    <!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置\n    mvc:annotation-driven默认加载很多的参数绑定方法，\n    比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter\n    实际开发时使用mvc:annotation-driven\n     -->\n    <mvc:annotation-driven conversion-service=\"conversionService\"></mvc:annotation-driven>\n         \n    <!-- 自定义参数绑定 -->\n    <bean id=\"conversionService\"\n        class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\n        <!-- 转换器 -->\n        <property name=\"converters\">\n            <list>\n                <!-- 日期类型绑定器 -->\n                <bean class=\"com.learn.conv.DateConverter\" />\n            </list>\n        </property>\n    </bean>\n \n    <!-- 视图解析器\n    解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包\n     -->\n    <bean\n        class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <!-- 配置jsp路径的前缀 -->\n        <property name=\"prefix\" value=\"WEB-INF/jsp/\"/>\n        <!-- 配置jsp路径的后缀 -->\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n    <!-- 自定义的全局异常处理器 \n只要实现HandlerExceptionResolver接口就是全局异常处理器-->\n    <bean class=\"com.learn.exception.CustomExceptionResolver\"></bean>\n     \n     <!-- SpringMVC上传文件时，需要配置MultipartResolver处理器 -->  \n    <bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\">  \n        <!-- 指定所上传文件的总大小不能超过200KB。注意maxUploadSize属性的限制不是针对单个文件，而是所有文件的容量之和 -->  \n      <!--    <property name=\"maxUploadSize\" value=\"5242880\"/>  -->\n    </bean> \n     \n    <!--拦截器 -->\n<mvc:interceptors>\n    <!-- 登陆认证拦截器 -->\n    <mvc:interceptor>\n        <mvc:mapping path=\"/**\"/>\n        <bean class=\"com.learn.interceptor.LoginInterceptor\"></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n</beans>\n```\n\n同时这里贴出三个类（日期邦定器、登陆拦截器、全部异常处理 ）\n\n```java\npackage com.learn.exception;\n \nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n \nimport org.springframework.web.servlet.HandlerExceptionResolver;\nimport org.springframework.web.servlet.ModelAndView;\n \npublic class CustomExceptionResolver implements HandlerExceptionResolver{\n \n    public ModelAndView resolveException(HttpServletRequest request,\n            HttpServletResponse response, Object handler, Exception ex) {\n        // TODO Auto-generated method stub\n        CustomException customException = null;\n        if(ex instanceof CustomException){\n            customException = (CustomException)ex;\n        }else{\n            customException = new CustomException(\"未知错误\");\n        }\n         \n        //错误信息\n        String message = customException.getMessage();\n         \n         \n        ModelAndView modelAndView = new ModelAndView();\n         \n        //将错误信息传到页面\n        modelAndView.addObject(\"message\", message);\n         \n        //指向错误页面\n        modelAndView.setViewName(\"error\");\n \n         \n        return modelAndView;\n    }\n     \n}\n```\n\n```java\npackage com.learn.conv;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport org.springframework.core.convert.converter.Converter;\npublic class DateConverter implements Converter<String, Date>{\n    public Date convert(String souce) {\n        System.out.println(souce.length());\n        if(souce.length() == 19){\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n            try {\n                return format.parse(souce);\n            } catch (ParseException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }          \n        }else if(souce.length() == 10){\n            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd\");\n            try {\n                return format.parse(souce);\n            } catch (ParseException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n                return null;\n            }  \n        }else{\n            return null;\n        }\n    }\n}\n```\n\n```java\npackage com.learn.interceptor;\n \nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\n \nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n \n/** \n* @author  \n* @version 创建时间：2016年4月26日 下午4:42:38 \n*  \n*/\npublic class LoginInterceptor implements HandlerInterceptor{\n \n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object arg2, Exception arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n        System.out.println(\"HandlerInterceptor1...afterCompletion\");\n         \n    }\n \n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object arg2, ModelAndView arg3)\n            throws Exception {\n        // TODO Auto-generated method stub\n        System.out.println(\"HandlerInterceptor1...postHandle\");\n         \n    }\n \n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object arg2) throws Exception {\n        String url=request.getRequestURI();\n        //System.out.println(\"url---------\"+url+\"--\"+url.indexOf(\"getModule.action\"));\n    if(url.indexOf(\"index.action\")>=0 ||url.indexOf(\"toLogin.action\")>=0||url.indexOf(\"msgDetail.action\")>=0\n            ||url.indexOf(\"findMsg.action\")>=0||url.indexOf(\"getModule.action\")>=0||url.indexOf(\"getModule2.action\")>=0\n            ||url.indexOf(\"getModule3.action\")>=0||url.indexOf(\"findMsg.action\")>=0||url.indexOf(\"indexSkip.action\")>=0\n            ||url.indexOf(\"searchType.action\")>=0||url.indexOf(\"searchRSIndex.action\")>=0||url.indexOf(\"getModule.action\")>=0     \n//             \n            )\n        {\n \n            return true;\n        }      \n        //判断session\n                HttpSession session  = request.getSession();\n                //从session中取出用户身份信息\n                String usercode = (String) session.getAttribute(\"userName\");               \n                if(usercode != null){\n                    //身份存在，放行\n                    return true;\n                }\n                 \n        //执行这里表示用户身份需要认证，跳转登陆页面\n        request.setAttribute(\"loginFailed\", \"用户登陆过期!\"); \n        request.getRequestDispatcher(\"index.action\").forward(request,response); \n         \n        return true;\n        //return true;\n    }\n}\n```\n\n#### applicationContext-transaction.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n \n<!-- 事务管理器 \n    对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\n-->\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <!-- 数据源\n    dataSource在applicationContext-dao.xml中配置了\n     -->\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n \n<!-- 通知 -->\n<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\n    <tx:attributes>\n        <!-- 传播行为 -->\n        <tx:method name=\"save*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"delete*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"insert*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n        <tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n        <tx:method name=\"get*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n        <tx:method name=\"select*\" propagation=\"SUPPORTS\" read-only=\"true\"/>\n    </tx:attributes>\n</tx:advice>\n<!-- aop -->\n<aop:config>\n    <aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.learn.service.Impl.*.*(..))\"/>\n</aop:config>\n \n</beans>\n```\n\n#### applicationContext-service.xml\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd \n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd \n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-3.2.xsd \n        http://www.springframework.org/schema/aop \n        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd \n        http://www.springframework.org/schema/tx \n        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd \">\n         \n<context:component-scan base-package=\"com.learn.service.Impl\"></context:component-scan>\n<!-- service -->\n<bean id=\"msgService\" class=\"com.learn.service.Impl.MsgServiceImpl\"/>\n \n</beans>\n```\n\n#### applicationContext-dao.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n    xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd          \n      http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \n      http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd\">\n     \n    <!-- 加载db.properties文件的内容，db.properties文件中的key命名有一定的特殊规则 -->\n    <context:property-placeholder location=\"classpath:db.properties\"/>\n    <!--配置数据源,dbcp  -->\n    <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n                <!-- 数据连接信息 -->\n                <property name=\"driverClassName\" value=\"${jdbc.driver}\" />\n                <property name=\"url\" value=\"${jdbc.url}\" />\n                <property name=\"username\" value=\"${jdbc.username}\" />\n                <property name=\"password\" value=\"${jdbc.password}\" />\n                <property name=\"maxActive\" value=\"30\" />\n                <property name=\"maxIdle\" value=\"5\" />\n                 \n    </bean>\n    <!-- sqlsessionFactory -->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"> \n                 <property name=\"dataSource\" ref=\"dataSource\"></property>\n                 <property name=\"configLocation\" value=\"classpath:mybatis/sqlMapConfig.xml\"></property>\n    </bean>\n   <!--  <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\n        p:dataSource-ref=\"dataSource\" p:configLocation=\"classpath:mybatis/sqlMapConfig.xml\" />--> \n    <!-- mapper扫描器 -->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n                 <property name=\"basePackage\" value=\"com.learn.mapper\"></property>\n                 <property name=\"SqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"></property>\n    </bean>\n</beans>\n```\n\n#### sqlMapConfig.xml\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n<configuration>\n   <!-- 全局的setting配置，根据需要添加 -->\n   <typeAliases>\n     <!-- 批量扫描别名 -->\n     <package name=\"com.learn.po\"/>\n   </typeAliases>\n</configuration>\n```\n\n## 逆向生成文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE generatorConfiguration\n  PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n  \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n \n<generatorConfiguration>\n    <context id=\"testTables\" targetRuntime=\"MyBatis3\">\n        <commentGenerator>\n            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->\n            <property name=\"suppressAllComments\" value=\"true\" />\n        </commentGenerator>\n        <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->\n        <jdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\n            connectionURL=\"jdbc:mysql://127.0.0.1:3306/mk_notes\" userId=\"root\"\n            password=\"root\">\n        </jdbcConnection>\n        <!-- <jdbcConnection driverClass=\"oracle.jdbc.OracleDriver\"\n            connectionURL=\"jdbc:oracle:thin:@127.0.0.1:1521:yycg\" \n            userId=\"yycg\"\n            password=\"yycg\">\n        </jdbcConnection> -->\n \n        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n            NUMERIC 类型解析为java.math.BigDecimal -->\n        <javaTypeResolver>\n            <property name=\"forceBigDecimals\" value=\"false\" />\n        </javaTypeResolver>\n \n        <!-- targetProject:生成PO类的位置 -->\n        <javaModelGenerator targetPackage=\"com.learn.po\"\n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n            <!-- 从数据库返回的值被清理前后的空格 -->\n            <property name=\"trimStrings\" value=\"true\" />\n        </javaModelGenerator>\n        <!-- targetProject:mapper映射文件生成的位置 -->\n        <sqlMapGenerator targetPackage=\"com.learn.mapper\" \n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n        </sqlMapGenerator>\n        <!-- targetPackage：mapper接口生成的位置 -->\n        <javaClientGenerator type=\"XMLMAPPER\"\n            targetPackage=\"com.learn.mapper\" \n            targetProject=\".\\src\">\n            <!-- enableSubPackages:是否让schema作为包的后缀 -->\n            <property name=\"enableSubPackages\" value=\"false\" />\n        </javaClientGenerator>\n        <!-- 指定数据库表 -->\n        <table tableName=\"op_member_t\"></table>\n     \n    </context>\n</generatorConfiguration>\n```\n\n### 对应的java代码\n\n```java\npackage Generator;\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n \nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\npublic class GeneratorSqlmap {\n    public void generator() throws Exception{\n \n        List<String> warnings = new ArrayList<String>();\n        boolean overwrite = true;\n        //指定 逆向工程配置文件\n        File configFile = new File(\"config/generatorConfig.xml\"); \n        ConfigurationParser cp = new ConfigurationParser(warnings);\n        Configuration config = cp.parseConfiguration(configFile);\n        DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n                callback, warnings);\n        myBatisGenerator.generate(null);\n \n    } \n    public static void main(String[] args) throws Exception {\n        try {\n            GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap();\n            generatorSqlmap.generator();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n         \n    }\n}\n```\n\n## 整个项目的目录结构\n\n供参考\n\n![](https://static.oschina.net/uploads/space/2017/0616/161712_LaAq_3429289.png)\n\n\n# 基于javaconfig配置\n\n## 1    项目结构（SSM+MAVEN）\n\n### 1.1    目录结构\n\n![](https://static.oschina.net/uploads/space/2018/0322/155319_tg0n_3429289.png)\n\n### 1.2    POM文件\n\n        由于仓库是nexus私服，如遇见无法加载的包，请无视\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<groupId>com.test</groupId>\n\t<artifactId>ssmTest</artifactId>\n\t<packaging>war</packaging>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>ssmTest Maven Webapp</name>\n\t<url>http://maven.apache.org</url>\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>junit</groupId>\n\t\t\t<artifactId>junit</artifactId>\n\t\t\t<version>3.8.1</version>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.xmlbeans</groupId>\n\t\t\t<artifactId>xmlbeans</artifactId>\n\t\t\t<version>2.6.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi-ooxml-schemas</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi-ooxml</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.poi</groupId>\n\t\t\t<artifactId>poi</artifactId>\n\t\t\t<version>3.16</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-collections4</artifactId>\n\t\t\t<version>4.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.websocket</groupId>\n\t\t\t<artifactId>javax.websocket-api</artifactId>\n\t\t\t<version>1.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-websocket</artifactId>\n\t\t\t<version>4.0.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>jstl</groupId>\n\t\t\t<artifactId>jstl</artifactId>\n\t\t\t<version>1.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t\t<version>2.2.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.google.code.gson</groupId>\n\t\t\t<artifactId>gson</artifactId>\n\t\t\t<version>2.2.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.ezmorph</groupId>\n\t\t\t<artifactId>ezmorph</artifactId>\n\t\t\t<version>1.0.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>jcifs</groupId>\n\t\t\t<artifactId>jcifs</artifactId>\n\t\t\t<version>1.3.17</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-beanutils</groupId>\n\t\t\t<artifactId>commons-beanutils</artifactId>\n\t\t\t<version>1.7.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-collections</groupId>\n\t\t\t<artifactId>commons-collections</artifactId>\n\t\t\t<version>3.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.json-lib</groupId>\n\t\t\t<artifactId>json-lib-ext-spring</artifactId>\n\t\t\t<version>1.0.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>log4j</groupId>\n\t\t\t<artifactId>log4j</artifactId>\n\t\t\t<version>1.2.17</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-lang</groupId>\n\t\t\t<artifactId>commons-lang</artifactId>\n\t\t\t<version>2.6</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-io</groupId>\n\t\t\t<artifactId>commons-io</artifactId>\n\t\t\t<version>2.0.1</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-fileupload</groupId>\n\t\t\t<artifactId>commons-fileupload</artifactId>\n\t\t\t<version>1.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis</groupId>\n\t\t\t<artifactId>mybatis-spring</artifactId>\n\t\t\t<version>1.2.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-dbcp</groupId>\n\t\t\t<artifactId>commons-dbcp</artifactId>\n\t\t\t<version>1.4</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-pool</groupId>\n\t\t\t<artifactId>commons-pool</artifactId>\n\t\t\t<version>1.5.6</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.aspectj</groupId>\n\t\t\t<artifactId>aspectjweaver</artifactId>\n\t\t\t<version>1.6.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis</groupId>\n\t\t\t<artifactId>mybatis</artifactId>\n\t\t\t<version>3.2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t<artifactId>mybatis-generator</artifactId>\n\t\t\t<version>1.3.5</version>\n\t\t\t<type>pom</type>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t<artifactId>mybatis-generator-core</artifactId>\n\t\t\t<version>1.3.5</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-logging</groupId>\n\t\t\t<artifactId>commons-logging</artifactId>\n\t\t\t<version>1.1.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet.jsp</groupId>\n\t\t\t<artifactId>jsp-api</artifactId>\n\t\t\t<version>2.2</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>javax.servlet</groupId>\n\t\t\t<artifactId>servlet-api</artifactId>\n\t\t\t<version>2.5</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>aopalliance</groupId>\n\t\t\t<artifactId>aopalliance</artifactId>\n\t\t\t<version>1.0</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-webmvc</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-aop</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-aspects</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-context</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-beans</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-context-support</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-core</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-expression</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-jdbc</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-tx</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-test</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-web</artifactId>\n\t\t\t<version>4.2.5.RELEASE</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-pool2</artifactId>\n\t\t\t<version>2.2</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.codehaus.jackson</groupId>\n\t\t\t<artifactId>jackson-core-asl</artifactId>\n\t\t\t<version>1.9.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.codehaus.jackson</groupId>\n\t\t\t<artifactId>jackson-mapper-asl</artifactId>\n\t\t\t<version>1.9.11</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>net.sf.json-lib</groupId>\n\t\t\t<artifactId>json-lib</artifactId>\n\t\t\t<version>2.3</version>\n\t\t\t<classifier>jdk15</classifier>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<version>5.1.20</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>javax.mail</groupId>\n\t\t\t<artifactId>mail</artifactId>\n\t\t\t<version>1.4.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-net</groupId>\n\t\t\t<artifactId>commons-net</artifactId>\n\t\t\t<version>3.3</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>commons-codec</groupId>\n\t\t\t<artifactId>commons-codec</artifactId>\n\t\t\t<version>1.10</version>\n\t\t</dependency>\n\t</dependencies>\n\t<build>\n\t\t<finalName>ssmTest</finalName>\n\t</build>\n</project>\n\n```\n\n## 2    配置SPRINGMVC\n\n### 2.1    初始化\n\n         首先创建一个初始化类，继承AbstractAnnotationConfigDispatcherServletInitializer类\n\n```java\npackage com.ssm.config;\n\nimport org.apache.log4j.Logger;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\n/**\n * \n * @author C\n *\n */\npublic class WebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\tprivate final static Logger LOG = Logger.getLogger(WebAppInitializer.class);\n\n\t@Override\n\tprotected Class<?>[] getRootConfigClasses() {\n\t\t// TODO Auto-generated method stub\n\t\tLOG.info(\"------root配置类初始化------\");\n\t\treturn new Class<?>[] { RootConfig.class };\n\t}\n\n\t@Override\n\tprotected Class<?>[] getServletConfigClasses() {\n\t\tLOG.info(\"------web配置类初始化------\");\n\t\t return new Class<?>[] { WebConfig.class };\n\t}\n\n\t@Override\n\tprotected String[] getServletMappings() {\n\t\t// TODO Auto-generated method stub\n\t\tLOG.info(\"------映射根路径初始化------\");\n\t\t//return null;\n\t\t return new String[] {\"/\"};// 请求路径映射，将路径映射到DispatcherServlet上\n\t}\n\n}\n\n```\n\n这里继承AbstractAnnotationConfigDispatcherServletInitializer 类，就会自动个地配置Dispatcher-Servlet和Spring上下文(传统的方法是在web.xml中配置 DispatcherServlet)\n\n### 2.2    AbstractAnnotationConfigDispatcherServletInitializer剖析\n\n         Servlet3.0环境中，容器会在类路径去查找实现javax.servlet.ServletContainerInitializer接口的类，如果发现，就用它做servlet的容器\n    \n        Spring对这个接口进行了实现，为SpringServletContainerInitializer。它( SpringServletContainerInitializer )会去查找实现了WebAppInitializer的类并将配置任务交给他们来完成。Spring3.2引入了便利的 WebAppInitializer 实现，就是AbstractAnnotationConfigDispatcherServletInitializer。所以当部署到Servlet3.0容器中时，容器会自动发现它，并配置servlet上下文\n    \n         重新的三个方法也有对应注解，这里不再多说\n\n### 2.3  WebConfig配置\n\n        当DispatcherServlet启动的时候，会创建Spring应用上下文并加载配置文件或配置文件中声明的bean。\n    \n        当它加载上下文时，使用定义在WebConfig中的bean(基于java配置)\n    \n        DispatcherServlet 加载包含web组件的bean，如控制器，视图解析器等。还有一个ContextLoaderListener加载其他bean，如中间层及数据层组件等\n\n```java\npackage com.ssm.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.multipart.commons.CommonsMultipartResolver;\nimport org.springframework.web.servlet.ViewResolver;\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\n\n/****\n * 定义 DispatcherServlet 加载应用上下文的配置\n * \n * @author C\n *\n */\n@Configuration\n@EnableWebMvc\n@ComponentScan(\"com.ssm.controller\") // 包扫描\npublic class WebConfig extends WebMvcConfigurerAdapter{\n\t@Bean\n\tpublic ViewResolver viewResolver() {\n\t\tInternalResourceViewResolver resolver = new InternalResourceViewResolver();\n\t\tresolver.setPrefix(\"/WEB-INF/jsp\");\n\t\tresolver.setSuffix(\".jsp\");\n\t\treturn resolver;\n\t}\n\n\t@Bean(name = \"multipartResolver\") // bean必须写name属性且必须为multipartResolver\n\tprotected CommonsMultipartResolver multipartResolver() {\n\t\tCommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();\n\t\tcommonsMultipartResolver.setMaxUploadSize(5 * 1024 * 1024);\n\t\tcommonsMultipartResolver.setMaxInMemorySize(0);\n\t\tcommonsMultipartResolver.setDefaultEncoding(\"UTF-8\");\n\t\treturn commonsMultipartResolver;\n\t}\n\n\t// 静态资源的处理\n\tpublic void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n\t\tconfigurer.enable();\n\t}\n}\n\n```\n\n@Configuration：配置类\n\n@EnableWebMvc：相当于基于xml配置的<mvc:annotation-driven>启用注解驱动\n\n@ComponentScan：包扫描\n\n## 3    RootConfig配置\n\n```java\npackage com.ssm.config;\n\nimport org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n\n/***\n * 主要配置持久层的一些东西，包括数据库、Mybatis框架，事务之类的\n * \n * @author C\n *\n */\n@Configuration\n@ComponentScan(basePackages = { \"com.ssm.config\", \"com.ssm.service.impl\" })\n@Import(DataSourceConfig.class)\npublic class RootConfig {\n\t@Bean\n\tpublic BeanNameAutoProxyCreator autoProxyCreator() {\n\t\tBeanNameAutoProxyCreator autoProxyCreator = new BeanNameAutoProxyCreator();\n\t\tautoProxyCreator.setProxyTargetClass(true);\n\t\t// 设置要创建代理的那些Bean的名字\n\t\tautoProxyCreator.setBeanNames(\"*Service\");\n\t\tautoProxyCreator.setInterceptorNames(\"transactionInterceptor\");\n\t\treturn autoProxyCreator;\n\t}\n\n}\n\n```\n\n这里数据库的事务配置方式有三种：\n\n-   第一种在 RootConfig加上 @EnableTransactionManagement 注解，配置数据库， 手动加上事务使用 [@Transactional](https://my.oschina.net/u/3770144) 注解，并且指定的传播属性，缺点麻烦\n-   第二种使用 BeanNameAutoProxyCreator拦截代理方式\n-   第三种是采用aop切面事务\n\n## 4    DataSourceConfig\n\n        这里由于我用的1.7的JDK，@PropertySources会报错，作为学习，就直接将properties文件写到类里面了\n\n```java\npackage com.ssm.config;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\nimport org.apache.commons.dbcp.BasicDataSource;\nimport org.apache.log4j.Logger;\nimport org.mybatis.spring.SqlSessionFactoryBean;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.PropertySource;\nimport org.springframework.context.annotation.PropertySources;\nimport org.springframework.core.io.support.PathMatchingResourcePatternResolver;\nimport org.springframework.core.io.support.ResourcePatternResolver;\nimport org.springframework.jdbc.datasource.DataSourceTransactionManager;\nimport org.springframework.transaction.interceptor.TransactionInterceptor;\n\n@Configuration\n/*@PropertySources(value = { @PropertySource(\"classpath:db.properties\") }) */\n@MapperScan(\"com.ssm.mapper\")\npublic class DataSourceConfig {\n\tprivate final static Logger LOG = Logger.getLogger(DataSourceConfig.class);\n\n\tprivate String driver = \"com.mysql.jdbc.Driver\";;\n\n\tprivate String url = \"jdbc:mysql://127.0.0.1:3306/test?characterEncoding=UTF-8&zeroDateTimeBehavior=convertToNull&transformedBitIsBoolean=true&autoReconnect=true\";\n\n\tprivate String username = \"root\";\n\n\tprivate String password = \"root\";\n\n\t@Bean\n\tpublic BasicDataSource dataSource() {\n\t\tLOG.info(\"Initialize the BasicDataSource...\");\n\t\tBasicDataSource dataSource = new BasicDataSource();\n\t\tdataSource.setDriverClassName(driver);\n\t\tdataSource.setUrl(url);\n\t\tdataSource.setUsername(username);\n\t\tdataSource.setPassword(password);\n\t\treturn dataSource;\n\t}\n\n\t// mybatis的配置\n\t@Bean\n\tpublic SqlSessionFactoryBean sqlSessionFactoryBean() throws IOException {\n\t\tResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\t\tSqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();\n\t\tsqlSessionFactoryBean.setDataSource(dataSource());\n\t\tsqlSessionFactoryBean.setMapperLocations(resourcePatternResolver.getResources(\"classpath*:mappers/*.xml\"));\n\t\tsqlSessionFactoryBean.setTypeAliasesPackage(\"com.ssm.mapper\");// 别名，让*Mpper.xml实体类映射可以不加上具体包名\n\t\treturn sqlSessionFactoryBean;\n\t}\n\n\t// 事务管理器 对mybatis操作数据库事务控制，spring使用jdbc的事务控制类\n\t@Bean(name = \"transactionManager\")\n\tpublic DataSourceTransactionManager dataSourceTransactionManager() {\n\t\tDataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();\n\t\tdataSourceTransactionManager.setDataSource(dataSource());\n\t\treturn dataSourceTransactionManager;\n\t}\n\n\t@Bean(name = \"transactionInterceptor\")\n\tpublic TransactionInterceptor interceptor() {\n\t\tTransactionInterceptor interceptor = new TransactionInterceptor();\n\t\tinterceptor.setTransactionManager(dataSourceTransactionManager());\n\t\tProperties transactionAttributes = new Properties();\n\t\ttransactionAttributes.setProperty(\"save*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"del*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"update*\", \"PROPAGATION_REQUIRED\");\n\t\ttransactionAttributes.setProperty(\"get*\", \"PROPAGATION_REQUIRED,readOnly\");\n\t\ttransactionAttributes.setProperty(\"find*\", \"PROPAGATION_REQUIRED,readOnly\");\n\t\ttransactionAttributes.setProperty(\"*\", \"PROPAGATION_REQUIRED\");\n\t\tinterceptor.setTransactionAttributes(transactionAttributes);\n\t\treturn interceptor;\n\t}\n}\n\n```\n\n## 5    测试\n\n```java\npackage com.ssm.controller;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.ssm.service.IndexService;\nimport com.sun.mail.handlers.image_gif;\n\n@RestController\npublic class IndexController {\n\t@Autowired\n\tprivate IndexService indexService;\n\n\t@RequestMapping(\"index\")\n\tpublic String index() {\n\t\treturn \"THIS IS A TEST.WELCOME\";\n\t}\n\n\t@RequestMapping(\"getData\")\n\tpublic String getData() {\n\t\treturn indexService.findUser();\n\t}\n\n}\n\n```\n\n### 5.1访问servlet\n\n![](https://static.oschina.net/uploads/space/2018/0322/165245_2jbO_3429289.png)\n\n### 5.2访问数据库\n\n![](https://static.oschina.net/uploads/space/2018/0322/165508_siNA_3429289.png)![](https://static.oschina.net/uploads/space/2018/0322/165413_GwmS_3429289.png)"},{"title":"dubbo+zookeeper 入门","url":"/2018/03/07/中间件/dubbo/DUBBO+ZOOKEEPER入门/","content":"\n采用spring3.2+dubbo2.5.3+zookeeper3.3.6\n\n所需架包如图所示   \n\n![](DUBBO+ZOOKEEPER入门\\1.png)\n\n# 1.安装zookeeper\n\n本文采用zookeeper-3.3.6，可自行查找下载。下载后进入conf目录下，修改zoo_sample.cfg为zoo.cfg。该文件为zookeeper的配置文件\n\n```bash\n# The number of milliseconds of each tick\ntickTime=2000\n# The number of ticks that the initial \n# synchronization phase can take\ninitLimit=10\n# The number of ticks that can pass between \n# sending a request and getting an acknowledgement\nsyncLimit=5\n# the directory where the snapshot is stored.\ndataDir=/tmp/zookeeper\n# the port at which the clients will connect\nclientPort=2181\n```\n\ntickTime：基本事件单元，以毫秒为单位。**它用来控制心跳和超时，默认情况下最小的会话超时时间为两倍的 tickTime。**\n\ndataDir：存放内存数据的地方\n\nclientPort：用户于zookeeper相连的端口\n\ninitLimit：Leader允许F在 **initLimit** 时间内完成这个工作，请求和响应时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 10*2000=20 秒\n\nsyncLimit：检测机器的存活状态，请求和响应时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 5*2000=10 秒\n\n此处需注意这种文件\n\n```bash\ntickTime=2000\ndataDir=/usr/zdatadir\ndataLogDir=/usr/zlogdir\nclientPort=2181\ninitLimit=5\nsyncLimit=2\nserver.1=cloud:2888:3888\nserver.2=cloud02:2888:3888\nserver.3=cloud03:2888:3888\nserver.4=cloud04:2888:3888\nserver.5=cloud05:2888:3888\n```\n\n**server.A=B：C：D：**其中 A 是一个数字，表示这个是第几号服务器；**B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。**如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号\n\n除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，**Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。**\n\n![](DUBBO+ZOOKEEPER入门\\2.png)\n\n# 2.启动zookeeper\n\n此处我用的为第一个配置文件，并没有配置集群。直接打开zookeeper-3.3.6\\\\bin\\\\zkServer.cmd，这里我是window环境，linux环境运行.sh文件\n\n# 3.dubbo\n\n通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。\n    \ndubbo就是一个服务框架，可以实现调用远程接口像调用本地接口一样方便。\n    \n这里注册中心我们选择zookeeper\n\n## 3.1安装Dubbo-admin，实现监控\n\n这里我安装的是dubbo-admin-2.5.3.war，部署到tomcat的webapps下，修改webapps\\\\dubbo-admin-2.5.3\\\\WEB-INF\\\\dubbo.properties文件，内容如下\n\n```ini\ndubbo.registry.address=zookeeper://127.0.0.1:2181\ndubbo.admin.root.password=root\ndubbo.admin.guest.password=guest\n```\n\n其中root和guest都为密码。\n\n启动tomcat，效果如下(如提示输出账号信息，输入root，root)\n\n![](DUBBO+ZOOKEEPER入门\\3.png)\n\n## 3.2dubbo流程\n\nprovider注册----生产---->zookeeper<----消费--------consumer\n    \n生产者将接口信息注册到zookeper，消费者通过zookeeper进行消费\n\n## 3.3生产者注册\n\nProvider.java文件如下\n\n```java\npackage com.dubbotest.provider;\n \nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n \npublic class Provider {\n \n    public static void main(String[] args) throws Exception {\n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext-service.xml\");\n        context.start();\n        System.out.println(\"-----------\");\n        System.in.read(); // 为保证服务一直开着，利用输入流的阻塞来模拟,任意键退出\n    }\n}\n```\n\napplicationContext-service.xml如下\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n        http://code.alibabatech.com/schema/dubbo  \n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd  \n        \">\n \n    <bean id=\"user\" class=\"com.model.User\">\n        <property name=\"name\" value=\"person\" />\n    </bean>\n \n    <!-- 具体的实现bean -->\n    <bean id=\"demoService\" class=\"com.dubbotest.provider.DemoServiceImpl\" />\n \n    <!-- 提供方应用信息，用于计算依赖关系 -->\n    <dubbo:application name=\"xixi_provider\" />\n \n    <!-- 使用multicast广播注册中心暴露服务地址 <dubbo:registry address=\"multicast://224.5.6.7:1234\" \n        /> -->\n \n    <!-- 使用zookeeper注册中心暴露服务地址 -->\n    <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />\n \n    <!-- 用dubbo协议在20880端口暴露服务 -->\n    <dubbo:protocol name=\"dubbo\" port=\"20880\" />\n \n    <!-- 声明需要暴露的服务接口 -->\n    <!-- <dubbo:service interface=\"com.dubbotest.provider.DemoService\" ref=\"demoService\" \n        /> -->\n    <dubbo:service interface=\"com.dubbotest.provider.DemoService\"\n        ref=\"demoService\" />\n \n</beans>\n```\n\n运行了provider中的main函数后可以在dubbo-admin管理中看见接口信息。\n\n![](DUBBO+ZOOKEEPER入门\\4.png)\n\n## 3.4consumer消费\n\nConsumer.java如下\n\n```java\npackage com.dubbotest.consumer;\n \nimport java.util.List;\n \nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n \nimport com.dubbotest.provider.DemoService;\nimport com.model.User;\n \npublic class Consumer {\n \n    public static void main(String[] args) throws Exception {  \n        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(  \n                new String[] { \"applicationContext-dubbo.xml\" });  \n        context.start();  \n        DemoService demoService = (DemoService) context.getBean(\"demoService\"); \n        String hello = demoService.sayHello(\"tom\"); \n        System.out.println(hello); \n        List<User> list = demoService.getUsers();  \n        if (list != null && list.size() > 0) {  \n            for (int i = 0; i < list.size(); i++) {  \n                System.out.println(list.get(i).toString());  \n            }  \n        }  \n        System.in.read();  \n    }  \n}\n```\n\napplicationContext-dubbo.xml如下\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\"  \n        xsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n            http://www.springframework.org/schema/beans/spring-beans.xsd  \n            http://code.alibabatech.com/schema/dubbo  \n            http://code.alibabatech.com/schema/dubbo/dubbo.xsd  \n            \">  \n        \n        <!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 -->  \n        <dubbo:application name=\"hehe_consumer\" />  \n       \n        <!-- 使用zookeeper注册中心暴露服务地址 -->  \n        <!-- <dubbo:registry address=\"multicast://224.5.6.7:1234\" /> -->  \n        <dubbo:registry address=\"zookeeper://127.0.0.1:2181\" />  \n       \n        <!-- 生成远程服务代理，可以像使用本地bean一样使用demoService -->  \n        <dubbo:reference id=\"demoService\"  \n            interface=\"com.dubbotest.provider.DemoService\" />  \n       \n</beans>\n```\n\n运行后结果如图 ：\n\n![](DUBBO+ZOOKEEPER入门\\5.png)\n\n## 3.5其他文件：\n\nDemoService.java\n\n```java\npackage com.dubbotest.provider;\n \nimport java.util.List;\n \npublic interface DemoService {\n    String sayHello(String name);  \n       \n    public List getUsers();  \n}\n```\n\nDemoServiceImpl.java\n\n```java\npackage com.dubbotest.provider;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \nimport org.springframework.stereotype.Component;\n \nimport com.alibaba.dubbo.config.annotation.Service;\nimport com.model.User;\n \n@Service(version=\"1.0\")//此处Component是Spring bean注解，Service是dubbo的注解\npublic class DemoServiceImpl implements DemoService{\n \n    @Override\n    public String sayHello(String name) {\n        // TODO Auto-generated method stub\n         return \"Hello \" + name;  \n    }\n \n    @Override\n    public List getUsers() {\n          List list = new ArrayList();  \n             User u1 = new User();  \n             u1.setName(\"jack\");  \n             u1.setAge(20);  \n             u1.setSex(\"男\");  \n                \n             User u2 = new User();  \n             u2.setName(\"tom\");  \n             u2.setAge(21);  \n             u2.setSex(\"女\");  \n                \n             User u3 = new User();  \n             u3.setName(\"rose\");  \n             u3.setAge(19);  \n             u3.setSex(\"女\");  \n                \n             list.add(u1);  \n             list.add(u2);  \n             list.add(u3);  \n             return list;  \n    }\n \n}\n```\n\nUser.java\n\n```java\npackage com.model;\n \nimport java.io.Serializable;\n \npublic class User implements Serializable{\n     \n    private String name;\n    private String sex;\n    private int age;\n \n    @Override\n    public String toString() {\n        return \"User [name=\" + name + \", sex=\" + sex + \", age=\" + age + \"]\";\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public String getSex() {\n        return sex;\n    }\n \n    public void setSex(String sex) {\n        this.sex = sex;\n    }\n \n    public int getAge() {\n        return age;\n    }\n \n    public void setAge(int age) {\n        this.age = age;\n    }\n \n}\n```","tags":["dubbo"]},{"title":"Spring源码学习——自定义标签","url":"/2017/11/28/框架系列/spring/spring-自定义标签/","content":"\n# 1.自定义标签步骤\n\n1.  创建一个需要扩展的组件\n2.  定义xsd文件描述组件内容\n3.  创建一个文件，实现BeanDefinitionParser接口，解析xsd文件中的定义和组件定义\n4.  创建handler文件，扩展NamespaceHandlerSupport，注册组件到spring容器\n5.  编写spring.handlers和spring.schemas文件\n\n# 2.代码如下\n\n## 1.编写pojo\n\n```java\npublic class User {\n\t\n\tprivate String name;\n\tprivate String sex;\n\tprivate int age;\n//省略getter、setter\n\n}\n```\n\n## 2.xsd文件描述组件内容\n\n```xml\n<?xml version=\"1.0\"?>\n<schema xmlns=\"http://www.w3.org/2001/XMLSchema\" targetNamespace=\"http://www.springtest.com/schema/user\"\n\txmlns:tns=\"http://www.springtest.com/schema/user\" elementFormDefault=\"qualified\">\n\t<!-- 表示数据类型等定义来自w3 -->\n\t<!--表示文档中要定义的元素来自什么命名空间 -->\n\t<!--表示此文档的默认命名空间是什么 -->\n\t<!--表示要求xml文档的每一个元素都要有命名空间指定 -->\n\n\t<!-- ……定义主体部分…… -->\n\t<element name=\"user\">\n\t\t<complexType>\n\t\t\t<attribute name=\"id\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"name\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"sex\" type=\"string\"></attribute>\n\t\t\t<attribute name=\"age\" type=\"int\"></attribute>\n\t\t</complexType>\n\t</element>\n\n</schema>\n```\n\n描述了一个新的targetNamespace，并定义了一个name是user的element，有id，name，sex，age属性\n\n## 3.创建类，实现BeanDefinitionParser接口\n\n```java\npackage test.customtag;\n\nimport org.springframework.beans.factory.support.BeanDefinitionBuilder;\nimport org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;\nimport org.springframework.util.StringUtils;\nimport org.w3c.dom.Element;\n\nimport com.model.User;\n\npublic class UserBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {\n\t// Element对应的类\n\tprotected Class getBeanClass(Element element) {\n\t\treturn User.class;\n\t}\n\n\t// 从element中解析并提取对应的元素\n\tprotected void doParse(Element element, BeanDefinitionBuilder bean) {\n\t\tString name = element.getAttribute(\"name\");\n\t\tString sex = element.getAttribute(\"sex\");\n\t\tString age = element.getAttribute(\"age\");\n\t\t// 将提取的数据放入到BeanDefinitionBuilder中，将所有beanbeanFactory中\n\t\tif (StringUtils.hasText(name)) {\n\t\t\tbean.addPropertyValue(\"name\", name);\n\t\t}\n\t\tif (StringUtils.hasText(sex)) {\n\t\t\tbean.addPropertyValue(\"sex\", sex);\n\t\t}\n\t\tif (StringUtils.hasText(age)) {\n\t\t\tbean.addPropertyValue(\"age\", Integer.parseInt(age));\n\t\t}\n\n\t}\n\n}\n```\n\n## 4.创建handler文件，注册spring容器\n\n```java\npackage test.customtag;\n\nimport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n\n/******创建handler文件，组件注册到spring容器***/\npublic class MyNamespaceHandler extends NamespaceHandlerSupport{\n\n\t@Override\n\tpublic void init() {\n\t\t// TODO Auto-generated method stub\n\t\tregisterBeanDefinitionParser(\"user\", new UserBeanDefinitionParser());\n\t}\n\n}\n```\n\n## 5.编写spring.handlers和spring.schemas文件，默认在工程的/META-INF/文件下\n\nspring.handlers\n\n```xml\nhttp\\://www.springtest.com/schema/user=test.customtag.MyNamespaceHandler\n```\n\nspring.schemas\n\n```xml\nhttp\\://www.springtest.com/schema/user.xsd=META-INF/Spring-test.xsd\n```\n\n此处注意：\n\n这里因为我创建的是java项目，直接在项目下建造META-INF会提示找不到对应的文件，所以这里是将文件打包成jar包导入到项目中。如下图所示\n\n![](https://static.oschina.net/uploads/space/2017/1128/113739_vNLU_3429289.png)![](https://static.oschina.net/uploads/space/2017/1128/113750_HHla_3429289.png)\n\n## 6.测试\n\n导入自定义标签\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n\txmlns:myname=\"http://www.springtest.com/schema/user\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans  \n        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd  \n        http://www.springtest.com/schema/user\n       \thttp://www.springtest.com/schema/user.xsd\n        \">\n\t<myname:user id=\"testBean\" name=\"aaaaaa\" sex=\"dsaf\" age=\"12\"></myname:user>\n</beans>\n```\n\n测试代码\n\n```java\n\npublic class Test {\n\t/****测试输出*/\n\t@org.junit.Test\n\tpublic void test1(){\n\t\tSystem.out.println(\"--------\");\n\t\tApplicationContext act=new ClassPathXmlApplicationContext(\"applicationContext-service.xml\");\n\t\tUser u=(User) act.getBean(\"testBean\");\n\t\tSystem.out.println(\"--------------\"+u.toString());\n\t}\n}\n```\n\n输出结果\n\n![](https://static.oschina.net/uploads/space/2017/1128/113515_sKwH_3429289.png)\n\n# 3.整个项目结构\n\n![](https://static.oschina.net/uploads/space/2017/1128/113903_VcT2_3429289.png)\n\n参考自：spring源码深度解析","tags":["spring"]},{"title":"springMVC使用websocket实现在线客服","url":"/2017/10/17/框架系列/websocket实现在线客服/","content":"\n# 1.环境\n\nspringMVC+spring+mybatis（spring4.0以上）\n\n注意需要导入spring-websocket和websocket-api包。其余架包正常ssm即可，可自行百度\n\n```xml\n<dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-websocket</artifactId>\n      <version>4.0.5.RELEASE</version> \n    </dependency>\n<dependency> \n    \t<groupId>javax.websocket</groupId>\n    \t<artifactId>javax.websocket-api</artifactId>\n    \t<version>1.1</version>\n    \t<scope>provided</scope>\n\t</dependency>\n```\n\n# 2.后台代码\n\n        用Map存放当前登录的账户及其对应的session\n\n提出几点解释：\n\n1.  @ServerEndpoint：把当前类变成websocket服务类\n2.  @OnOpen： 连接时执行\n3.  @OnClose：关闭时执行\n4.  @OnMessage：收到消息时执行\n5.  @OnError：连接错误时执行\n\n```java\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * @Description: 简单websocket demo *\n */\n@ServerEndpoint(value = \"/websocketTest/{userId}\")//@ServerEndpoint把当前类变成websocket服务类\npublic class WebsocketTest {\n\tprivate Logger logger = LoggerFactory.getLogger(WebsocketTest.class);\n\tprivate static String userId;\n\t// 连接的用户\n\tprivate static Map<String, Session> onlines = new HashMap<String, Session>();\n\n\t// 连接时执行\n\t@OnOpen\n\tpublic void onOpen(@PathParam(\"userId\") String userId, Session session) throws IOException {\n\t\tthis.userId = userId;\n\t\tonlines.put(userId, session);\n\t\tSystem.out.println(\"新连接：\" + userId);\n\n\t}\n\n\t// 关闭时执行\n\t@OnClose\n\tpublic void onClose(@PathParam(\"userId\") String userId) {\n\t\tif (onlines.containsKey(userId)) {\n\t\t\tonlines.remove(userId);\n\t\t}\n\t\tSystem.out.println(\"连接close：\" + this.userId + \" 关闭\");\n\t}\n\n\t// 收到消息时执行\n\t@OnMessage\n\tpublic void onMessage(String message, Session session, @PathParam(\"userId\") String userId) throws IOException {\n\t\tSystem.out.println(message);\n\t\tif (message.contains(\"&\")) {\n\t\t\tString[] params = message.split(\"&\");\n\t\t\tif (params[1].equals(\"all\")) {\n\t\t\t\tSystem.out.println(\"广播\");\n\t\t\t\tsendMessageToAll(userId + \"发送广播消息:\" + params[0]);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"toUser\");\n\t\t\t\tsendMessageToUser(userId, params[1], params[0]);\n\t\t\t\t;\n\t\t\t}\n\t\t}else\n\t\t\t session.getBasicRemote().sendText(userId+\"发送消息： \" + message); \n\t\tSystem.out.println(onlines.toString());\n\t}\n\n\t\n\n\n\t// 连接错误时执行\n\t@OnError\n\tpublic void onError(Session session, Throwable error) {\n\t\tSystem.out.println(\"用户id为：\" + this.userId + \"的连接发送错误\");\n\t\terror.printStackTrace();\n\t}\n\n\t/**\n\t * 广播消息给所有人\n\t * **/\n\t\tprivate void sendMessageToAll(String message) {\n\t\t\tSet<String> users = onlines.keySet();\n\t\t\tfor (String user : users) {\n\t\t\t\ttry {\n\t\t\t\t\tif (onlines.get(user).isOpen()) {\n\t\t\t\t\t\t((Session) onlines.get(user)).getBasicRemote().sendText(message);\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t/******\n\t *  给某个用户发送消息 \n\t * @Param userName 发消息的name\n\t * **/\n\t\tprivate void sendMessageToUser(String userName, String receiveName, String message) {\n\t\t\tSet<String> users = onlines.keySet();\n\t\t\tfor (String user : users) {\n\t\t\t\tif (user.equals(receiveName)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (onlines.get(user).isOpen()) {\n\t\t\t\t\t\t\tSystem.out.println(\"user---\" + user);\n\t\t\t\t\t\t\t((Session) onlines.get(user)).getBasicRemote().sendText(userName + \"给你发了消息：\" + message);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\n```\n\n# 3.html\n\n## 一、操作类html\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\t广播消息---- admin\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<select id=\"toUser\" >\n\t<option id=\"toUser\" value=\"all\">ALL</option>\n\t<option id=\"toUser\" value=\"user001\">user001</option>\n\t<option id=\"toUser\" value=\"user002\">user002</option>\n\t</select>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/admin\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\tvar user = document.getElementById('toUser').value;\n\t\t\tmessage+='&'+user;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n## 二、接收类1\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\twebsocket Demo---- user001\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/user001\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n## 三、接收类2\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title></title>\n</head>\n<body>\n\twebsocket Demo---- user002\n\t<br />\n\t<input id=\"text\" type=\"text\" />\n\t<button onclick=\"send()\">Send</button>\n\t<button onclick=\"closeWebSocket()\">Close</button>\n\t<div id=\"message\"></div>\n\t<script type=\"text/javascript\">\n\t\t//判断当前浏览器是否支持WebSocket\n\t\tif ('WebSocket' in window) {\n\t\t\twebsocket = new WebSocket(\n\t\t\t\t\t\"ws://localhost:8088/IM/websocketTest/user002\");\n\t\t\tconsole.log(\"link success\")\n\t\t} else {\n\t\t\talert('Not support websocket')\n\t\t}\n\t\t//连接发生错误的回调方法\n\t\twebsocket.onerror = function() {\n\t\t\tsetMessageInnerHTML(\"error\");\n\t\t};\n\t\t//连接成功建立的回调方法\n\t\twebsocket.onopen = function(event) {\n\t\t\tsetMessageInnerHTML(\"open\");\n\t\t}\n\t\tconsole.log(\"-----\")\n\t\t//接收到消息的回调方法\n\t\twebsocket.onmessage = function(event) {\n\t\t\tsetMessageInnerHTML(event.data);\n\t\t}\n\t\t//连接关闭的回调方法\n\t\twebsocket.onclose = function() {\n\t\t\tsetMessageInnerHTML(\"close\");\n\t\t}\n\t\t//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 \n\t\twindow.onbeforeunload = function() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//将消息显示在网页上\n\t\tfunction setMessageInnerHTML(innerHTML) {\n\t\t\tdocument.getElementById('message').innerHTML += innerHTML + '<br/>';\n\t\t}\n\t\t//关闭连接\n\t\tfunction closeWebSocket() {\n\t\t\twebsocket.close();\n\t\t}\n\t\t//发送消息\n\t\tfunction send() {\n\t\t\tvar message = document.getElementById('text').value;\n\t\t\twebsocket.send(message);\n\t\t}\n\t</script>\n</body>\n</html>\n\n```\n\n4.具体效果\n\n截图如下，实现简单web聊天功能。\n\n","tags":["springmvc"]},{"title":"Shiro简介","url":"/2017/09/02/中间件/shiro/Apache-shiro学习/","content":"\n# 1.Shiro简介\n\nShiro 可以帮助我们完成：认证、授权、加密、会话管理、与Web 集成、缓存等\n\n![](https://static.oschina.net/uploads/space/2017/0902/160620_MqP6_3429289.png)\n\n其中工作原理主要如图，进入后创建一个Subject（即为当前用户），然后SecurityManager管理所有Subject，这里可以理解为于SpringMVC的DispatcherServlet，最后我们Realm相当于是一个数据源，管理用户身份是否合法。\n\n# 2.入门示例\n\n```java\n@Test\npublic void testHelloworld() {\n//1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager\nFactory<org.apache.shiro.mgt.SecurityManager> factory =\nnew IniSecurityManagerFactory(\"classpath:shiro.ini\");\n//2、得到SecurityManager实例并绑定给SecurityUtils\norg.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();\nSecurityUtils.setSecurityManager(securityManager);\n//3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）\nSubject subject = SecurityUtils.getSubject();\nUsernamePasswordToken token = new UsernamePasswordToken(\"zhang\", \"123\");\ntry {\n//4、登录，即身份验证\nsubject.login(token);\n} catch (AuthenticationException e) {\n//5、身份验证失败\n}\nAssert.assertEquals(true, subject.isAuthenticated()); //断言用户已经登录\n//6、退出\nsubject.logout();\n}\n```\n\n2.1、首先通过new IniSecurityManagerFactory 并指定一个ini 配置文件来创建一个SecurityManager工厂；\n\n2.2、接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可；  \n2.3、通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结  \n束时需要解除绑定；然后获取身份验证的Token，如用户名/密码；  \n2.4、调用subject.login 方法进行登录，其会自动委托给SecurityManager.login方法进行登录；  \n2.5、如果身份验证失败请捕获AuthenticationException 或其子类;\n\n2.6、最后可以调用subject.logout退出\n\n# 3.与web集成\n\n```xml\n<dependency>\n<groupId>org.apache.shiro</groupId>\n<artifactId>shiro-web</artifactId>\n<version>1.2.2</version>\n</dependency>\n<dependency>\n<groupId>junit</groupId>\n<artifactId>junit</artifactId>\n<version>4.9</version>\n</dependency>\n<dependency>\n<groupId>commons-logging</groupId>\n<artifactId>commons-logging</artifactId>\n<version>1.1.3</version>\n</dependency>\n<dependency>\n<groupId>org.apache.shiro</groupId>\n<artifactId>shiro-core</artifactId>\n<version>1.2.2</version>\n</dependency>\n```\n\n## 必要的架包。\n\n## web.xml如图所示\n\n```xml\n<filter>\n\t\t<filter-name>shiroFilter</filter-name>\n\t\t<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n\t</filter>\n\n\t<filter-mapping>\n\t\t<filter-name>shiroFilter</filter-name>\n\t\t<url-pattern>*.shtml</url-pattern>\n\t</filter-mapping>\n```\n\nDelegatingFilterProxy作用是自动到spring容器查找名字为shiroFilter（filter-name）的bean并把所有Filter的操作委托给它，然后将ShiroFilter 配置到spring容器即可\n\n```xml\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n\t\t<property name=\"securityManager\" ref=\"securityManager\" />\n</bean>\n```\n\n## ini配置部分说明\n\n```xml\n[main]\n#默认是/login.jsp\nauthc.loginUrl=/login\nroles.unauthorizedUrl=/unauthorized\nperms.unauthorizedUrl=/unauthorized\n[users]\nzhang=123,admin\nwang=123\n[roles]\nadmin=user:*,menu:*\n[urls]\n/login=anon\n/unauthorized=anon\n/static/**=anon\n/authenticated=authc\n/role=authc,roles[admin]\n/permission=authc,perms[\"user:create\"]\n```\n\n其中最重要的就是\\[urls\\]部分的配置，其格式是： “url=拦截器\\[参数\\]，拦截器\\[参数\\]”；  \n即如果当前请求的url匹配\\[urls\\]部分的某个url模式，将会执行其配置的拦截器。比如anon  \n拦截器表示匿名访问（即不需要登录即可访问）；authc拦截器表示需要身份认证通过后才  \n能访问；roles\\[admin\\]拦截器表示需要有admin 角色授权才能访问；而perms\\[\"user:create\"\\]  \n拦截器表示需要有“user:create”权限才能访问\n\n暂时就看到这里，作一个记录，下次继续更新","tags":["shiro"]},{"title":"微信公众号接入","url":"/2017/05/20/开发相关/微信公众号接入/","content":"\nPACKAGE\n\n![](https://static.oschina.net/uploads/space/2017/0522/172756_NC0S_3429289.png)\n\n1.MenuManage\n\n```java\n/**\n * 创建菜单\n * */\npublic class MenuManager {\n\tprivate static Logger log = LoggerFactory.getLogger(MenuManager.class);\n\n\tpublic static void main(String[] args) {\n\t\t// 第三方用户唯一凭证\n\t\tString appId = \"000000000000000000\";\n\t\t// 第三方用户唯一凭证密钥\n\t\tString appSecret = \"00000000000000000000000000000000\";\n\n\t\t// 调用接口获取access_token\n\t\tAccessToken at = WeixinUtil.getAccessToken(appId, appSecret);\n\t\t\n\t\tif (null != at) {\n\t\t\t// 调用接口创建菜单\n\t\t\tint result = WeixinUtil.createMenu(getMenu(), at.getToken());\n\n\t\t\t// 判断菜单创建结果\n\t\t\tif (0 == result)\n\t\t\t\tlog.info(\"菜单创建成功！\");\n\t\t\telse\n\t\t\t\tlog.info(\"菜单创建失败，错误码：\" + result);\n\t\t}\n\t}\n\n\tprivate static Menu getMenu() {\n\t\t// TODO Auto-generated method stub\n\t\tCommonButton btn11 = new CommonButton();\n\t\tbtn11.setName(\"测试1\");\n\t\tbtn11.setType(\"click\");\n\t\tbtn11.setKey(\"11\");\n\t\t\n\t\tCommonButton btn12 = new CommonButton();\n\t\tbtn12.setName(\"测试2\");\n\t\tbtn12.setType(\"click\");\n\t\tbtn12.setKey(\"12\");\n\n\t\tCommonButton btn13 = new CommonButton();\n\t\tbtn13.setName(\"测试3\");\n\t\tbtn13.setType(\"click\");\n\t\tbtn13.setKey(\"13\");\n\n\t\tCommonButton btn14 = new CommonButton();\n\t\tbtn14.setName(\"测试4\");\n\t\tbtn14.setType(\"click\");\n\t\tbtn14.setKey(\"14\");\n\n\t\tCommonButton btn21 = new CommonButton();\n\t\tbtn21.setName(\"快递查询\");\n\t\tbtn21.setType(\"click\");\n\t\tbtn21.setKey(\"21\");\n\n\t\tCommonButton btn22 = new CommonButton();\n\t\tbtn22.setName(\"经典游戏\");\n\t\tbtn22.setType(\"click\");\n\t\tbtn22.setKey(\"22\");\n\n\n\t\tCommonButton btn23 = new CommonButton();\n\t\tbtn23.setName(\"聊天唠嗑\");\n\t\tbtn23.setType(\"click\");\n\t\tbtn23.setKey(\"23\");\n\n\n\t\tCommonButton btn31 = new CommonButton();\n\t\tbtn31.setName(\"Q友圈\");\n\t\tbtn31.setType(\"click\");\n\t\tbtn31.setKey(\"31\");\n\n\t\tCommonButton btn32 = new CommonButton();\n\t\tbtn32.setName(\"电影排行榜\");\n\t\tbtn32.setType(\"click\");\n\t\tbtn32.setKey(\"32\");\n\n\t\tCommonButton btn33 = new CommonButton();\n\t\tbtn33.setName(\"更多帮助\");\n\t\tbtn33.setType(\"click\");\n\t\tbtn33.setKey(\"33\");\n\n\t\tComplexButton mainBtn1 = new ComplexButton();\n\t\tmainBtn1.setName(\"测试按钮\");\n\t\tmainBtn1.setSub_button(new CommonButton[] { btn11, btn12, btn13, btn14 });\n\n\t\tComplexButton mainBtn2 = new ComplexButton();\n\t\tmainBtn2.setName(\"休闲驿站\");\n\t\tmainBtn2.setSub_button(new CommonButton[] { btn21, btn22, btn23});\n\n\t\tComplexButton mainBtn3 = new ComplexButton();\n\t\tmainBtn3.setName(\"更多帮助\");\n\t\tmainBtn3.setSub_button(new CommonButton[] { btn31, btn32, btn33 });\n\n\t\t/**\n\t\t * 此菜单结构，每个一级菜单都有二级菜单项\n\t\t */\n\t\tMenu menu = new Menu();\n\t\tmenu.setButton(new Button[] { mainBtn1, mainBtn2, btn33 });\n\t\t\n\t\treturn menu;\n\t}\n\n}\n```\n\nBaseServlet\n\n```java\npublic class BaseServlet extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * 认证微信服务器\n\t */\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t// 微信加密签名\n\t\tString signature = req.getParameter(\"signature\");\n\t\t// 时间\n\t\tString timestamp = req.getParameter(\"timestamp\");\n\t\t// 随机数\n\t\tString nonce = req.getParameter(\"nonce\");\n\t\t// 随机字符串\n\t\tString echostr = req.getParameter(\"echostr\");\n\t\tPrintWriter out = resp.getWriter();\n\t\t// 通过检验signature对请求进行校验，若校验成功则原样返回echostr，表示接入成功，否则接入失败\n\t\tif (SignUtil.checkSignature(signature, timestamp, nonce)) {\n\t\t\tout.print(echostr);\n\t\t}\n\t\tout.close();\n\t\tout = null;\n\t}\n\n\t/**\n\t * 用户消息处理\n\t */\n\t@Override\n\tprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\t// 将请求、响应的编码均设置为UTF-8（防止中文乱码）\n\t\treq.setCharacterEncoding(\"UTF-8\");\n\t\tresp.setCharacterEncoding(\"UTF-8\");\n\t\t// Service处理请求\n\t\tString result = null;\n\t\ttry {\n\t\t\t// 默认返回内容\n\t\t\tString respContent = \"测试微信公众号\";\n\t\t\tMap<String, String> requestMap = MessageUtil.parseXml(req);\n\t\t\tString fromUserName = requestMap.get(\"FromUserName\");\n\t\t\tString toUserName = requestMap.get(\"ToUserName\");\n\t\t\tString msgType = requestMap.get(\"MsgType\");\t\n\t\t\tBaseService baseService=new BaseService();\n\t\t\t// 回复文本消息\n\t\t\tif(MessageUtil.REQ_MESSAGE_TYPE_TEXT.equals(msgType)){\n\t\t\t\tString content=requestMap.get(\"Content\");\n\t\t\t\tTextMessageReq textMessageReq=new TextMessageReq(toUserName, fromUserName, msgType, content);\n\t\t\t\tresult=baseService.dealTextReq(textMessageReq);\t\n\t\t\t}else if(MessageUtil.REQ_MESSAGE_TYPE_EVENT.equals(msgType)){\n\t\t\t\t// 事件类型   \n\t\t\t\tString eventType = requestMap.get(\"Event\");\n\t\t\t\tif (eventType.equals(MessageUtil.EVENT_TYPE_SUBSCRIBE)){\n\t\t\t\t\tresult = \"谢谢您的关注！回复\\\"0\\\"查看帮助\";\n\t\t\t\t}else if(MessageUtil.EVENT_TYPE_CLICK.equals(eventType)){\n\t\t\t\t\t// 菜单点击key值\n\t\t\t\t\tString eventKey = requestMap.get(\"EventKey\");  \n\t\t\t\t\tresult=baseService.dealClickReq(toUserName,fromUserName,msgType,eventKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tPrintWriter out = resp.getWriter();\n\t\tout.write(result);\n\t\tout.close();\n\n\t}\n\n}\n```\n\nBaseService\n\n```java\n/**\n * 消息处理\n */\npublic class BaseService {\n\t/**\n\t * 文本消息处理\n\t */\n\tpublic String dealTextReq(TextMessageReq textMessageReq) {\n\t\tString result = null;\n\t\tif (\"0\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(MessageTemplate.getMainMenu());\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"1\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\n\t\t\t\t\t\"<a href=\\\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\\\">点击跳转网页welcome</a>\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"2\".equals(textMessageReq.getContent())) {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\n\t\t\t\t\t\"<a href=\\\"http://rotornet.tunnel.qydev.com/WXTest/jsp/content.jsp\\\">点击跳转网页content</a>\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t} else if (\"3\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getSingleNews();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else if (\"4\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getSingleNewsNoImage();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else if (\"5\".equals(textMessageReq.getContent())) {\n\t\t\tNewsMessageResp newsMessageResp = getNewsMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\tList<ArticleResp> articles = MessageTemplate.getNews();\n\t\t\tnewsMessageResp.setArticleCount(articles.size());\n\t\t\tnewsMessageResp.setArticles(articles);\n\t\t\tresult = MessageUtil.newsMessageToXml(newsMessageResp);\n\t\t} else {\n\t\t\tTextMessageResp textMessageResp = getTextMessageResp(textMessageReq.getToUserName(),\n\t\t\t\t\ttextMessageReq.getFromUserName());\n\t\t\ttextMessageResp.setContent(\"没有找到指令，请重新输入\");\n\t\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\t}\n\t\treturn result;\n\n\t}\n\n\t/** 菜单点击事件 */\n\tpublic String dealClickReq(String toUserName, String fromUserName, String msgType, String eventKey) {\n\t\t// TODO Auto-generated method stub\n\t\tString result = null;\n\t\tTextMessageResp textMessageResp = getTextMessageResp(toUserName,fromUserName);\n\t\tif (eventKey.equals(\"11\")) {\n\t\t\ttextMessageResp.setContent(\"测试1被点击\");\n\t\t}else if (eventKey.equals(\"12\")) {\n\t\t\ttextMessageResp.setContent(\"测试2被点击\");\n\t\t}else if (eventKey.equals(\"13\")) {\n\t\t\ttextMessageResp.setContent(\"测试3被点击\");\n\t\t}else if (eventKey.equals(\"14\")) {\n\t\t\ttextMessageResp.setContent(\"测试4被点击\");\n\t\t}else if (eventKey.equals(\"21\")) {\n\t\t\ttextMessageResp.setContent(\"快递查询被点击\");\n\t\t}else if (eventKey.equals(\"22\")) {\n\t\t\ttextMessageResp.setContent(\"经典游戏被点击\");\n\t\t}else if (eventKey.equals(\"23\")) {\n\t\t\ttextMessageResp.setContent(\"聊天唠嗑被点击\");\n\t\t}else if (eventKey.equals(\"33\")) {\n\t\t\ttextMessageResp.setContent(MessageTemplate.getMainMenu());\n\t\t}else{\n\t\t\ttextMessageResp.setContent(\"未找到功能\");\n\t\t}\n\t\tresult = MessageUtil.textMessageToXml(textMessageResp);\n\t\treturn result;\n\t}\n\t/**此处和接收到的发送者，接受者相反*/\n\tprivate NewsMessageResp getNewsMessageResp(String fromUserName, String toUserName) {\n\t\t// TODO Auto-generated method stub\n\t\tNewsMessageResp newsMessage = new NewsMessageResp();\n\t\tnewsMessage.setFromUserName(fromUserName);\n\t\tnewsMessage.setToUserName(toUserName);\n\t\tnewsMessage.setCreateTime(new Date().getTime());\n\t\tnewsMessage.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_NEWS);\n\t\tnewsMessage.setFuncFlag(0);\n\t\treturn newsMessage;\n\t}\n\t/**此处和接收到的发送者，接受者相反*/\n\tprivate TextMessageResp getTextMessageResp(String fromUserName, String toUserName) {\n\t\tTextMessageResp textMessageResp = new TextMessageResp();\n\t\ttextMessageResp.setFromUserName(fromUserName);\n\t\ttextMessageResp.setToUserName(toUserName);\n\t\ttextMessageResp.setCreateTime(new Date().getTime());\n\t\ttextMessageResp.setMsgType(MessageUtil.RESP_MESSAGE_TYPE_TEXT);\n\t\ttextMessageResp.setFuncFlag(0);\n\t\treturn textMessageResp;\n\t}\n}\n```\n\nMessageTemplate\n\n```java\n/**\n * 消息模板\n */\npublic class MessageTemplate {\n\t/**\n\t * 主菜单消息\n\t */\n\tpublic static String getMainMenu() {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tbuffer.append(\"您好/::)，请回复数字选择服务：\").append(\"\\n\\n\");\n\t\tbuffer.append(\"1  网页welcome预览\").append(\"\\n\");\n\t\tbuffer.append(\"2  网页content预览\").append(\"\\n\");\n\t\tbuffer.append(\"3  单图文消息预览1\").append(\"\\n\");\n\t\tbuffer.append(\"4  单图文消息预览2\").append(\"\\n\");\n\t\tbuffer.append(\"5  多图文消息预览\").append(\"\\n\\n\");\n\t\tbuffer.append(\"回复“0”显示此帮助菜单\");\n\t\treturn buffer.toString();\n\t}\n\n\t/**\n\t * 超链接信息\n\t */\n\tpublic static String getUrlContent(String content, String url) {\n\t\treturn \"<a href=\\\"\" + url + \"\\\">\" + content + \"</a>\";\n\t}\n\n\t/**\n\t * 单图文消息\n\t */\n\tpublic static List<ArticleResp> getSingleNews() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article = new ArticleResp();\n\t\tarticle.setTitle(\"微信公众帐号开发教程Java版\");\n\t\tarticle.setDescription(\"测试微信公众号单图文消息-\"+String.valueOf(Character.toChars(0x1F334))+\"\");\n\t\tarticle.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower.jpg\");\n\t\tarticle.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article);\n\t\treturn articles;\n\t}\n\n\t/**\n\t * 单图文消息---不含图片\n\t */\n\tpublic static List<ArticleResp> getSingleNewsNoImage() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article = new ArticleResp();\n\t\tarticle.setTitle(\"微信公众帐号单图文消息测试\");\n\t\tarticle.setDescription(\"测试微信公众号单图文消息--无图片\"+String.valueOf(Character.toChars(0x2764))+\"心分两半，一半清醒，一半醉\");\n\t\t//图片设置为空\n\t\tarticle.setPicUrl(\"\");\n\t\tarticle.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article);\n\t\treturn articles;\n\t}\n\t/**多图文消息*/\n\tpublic static List<ArticleResp> getNews() {\n\t\tList<ArticleResp> articles=new ArrayList<>();\n\t\tArticleResp article1 = new ArticleResp();\n\t\tarticle1.setTitle(\"微信公众号多图文消息\");\n\t\t//description页面不会显示\n\t\tarticle1.setDescription(\"\");\n\t\tarticle1.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower3.jpg\");\n\t\tarticle1.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tArticleResp article2 = new ArticleResp();\n\t\tarticle2.setTitle(\"微信\"+String.valueOf(Character.toChars(0x1F334))+\"公众号图文消息二\");\n\t\t//description页面不会显示\n\t\tarticle2.setDescription(\"\");\n\t\tarticle2.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower2.jpg\");\n\t\tarticle2.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tArticleResp article3 = new ArticleResp();\n\t\tarticle3.setTitle(\"微信\"+String.valueOf(Character.toChars(0x1F339))+\"公众号图文消息三\");\n\t\tarticle3.setPicUrl(\"http://rotornet.tunnel.qydev.com/WXTest/images/flower1.jpg\");\n\t\tarticle3.setUrl(\"http://rotornet.tunnel.qydev.com/WXTest/jsp/welcome.jsp\");\n\t\tarticles.add(article1);\n\t\tarticles.add(article2);\n\t\tarticles.add(article3);\n\t\treturn articles;\n\t}\n\t\n}\n```\n\nimages\n\n![](微信公众号接入\\1.jpg)\n\n![](微信公众号接入\\2.jpg)\n\n![](微信公众号接入\\3.jpg)\n\n![](微信公众号接入\\4.jpg)\n\nwelcome.jsp\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.css\">\n<script src=\"https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js\"></script>\n<script src=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.js\"></script>\n</head>\n\n<body>\n\n<div data-role=\"page\">\n  <div data-role=\"header\">\n    <h1>欢迎来到我的微信测试公众号</h1>\n  </div>\n\n  <div data-role=\"main\" class=\"ui-content\">\n    <p>这是一个简单的测试公众号!!</p>\n  </div>\n\n  <div data-role=\"footer\">\n    <h1>有疑问欢迎致电客服</h1>\n  </div>\n</div> \n\n</body>\n</html>\n```\n\ncontent.jsp\n\n```html\n<%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%>\n<!DOCTYPE html>\n<html>\n<head>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n<link rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.css\">\n<script src=\"https://apps.bdimg.com/libs/jquery/1.10.2/jquery.min.js\"></script>\n<script src=\"https://apps.bdimg.com/libs/jquerymobile/1.4.5/jquery.mobile-1.4.5.min.js\"></script>\n</head>\n<script>\n  function message(){\n\t  var chk_value =[]; \n\t  var name=$(\"#name\").val();\n\t  $(\"input[name='favcolor']:checked\").each(function(){\n\t\t  chk_value.push($(this).val()); \n\t  });\n\t  alert(\"您的全名是:\"+name+\" 您喜欢的颜色是：\"+chk_value);\n  }\n</script>\n<body>\n\n<div data-role=\"page\">\n  <div data-role=\"header\">\n  <h1>公众号主题页面</h1>\n  </div>\n  <div data-role=\"main\" class=\"ui-content\">\n    <form method=\"post\" >\n      <fieldset data-role=\"collapsible\" data-theme=\"b\" data-content-theme=\"b\">\n        <legend>点击可折叠</legend>\n          <label for=\"name\">全名:</label>\n          <input type=\"text\" name=\"text\" id=\"name\" data-theme=\"a\">\n          <p>喜爱的颜色:</p>\n        <div data-role=\"controlgroup\">\n          <label for=\"red\">红色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"red\" value=\"red\">\n          <label for=\"green\">绿色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"green\" value=\"green\">\n          <label for=\"blue\">蓝色</label>\n          <input type=\"checkbox\" name=\"favcolor\" id=\"blue\" value=\"blue\" >\n        </div>\t\n      <input type=\"button\" data-inline=\"true\" onclick=\"message()\"  value=\"提交\" data-theme=\"b\">\n      </fieldset>\n    </form>\n  </div>\n</div>\n\n</body>\n</html>\n```","tags":["公众号"]},{"title":"nginx+tomcat入门配置","url":"/2017/04/21/中间件/nginx/nginx+tomcat入门配置/","content":"\n    此文仅作入门学习，以及记录下配置中遇到的坑。首先nginx+tomcat主要为了实现负载均衡 (分发请求)。为了解释清楚负载均衡，这里假设www.test.com采用这种配置，当我们去访问www.test.com这个网址的时候，请求是传到了nginx服务器，然后由nginx分发到tomcat，假设我们启动了10个tomcat，nginx根据我们的配置分发请求给指定的tomcat，减轻服务器压力。\n\n# 1.工具\n\nnginx-1.8.0\n\napache-tomcat-6.0.20\n\napache-tomcat-8.0.30\n\n# 2.Nginx+tomcat配置\n\n解压后在nginx-1.8.0\\\\conf\\\\中找到Nginx配置文件nginx.conf进行配置。\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\t#location / {\n        #    proxy_pass http://backend_tomcat;\n        #}\n        }\n```\n\n先找到配置文件中server{}，这里listen 8080监听8080端口\n\n如果启动了nginx，输入http://localhost:8080会看见![](https://static.oschina.net/uploads/space/2017/0421/103109_IUKW_3429289.png)\n\n接下来取消注解location / {  \n            proxy\\_pass http://backend\\_tomcat;  \n        }这里标示将请求转发给backend_tomcat（名字随意），然后在http里配置backend_tomcat，与server同一级。\n\n```xml\nhttp{\n\tupstream backend_tomcat{\n\t\t\n\t\tserver 127.0.0.1:80 weight=1;\n\t\tserver 127.0.0.1:8888 weight=1;\n\t}\n\t\n    server {\n    }\n}\n```\n\n这里配置两个server对应两个tomcat，一个80端口的tomcat6，一个8888端口的tomcat8，weight表示访问的权重。\n\n配置好后，启动tomcat6和tomcat8，启动nginx，访问http://localhost:8080一直刷新，会看见在tomcat6和tomcat8界面切换。实现分发请求\n\n# 3.nginx实现静态分离\n\n这里主要说在使用nginx时，由于我们的请求是转发的，所以对于静态的文件无法直接加载，这里需要配置静态分离，即将js，css，image等静态资源放在nginx服务器，jsp，do，action等去分发请求。\n\n操作如下\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\n\t\tlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\t\n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   html;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\t\n\t\t\tproxy_pass http://backend_tomcat;\n\t\t}\n}\n```\n\n这里贴出代码注意，此时需要将第二点处的location /(如下图) 改为location ~ \\\\.(jsp|action)$(如上图)，第一个表示所有请求，第二个表示拦截以.jsp或者.action结尾的请求\n\nroot html表示拦截到的静态文件去html文件夹找，这里的html文件夹表示安装目录\\\\nginx-1.8.0\\\\html文件夹，可以在html里放一个test文件夹，放一个图片test.png，启动nginx，输入http://localhost:8080/test/test.png，此时可以访问\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\tlocation / {\n            proxy_pass http://backend_tomcat;\n        }\n        }\n```\n\n# 4.nignx配置导向项目\n\n        如果按上述配置将请求转发到项目位置，并将项目静态文件放到html文件夹下，此时发现报错，查看文件时发现在服务器的jsp页面中的basePath会被解析为backend_tomcat加上端口+项目名，系统找不到backend\\_tomcat，此时需要在添加proxy\\_set\\_header Host， proxy\\_set_header，这里作用及时重写请求头，防止后端服务器处理时认为所有请求都来自反向代理服务器。\n\n```xml\nserver {\n        listen       8080;\n        server_name  localhost;\n\t\t\n\t\t#location / {\n        #    proxy_pass http://backend_tomcat;\n        #}\n\t\tlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   filetest;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n\t\t\tproxy_pass http://backend_tomcat;\n\t\t}\n```\n\n如图，配置后，重跑ngnix，发现请求地址对了，但是对于nginx中的静态文件未显示端口，加载不出静态文件。此时再加上host中的端口，如下图\n\n```xml\nlocation ~ .*\\.(css|js|gif|jpg|png|bmp|swf)$   #由nginx处理静态页面\n        {\n\t\t\tproxy_set_header Host  $host:8080; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n            expires 10d;   #使用expires缓存模块，缓存到客户端30天\n\t\t\troot   filetest;\n        }\n\t\t\n\t\tlocation ~ \\.(jsp|action)$ {\n\t\t\tproxy_set_header Host  $host; \n\t\t\tproxy_set_header X-Real-IP $remote_addr; \n\t\t\tproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; \n\t\t\tproxy_pass http://backend_tomcat;\n```\n\n重新启动nginx，配置完成，正常访问","tags":["nginx"]}]